[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive neighborhood exploration with multi-objective path relinking, prioritizing solutions with diverse trade-off improvements by dynamically adjusting segment lengths and evaluating edge contributions in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: adaptive segment relocation with multi-objective evaluation\n    new_solution = base_solution.copy()\n\n    # Step 1: Select a segment to relocate (adaptive length based on solution quality)\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Step 2: Find best insertion point considering both objectives\n    best_pos = start\n    best_cost = (float('inf'), float('inf'))\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue  # Skip current position\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            np.delete(new_solution, np.arange(start, start + segment_length))\n        ])\n\n        # Evaluate both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Update best position if Pareto-dominant or better in both objectives\n        if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n            best_pos = pos\n            best_cost = (cost1, cost2)\n\n    # Apply the best insertion\n    if best_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, np.arange(start, start + segment_length))\n        ])\n\n    # Step 3: Optional 3-opt refinement for local fine-tuning\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j] = np.flip(candidate[i:j])\n        candidate[j:k] = np.flip(candidate[j:k])\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            8.456247986649833,
            7.2823942042704175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search: adaptive segment relocation with multi-objective evaluation\n    new_solution = base_solution.copy()\n\n    # Step 1: Select a segment to relocate (adaptive length based on solution quality)\n    segment_length = max(2, min(5, n // 5))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Step 2: Find best insertion point considering both objectives\n    best_pos = start\n    best_cost = (float('inf'), float('inf'))\n\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue  # Skip current position\n\n        # Create candidate solution\n        candidate = np.concatenate([\n            new_solution[:pos],\n            segment,\n            np.delete(new_solution, np.arange(start, start + segment_length))\n        ])\n\n        # Evaluate both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Update best position if Pareto-dominant or better in both objectives\n        if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n            best_pos = pos\n            best_cost = (cost1, cost2)\n\n    # Apply the best insertion\n    if best_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, np.arange(start, start + segment_length))\n        ])\n\n    # Step 3: Optional 3-opt refinement for local fine-tuning\n    if n >= 4:\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j] = np.flip(candidate[i:j])\n        candidate[j:k] = np.flip(candidate[j:k])\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Accept if both objectives improve or one improves significantly\n        if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel heuristic function selects a solution from the archive based on a weighted sum of objective values and diversity, then applies a hybrid local search combining edge insertion and segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-consecutive edges to break\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = sorted([i, j])\n    if i == 0 and j == n-1:\n        j = 1  # Ensure non-consecutive\n\n    # Extract segments and remaining nodes\n    segment1 = new_solution[i:j+1]\n    remaining_nodes = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert segment1 at a random position in remaining nodes\n    insert_pos = np.random.randint(len(remaining_nodes) + 1)\n    new_solution = np.concatenate([remaining_nodes[:insert_pos], segment1, remaining_nodes[insert_pos:]])\n\n    # Further improve with segment relocation\n    if len(new_solution) > 4:\n        k = np.random.randint(2, len(new_solution)-2)\n        segment2 = new_solution[k:]\n        remaining_nodes = new_solution[:k]\n        insert_pos = np.random.randint(len(remaining_nodes) + 1)\n        new_solution = np.concatenate([remaining_nodes[:insert_pos], segment2, remaining_nodes[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            8.81927815584651,
            9.87204079085622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.rand(2)\n    weighted_scores = objectives @ weights\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: edge insertion + segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-consecutive edges to break\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = sorted([i, j])\n    if i == 0 and j == n-1:\n        j = 1  # Ensure non-consecutive\n\n    # Extract segments and remaining nodes\n    segment1 = new_solution[i:j+1]\n    remaining_nodes = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert segment1 at a random position in remaining nodes\n    insert_pos = np.random.randint(len(remaining_nodes) + 1)\n    new_solution = np.concatenate([remaining_nodes[:insert_pos], segment1, remaining_nodes[insert_pos:]])\n\n    # Further improve with segment relocation\n    if len(new_solution) > 4:\n        k = np.random.randint(2, len(new_solution)-2)\n        segment2 = new_solution[k:]\n        remaining_nodes = new_solution[:k]\n        insert_pos = np.random.randint(len(remaining_nodes) + 1)\n        new_solution = np.concatenate([remaining_nodes[:insert_pos], segment2, remaining_nodes[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{This algorithm intelligently selects a high-quality solution from the archive by prioritizing those with the best trade-off between the two objectives, then applies a hybrid local search combining multiple moves (e.g., 3-opt with adaptive segment selection and a novel \"objective-balanced\" perturbation) to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (highest trade-off)\n    def tradeoff_score(obj):\n        return obj[0] * obj[1] / (obj[0] + obj[1] + 1e-10)  # Avoid division by zero\n\n    archive_sorted = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_size = max(3, min(n // 4, 10))\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n\n    # Objective-balanced 3-opt move\n    def compute_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    current_cost = compute_cost(new_solution)\n\n    # Try all possible 3-opt moves in the segment\n    best_improvement = 0\n    best_new_solution = new_solution.copy()\n\n    for a in range(i, j):\n        for b in range(a+1, j):\n            for c in range(b+1, j):\n                # Try different permutations\n                for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                    temp_sol = new_solution.copy()\n                    temp_sol[a], temp_sol[b], temp_sol[c] = temp_sol[perm[0]], temp_sol[perm[1]], temp_sol[perm[2]]\n                    new_cost = compute_cost(temp_sol)\n\n                    # Objective-balanced improvement measure\n                    improvement = (current_cost[0] - new_cost[0]) * (current_cost[1] - new_cost[1])\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_new_solution = temp_sol.copy()\n\n    # If no improvement, apply a random but feasible perturbation\n    if best_improvement <= 0:\n        a, b = np.random.choice(n, 2, replace=False)\n        best_new_solution[a], best_new_solution[b] = best_new_solution[b], best_new_solution[a]\n\n    return best_new_solution\n\n",
        "score": [
            8.899636535670597,
            9.151065014359624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution (highest trade-off)\n    def tradeoff_score(obj):\n        return obj[0] * obj[1] / (obj[0] + obj[1] + 1e-10)  # Avoid division by zero\n\n    archive_sorted = sorted(archive, key=lambda x: tradeoff_score(x[1]))\n    selected = archive_sorted[0][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection\n    segment_size = max(3, min(n // 4, 10))\n    i = np.random.randint(0, n - segment_size)\n    j = i + segment_size\n\n    # Objective-balanced 3-opt move\n    def compute_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    current_cost = compute_cost(new_solution)\n\n    # Try all possible 3-opt moves in the segment\n    best_improvement = 0\n    best_new_solution = new_solution.copy()\n\n    for a in range(i, j):\n        for b in range(a+1, j):\n            for c in range(b+1, j):\n                # Try different permutations\n                for perm in [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)]:\n                    temp_sol = new_solution.copy()\n                    temp_sol[a], temp_sol[b], temp_sol[c] = temp_sol[perm[0]], temp_sol[perm[1]], temp_sol[perm[2]]\n                    new_cost = compute_cost(temp_sol)\n\n                    # Objective-balanced improvement measure\n                    improvement = (current_cost[0] - new_cost[0]) * (current_cost[1] - new_cost[1])\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_new_solution = temp_sol.copy()\n\n    # If no improvement, apply a random but feasible perturbation\n    if best_improvement <= 0:\n        a, b = np.random.choice(n, 2, replace=False)\n        best_new_solution[a], best_new_solution[b] = best_new_solution[b], best_new_solution[a]\n\n    return best_new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of objective diversity and dominance, then applies a novel segment rotation and edge insertion operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Novel segment rotation and edge insertion\n    a = random.randint(0, n-5)\n    b = random.randint(a+2, n-3)\n    c = random.randint(b+1, n-1)\n\n    # Rotate segment and insert\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Random edge insertion\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    if random.random() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.056294828620439,
            7.657084585017431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Novel segment rotation and edge insertion\n    a = random.randint(0, n-5)\n    b = random.randint(a+2, n-3)\n    c = random.randint(b+1, n-1)\n\n    # Rotate segment and insert\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Random edge insertion\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    if random.random() < 0.5:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment insertion and edge relocation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        base_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 2, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment from its current position\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 4: Apply edge relocation if beneficial\n    for _ in range(2):\n        u = random.randint(0, n - 1)\n        v = random.randint(0, n - 1)\n        if u == v:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[u-1], new_solution[u]] + distance_matrix_1[new_solution[v-1], new_solution[v]]\n        new_cost1 = distance_matrix_1[new_solution[u-1], new_solution[v]] + distance_matrix_1[new_solution[v-1], new_solution[u]]\n\n        current_cost2 = distance_matrix_2[new_solution[u-1], new_solution[u]] + distance_matrix_2[new_solution[v-1], new_solution[v]]\n        new_cost2 = distance_matrix_2[new_solution[u-1], new_solution[v]] + distance_matrix_2[new_solution[v-1], new_solution[u]]\n\n        # Apply relocation if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n",
        "score": [
            9.17030521873705,
            9.02962803179074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        base_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 2, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment from its current position\n    remaining = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 4: Apply edge relocation if beneficial\n    for _ in range(2):\n        u = random.randint(0, n - 1)\n        v = random.randint(0, n - 1)\n        if u == v:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[u-1], new_solution[u]] + distance_matrix_1[new_solution[v-1], new_solution[v]]\n        new_cost1 = distance_matrix_1[new_solution[u-1], new_solution[v]] + distance_matrix_1[new_solution[v-1], new_solution[u]]\n\n        current_cost2 = distance_matrix_2[new_solution[u-1], new_solution[u]] + distance_matrix_2[new_solution[v-1], new_solution[v]]\n        new_cost2 = distance_matrix_2[new_solution[u-1], new_solution[v]] + distance_matrix_2[new_solution[v-1], new_solution[u]]\n\n        # Apply relocation if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a novel hybrid local search that combines segment insertion with edge swapping and node reinsertion, while ensuring feasibility through careful validation of all operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Step 1: Select a solution with high Pareto dominance or diverse objectives\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if len(pareto_front) > 0:\n        base_solution = random.choice(pareto_front).copy()\n    else:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Apply segment insertion with validation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    k = random.randint(0, n - 1)\n    while k in range(i, j+1):\n        k = random.randint(0, n - 1)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n\n    # Step 3: Apply edge swapping if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 4: Apply node reinsertion if beneficial\n    c = random.randint(0, n - 1)\n    node = new_solution[c]\n    new_solution = np.delete(new_solution, c)\n\n    d = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, d, node)\n\n    return new_solution\n\n",
        "score": [
            10.503750591825918,
            10.722724724822537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Step 1: Select a solution with high Pareto dominance or diverse objectives\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if len(pareto_front) > 0:\n        base_solution = random.choice(pareto_front).copy()\n    else:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 2: Apply segment insertion with validation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    k = random.randint(0, n - 1)\n    while k in range(i, j+1):\n        k = random.randint(0, n - 1)\n\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n\n    # Step 3: Apply edge swapping if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 4: Apply node reinsertion if beneficial\n    c = random.randint(0, n - 1)\n    node = new_solution[c]\n    new_solution = np.delete(new_solution, c)\n\n    d = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, d, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% or at least 1 solution\n        selection_pool = archive_sorted[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Combine segment reversal and node insertion\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    # Remove node from current position\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    # Insert node at a random position\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Step 3: Check if the new solution is better in at least one objective\n    old_obj1 = archive[selected_idx][1][0] if len(archive) > 1 else sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    old_obj2 = archive[selected_idx][1][1] if len(archive) > 1 else sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    new_obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    new_obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n    # Revert if not better in at least one objective\n    if (new_obj1 > old_obj1 and new_obj2 > old_obj2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.03425814189195,
            9.861298249987604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 30% or at least 1 solution\n        selection_pool = archive_sorted[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: Combine segment reversal and node insertion\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Randomly select a node and insert it in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    # Remove node from current position\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    # Insert node at a random position\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    # Step 3: Check if the new solution is better in at least one objective\n    old_obj1 = archive[selected_idx][1][0] if len(archive) > 1 else sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    old_obj2 = archive[selected_idx][1][1] if len(archive) > 1 else sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    new_obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    new_obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n    # Revert if not better in at least one objective\n    if (new_obj1 > old_obj1 and new_obj2 > old_obj2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This novel algorithm selects a diverse solution from the archive by prioritizing those with high objective value differences, then applies a combination of segment rotation and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    objective_diff = [(abs(obj[0] - obj[1]), i) for i, obj in enumerate(objectives)]\n    objective_diff.sort(reverse=True, key=lambda x: x[0])\n    selected_idx = objective_diff[0][1] if objective_diff else random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node from the segment elsewhere\n    if n > 4:\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.372498834974598,
            7.400892359072884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    objective_diff = [(abs(obj[0] - obj[1]), i) for i, obj in enumerate(objectives)]\n    objective_diff.sort(reverse=True, key=lambda x: x[0])\n    selected_idx = objective_diff[0][1] if objective_diff else random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node from the segment elsewhere\n    if n > 4:\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of crowding distance and Pareto dominance, then applies a segment inversion and edge exchange operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion and edge exchange\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n    k = random.randint(0, n-1)\n\n    # Invert segment\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Exchange edges if beneficial\n    if k > 0 and k < n-1:\n        a, b, c = new_solution[k-1], new_solution[k], new_solution[k+1]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n        new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n        cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n        new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost2 < cost2 and new_cost1 <= cost1):\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.5744898907213765,
            8.56620296883984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion and edge exchange\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n    k = random.randint(0, n-1)\n\n    # Invert segment\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Exchange edges if beneficial\n    if k > 0 and k < n-1:\n        a, b, c = new_solution[k-1], new_solution[k], new_solution[k+1]\n        cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n        new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n        cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n        new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost2 < cost2 and new_cost1 <= cost1):\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This novel algorithm selects a high-diversity solution from the archive, then applies a combination of partial tour rotation and edge insertion operations to generate a neighbor solution while maintaining feasibility, balancing exploration and exploitation through adaptive segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity (far from centroid)\n    objectives = np.array([obj for (sol, obj) in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective improvement potential\n    segment_size = max(3, min(10, n // 4))\n    start = random.randint(0, n - segment_size - 1)\n    end = start + segment_size\n\n    # Partial tour rotation operation\n    rotated = np.roll(new_solution[start:end], random.randint(1, segment_size-1))\n    new_solution[start:end] = rotated\n\n    # Edge insertion operation\n    if n >= 5:\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            # Insert node a between node b and its successor\n            new_solution = np.concatenate([\n                new_solution[:b+1],\n                np.array([new_solution[a]]),\n                new_solution[b+1:a] if a > b else new_solution[a:b],\n                new_solution[a+1:] if a > b else new_solution[b:]\n            ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            7.863071276833354,
            7.95973920265832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity (far from centroid)\n    objectives = np.array([obj for (sol, obj) in archive])\n    centroid = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - centroid, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective improvement potential\n    segment_size = max(3, min(10, n // 4))\n    start = random.randint(0, n - segment_size - 1)\n    end = start + segment_size\n\n    # Partial tour rotation operation\n    rotated = np.roll(new_solution[start:end], random.randint(1, segment_size-1))\n    new_solution[start:end] = rotated\n\n    # Edge insertion operation\n    if n >= 5:\n        a, b = random.sample(range(n), 2)\n        if abs(a - b) > 1:\n            # Insert node a between node b and its successor\n            new_solution = np.concatenate([\n                new_solution[:b+1],\n                np.array([new_solution[a]]),\n                new_solution[b+1:a] if a > b else new_solution[a:b],\n                new_solution[a+1:] if a > b else new_solution[b:]\n            ])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This algorithm selects a solution from the archive based on the diversity of its objectives, then applies a novel segment insertion and edge reversal operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Find solution with most diverse objectives\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(objectives[i][0] - objectives[i][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to remove\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Remove the segment and insert it elsewhere\n    removed_segment = new_solution[i+1:j]\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j:]])\n\n    # Step 3: Find insertion position that minimizes both objectives\n    best_pos = i+1\n    best_improvement = 0\n\n    for pos in range(len(new_solution)):\n        if pos == len(new_solution) - 1:\n            # Insert at the end\n            temp_solution = np.concatenate([new_solution, removed_segment])\n        else:\n            # Insert in the middle\n            temp_solution = np.concatenate([new_solution[:pos], removed_segment, new_solution[pos:]])\n\n        # Calculate cost change for both objectives\n        if pos == 0:\n            prev_node = temp_solution[-1]\n        else:\n            prev_node = temp_solution[pos-1]\n\n        if pos == len(temp_solution) - 1:\n            next_node = temp_solution[0]\n        else:\n            next_node = temp_solution[pos]\n\n        # Original cost\n        orig_cost1 = distance_matrix_1[prev_node, next_node]\n        orig_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # New cost after insertion\n        new_cost1 = (distance_matrix_1[prev_node, removed_segment[0]] +\n                     distance_matrix_1[removed_segment[-1], next_node])\n        new_cost2 = (distance_matrix_2[prev_node, removed_segment[0]] +\n                     distance_matrix_2[removed_segment[-1], next_node])\n\n        improvement1 = orig_cost1 - new_cost1\n        improvement2 = orig_cost2 - new_cost2\n\n        # Combine improvements (weighted sum)\n        total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # Perform the best insertion\n    if best_pos == len(new_solution):\n        new_solution = np.concatenate([new_solution, removed_segment])\n    else:\n        new_solution = np.concatenate([new_solution[:best_pos], removed_segment, new_solution[best_pos:]])\n\n    # Step 4: Randomly reverse a segment if beneficial\n    if n >= 4:\n        rev_i = random.randint(0, n - 3)\n        rev_j = random.randint(rev_i + 1, n - 1)\n\n        # Calculate cost change for both objectives\n        prev_node = new_solution[rev_i-1] if rev_i > 0 else new_solution[-1]\n        next_node = new_solution[rev_j]\n\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[rev_i]] + distance_matrix_1[new_solution[rev_j], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[rev_i]] + distance_matrix_2[new_solution[rev_j], next_node]\n\n        new_cost1 = distance_matrix_1[prev_node, new_solution[rev_j]] + distance_matrix_1[new_solution[rev_i], next_node]\n        new_cost2 = distance_matrix_2[prev_node, new_solution[rev_j]] + distance_matrix_2[new_solution[rev_i], next_node]\n\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[rev_i:rev_j+1] = new_solution[rev_i:rev_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.89135188194251,
            10.47278610853075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Find solution with most diverse objectives\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(objectives[i][0] - objectives[i][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to remove\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Remove the segment and insert it elsewhere\n    removed_segment = new_solution[i+1:j]\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j:]])\n\n    # Step 3: Find insertion position that minimizes both objectives\n    best_pos = i+1\n    best_improvement = 0\n\n    for pos in range(len(new_solution)):\n        if pos == len(new_solution) - 1:\n            # Insert at the end\n            temp_solution = np.concatenate([new_solution, removed_segment])\n        else:\n            # Insert in the middle\n            temp_solution = np.concatenate([new_solution[:pos], removed_segment, new_solution[pos:]])\n\n        # Calculate cost change for both objectives\n        if pos == 0:\n            prev_node = temp_solution[-1]\n        else:\n            prev_node = temp_solution[pos-1]\n\n        if pos == len(temp_solution) - 1:\n            next_node = temp_solution[0]\n        else:\n            next_node = temp_solution[pos]\n\n        # Original cost\n        orig_cost1 = distance_matrix_1[prev_node, next_node]\n        orig_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # New cost after insertion\n        new_cost1 = (distance_matrix_1[prev_node, removed_segment[0]] +\n                     distance_matrix_1[removed_segment[-1], next_node])\n        new_cost2 = (distance_matrix_2[prev_node, removed_segment[0]] +\n                     distance_matrix_2[removed_segment[-1], next_node])\n\n        improvement1 = orig_cost1 - new_cost1\n        improvement2 = orig_cost2 - new_cost2\n\n        # Combine improvements (weighted sum)\n        total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # Perform the best insertion\n    if best_pos == len(new_solution):\n        new_solution = np.concatenate([new_solution, removed_segment])\n    else:\n        new_solution = np.concatenate([new_solution[:best_pos], removed_segment, new_solution[best_pos:]])\n\n    # Step 4: Randomly reverse a segment if beneficial\n    if n >= 4:\n        rev_i = random.randint(0, n - 3)\n        rev_j = random.randint(rev_i + 1, n - 1)\n\n        # Calculate cost change for both objectives\n        prev_node = new_solution[rev_i-1] if rev_i > 0 else new_solution[-1]\n        next_node = new_solution[rev_j]\n\n        orig_cost1 = distance_matrix_1[prev_node, new_solution[rev_i]] + distance_matrix_1[new_solution[rev_j], next_node]\n        orig_cost2 = distance_matrix_2[prev_node, new_solution[rev_i]] + distance_matrix_2[new_solution[rev_j], next_node]\n\n        new_cost1 = distance_matrix_1[prev_node, new_solution[rev_j]] + distance_matrix_1[new_solution[rev_i], next_node]\n        new_cost2 = distance_matrix_2[prev_node, new_solution[rev_j]] + distance_matrix_2[new_solution[rev_i], next_node]\n\n        if (new_cost1 < orig_cost1) or (new_cost2 < orig_cost2):\n            new_solution[rev_i:rev_j+1] = new_solution[rev_i:rev_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a combination of edge exchange and segment reversal operations with adaptive segment lengths to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for diversity\n        crowding = np.zeros(len(archive))\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        for i in range(1, len(sorted_archive)-1):\n            crowding[i] = (sorted_archive[i+1][1][0] - sorted_archive[i-1][1][0]) / (sorted_archive[-1][1][0] - sorted_archive[0][1][0])\n\n        # Combine with Pareto dominance (simplified)\n        scores = [crowding[i] + 0.5 * (1 - i/len(archive)) for i in range(len(archive))]\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    max_segment = min(n//2, 5)\n    segment_length = random.randint(2, max_segment)\n\n    # Randomly select segments with adaptive length\n    i = random.randint(0, n - segment_length - 2)\n    j = i + segment_length\n\n    # Reverse the segment\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.7:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and random.random() < 0.8) or (new_cost2 < current_cost2 and random.random() < 0.8):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.55336680250413,
            6.661277768434564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for diversity\n        crowding = np.zeros(len(archive))\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        for i in range(1, len(sorted_archive)-1):\n            crowding[i] = (sorted_archive[i+1][1][0] - sorted_archive[i-1][1][0]) / (sorted_archive[-1][1][0] - sorted_archive[0][1][0])\n\n        # Combine with Pareto dominance (simplified)\n        scores = [crowding[i] + 0.5 * (1 - i/len(archive)) for i in range(len(archive))]\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    max_segment = min(n//2, 5)\n    segment_length = random.randint(2, max_segment)\n\n    # Randomly select segments with adaptive length\n    i = random.randint(0, n - segment_length - 2)\n    j = i + segment_length\n\n    # Reverse the segment\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.7:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and random.random() < 0.8) or (new_cost2 < current_cost2 and random.random() < 0.8):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on Pareto dominance and applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(5, n - start - 1))\n\n    # Rotate the segment right by one position\n    segment = new_solution[start:start+length]\n    new_solution[start:start+length] = np.roll(segment, 1)\n\n    # Randomly insert an edge if beneficial\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.728480580415678,
            6.273869808069713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(5, n - start - 1))\n\n    # Rotate the segment right by one position\n    segment = new_solution[start:start+length]\n    new_solution[start:start+length] = np.roll(segment, 1)\n\n    # Randomly insert an edge if beneficial\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on Pareto dominance and applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(5, n - start - 1))\n\n    # Rotate the segment right by one position\n    segment = new_solution[start:start+length]\n    new_solution[start:start+length] = np.roll(segment, 1)\n\n    # Randomly insert an edge if beneficial\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.728480580415678,
            6.273869808069713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(5, n - start - 1))\n\n    # Rotate the segment right by one position\n    segment = new_solution[start:start+length]\n    new_solution[start:start+length] = np.roll(segment, 1)\n\n    # Randomly insert an edge if beneficial\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select three distinct segments\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 1, n - 3)\n    c = random.randint(b + 1, n - 2)\n\n    # Step 2: Rearrange the segments in a new order\n    new_order = [new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]\n    new_solution = np.concatenate(new_order)\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.1007278602723085,
            6.807901633709799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select three distinct segments\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 1, n - 3)\n    c = random.randint(b + 1, n - 2)\n\n    # Step 2: Rearrange the segments in a new order\n    new_order = [new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]\n    new_solution = np.concatenate(new_order)\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select three distinct segments\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 1, n - 3)\n    c = random.randint(b + 1, n - 2)\n\n    # Step 2: Rearrange the segments in a new order\n    new_order = [new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]\n    new_solution = np.concatenate(new_order)\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.1007278602723085,
            6.807901633709799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]  # Simple sum of objectives\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select three distinct segments\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 1, n - 3)\n    c = random.randint(b + 1, n - 2)\n\n    # Step 2: Rearrange the segments in a new order\n    new_order = [new_solution[:a], new_solution[b:c], new_solution[a:b], new_solution[c:]]\n    new_solution = np.concatenate(new_order)\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and non-dominated status, then applies a novel segment-based crossover with adaptive segment length selection to generate a neighbor solution, ensuring feasibility through careful segment insertion and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity or non-dominated status\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n    non_dominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    non_dominated[i] = False\n                    break\n\n    selection_scores = diversity + non_dominated.astype(float) * 2\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Adaptive segment length selection\n    segment_length = min(3, max(1, int(np.sqrt(n))))\n\n    # Select a random segment\n    start = random.randint(0, n - segment_length - 1)\n    segment = base_solution[start:start+segment_length]\n\n    # Find insertion points that maintain feasibility\n    remaining_nodes = np.setdiff1d(np.arange(n), segment)\n    insert_pos = random.randint(0, len(remaining_nodes) - 1)\n\n    # Create new solution by inserting the segment\n    new_solution = np.concatenate([\n        remaining_nodes[:insert_pos],\n        segment,\n        remaining_nodes[insert_pos:]\n    ])\n\n    # Validate the solution\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            9.63281957539051,
            9.883479505648758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high diversity or non-dominated status\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n    non_dominated = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    non_dominated[i] = False\n                    break\n\n    selection_scores = diversity + non_dominated.astype(float) * 2\n    selected_idx = np.argmax(selection_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Adaptive segment length selection\n    segment_length = min(3, max(1, int(np.sqrt(n))))\n\n    # Select a random segment\n    start = random.randint(0, n - segment_length - 1)\n    segment = base_solution[start:start+segment_length]\n\n    # Find insertion points that maintain feasibility\n    remaining_nodes = np.setdiff1d(np.arange(n), segment)\n    insert_pos = random.randint(0, len(remaining_nodes) - 1)\n\n    # Create new solution by inserting the segment\n    new_solution = np.concatenate([\n        remaining_nodes[:insert_pos],\n        segment,\n        remaining_nodes[insert_pos:]\n    ])\n\n    # Validate the solution\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{This new algorithm prioritizes solutions with high crowding distance in the Pareto front, then applies a combination of segment reversal and edge insertion operations to generate neighbors while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = 0\n    else:\n        # Calculate crowding distances\n        objectives = [obj for _, obj in archive]\n        objectives_sorted = sorted(objectives, key=lambda x: (x[0], x[1]))\n\n        crowding = [0] * len(archive)\n        for m in range(2):  # For each objective\n            sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][m])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(archive)-1):\n                if objectives_sorted[sorted_idx[i+1]][m] == objectives_sorted[sorted_idx[i-1]][m]:\n                    continue\n                crowding[sorted_idx[i]] += (objectives_sorted[sorted_idx[i+1]][m] - objectives_sorted[sorted_idx[i-1]][m]) / (objectives_sorted[-1][m] - objectives_sorted[0][m])\n\n        selected_idx = crowding.index(max(crowding))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Segment reversal\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Edge insertion\n    k = random.randint(0, n-2)\n    l = random.randint(0, n-1)\n    if k != l and k+1 != l and k != l+1:\n        # Insert node l after node k\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n        insert_pos = np.where(new_solution == new_solution[k])[0][0] + 1\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            9.131928924176345,
            10.153265409457855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = 0\n    else:\n        # Calculate crowding distances\n        objectives = [obj for _, obj in archive]\n        objectives_sorted = sorted(objectives, key=lambda x: (x[0], x[1]))\n\n        crowding = [0] * len(archive)\n        for m in range(2):  # For each objective\n            sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][m])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n            for i in range(1, len(archive)-1):\n                if objectives_sorted[sorted_idx[i+1]][m] == objectives_sorted[sorted_idx[i-1]][m]:\n                    continue\n                crowding[sorted_idx[i]] += (objectives_sorted[sorted_idx[i+1]][m] - objectives_sorted[sorted_idx[i-1]][m]) / (objectives_sorted[-1][m] - objectives_sorted[0][m])\n\n        selected_idx = crowding.index(max(crowding))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Segment reversal\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Edge insertion\n    k = random.randint(0, n-2)\n    l = random.randint(0, n-1)\n    if k != l and k+1 != l and k != l+1:\n        # Insert node l after node k\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n        insert_pos = np.where(new_solution == new_solution[k])[0][0] + 1\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity, then applies a combination of segment insertion and edge rotation operations to create a neighbor solution while ensuring feasibility by maintaining the TSP tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a random position\n    pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    # Rotate edges to potentially improve both objectives\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 2)\n\n    # Calculate current and potential costs for rotation\n    current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_1[new_solution[l], new_solution[l+1]] +\n                     distance_matrix_1[new_solution[k], new_solution[l]])\n\n    new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[l], new_solution[k]] +\n                distance_matrix_1[new_solution[k], new_solution[l+1]])\n\n    current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_2[new_solution[l], new_solution[l+1]] +\n                     distance_matrix_2[new_solution[k], new_solution[l]])\n\n    new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[l], new_solution[k]] +\n                distance_matrix_2[new_solution[k], new_solution[l+1]])\n\n    # Apply rotation if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        temp = new_solution[k:l+1].copy()\n        new_solution[k:l+1] = temp[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.3989903450224395,
            6.87770687680468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a random position\n    pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    # Rotate edges to potentially improve both objectives\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 2)\n\n    # Calculate current and potential costs for rotation\n    current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_1[new_solution[l], new_solution[l+1]] +\n                     distance_matrix_1[new_solution[k], new_solution[l]])\n\n    new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[l], new_solution[k]] +\n                distance_matrix_1[new_solution[k], new_solution[l+1]])\n\n    current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_2[new_solution[l], new_solution[l+1]] +\n                     distance_matrix_2[new_solution[k], new_solution[l]])\n\n    new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[l], new_solution[k]] +\n                distance_matrix_2[new_solution[k], new_solution[l+1]])\n\n    # Apply rotation if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        temp = new_solution[k:l+1].copy()\n        new_solution[k:l+1] = temp[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment relinking and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and relink it to another position\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Insert a random node from the removed segment into another position\n    if len(segment) > 1:\n        node_to_insert = random.choice(segment)\n        remaining_after_insert = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos+len(segment):]])\n        insert_pos_new = random.randint(0, len(remaining_after_insert))\n        new_solution = np.concatenate([remaining_after_insert[:insert_pos_new], [node_to_insert], remaining_after_insert[insert_pos_new:]])\n\n    return new_solution\n\n",
        "score": [
            10.427050963333144,
            10.664516809590072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and relink it to another position\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment from the solution\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Insert a random node from the removed segment into another position\n    if len(segment) > 1:\n        node_to_insert = random.choice(segment)\n        remaining_after_insert = np.concatenate([new_solution[:insert_pos], new_solution[insert_pos+len(segment):]])\n        insert_pos_new = random.randint(0, len(remaining_after_insert))\n        new_solution = np.concatenate([remaining_after_insert[:insert_pos_new], [node_to_insert], remaining_after_insert[insert_pos_new:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on both objective diversity and dominance, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct positions\n    a, b, c = random.sample(range(n), 3)\n    a, b, c = sorted([a, b, c])\n\n    # Step 2: Perform edge insertion\n    if random.random() < 0.5:\n        # Insert edge (a, c) between b and a\n        segment = new_solution[b:c]\n        new_solution[b:c] = new_solution[b+1:c+1]\n        new_solution[c] = new_solution[a]\n    else:\n        # Reverse segment between a and c\n        segment = new_solution[a+1:c]\n        new_solution[a+1:c] = segment[::-1]\n\n    # Step 3: Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.466344239368992,
            10.635121308411755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three distinct positions\n    a, b, c = random.sample(range(n), 3)\n    a, b, c = sorted([a, b, c])\n\n    # Step 2: Perform edge insertion\n    if random.random() < 0.5:\n        # Insert edge (a, c) between b and a\n        segment = new_solution[b:c]\n        new_solution[b:c] = new_solution[b+1:c+1]\n        new_solution[c] = new_solution[a]\n    else:\n        # Reverse segment between a and c\n        segment = new_solution[a+1:c]\n        new_solution[a+1:c] = segment[::-1]\n\n    # Step 3: Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments with higher probability for larger segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    if random.random() < 0.3:  # 30% chance to select larger segments\n        i = random.randint(0, max(0, n - 10))\n        j = random.randint(i + 2, min(n - 2, i + 8))\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial for both objectives\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.51360154322163,
            10.609933186703184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments with higher probability for larger segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    if random.random() < 0.3:  # 30% chance to select larger segments\n        i = random.randint(0, max(0, n - 10))\n        j = random.randint(i + 2, min(n - 2, i + 8))\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial for both objectives\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment insertion and edge reversal operations, followed by a probabilistic edge swap to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and insert it elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a new random position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 2: Reverse a random segment if beneficial\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Calculate costs before and after reversal\n    before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    after_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    after_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Probabilistically swap two edges\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.682937855276181,
            8.498157116080284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and insert it elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a new random position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 2: Reverse a random segment if beneficial\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Calculate costs before and after reversal\n    before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    after_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    after_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n        new_solution[i:j+1] = segment[::-1]\n\n    # Step 3: Probabilistically swap two edges\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(i, j)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node into a different position\n    m = random.randint(0, n - 1)\n    node = new_solution[m]\n    new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.102176592890957,
            6.013121299168331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(i, j)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node into a different position\n    m = random.randint(0, n - 1)\n    node = new_solution[m]\n    new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(i, j)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node into a different position\n    m = random.randint(0, n - 1)\n    node = new_solution[m]\n    new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.102176592890957,
            6.013121299168331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(i, j)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node into a different position\n    m = random.randint(0, n - 1)\n    node = new_solution[m]\n    new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion, segment rotation, and edge reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 5)\n    j = random.randint(i + 2, n - 3)\n    k = random.randint(j + 1, n - 1)\n\n    # Step 2: Rotate the segment (insert after k)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k+1], segment, new_solution[k+1:]])\n\n    # Step 3: Reverse a random edge if beneficial\n    l = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[l], new_solution[l+1]]\n    current_cost2 = distance_matrix_2[new_solution[l], new_solution[l+1]]\n\n    # Calculate potential cost after reversal\n    new_cost1 = distance_matrix_1[new_solution[l+1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[l+1], new_solution[l]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[l], new_solution[l+1] = new_solution[l+1], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            10.400183235724853,
            10.631515855076838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 5)\n    j = random.randint(i + 2, n - 3)\n    k = random.randint(j + 1, n - 1)\n\n    # Step 2: Rotate the segment (insert after k)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k+1], segment, new_solution[k+1:]])\n\n    # Step 3: Reverse a random edge if beneficial\n    l = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[l], new_solution[l+1]]\n    current_cost2 = distance_matrix_2[new_solution[l], new_solution[l+1]]\n\n    # Calculate potential cost after reversal\n    new_cost1 = distance_matrix_1[new_solution[l+1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[l+1], new_solution[l]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[l], new_solution[l+1] = new_solution[l+1], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{An adaptive local search algorithm that selects a solution from the archive based on its dominance and diversity, then applies a novel combination of segment rotation and edge reinsertion operations to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance or diversity\n    if len(archive) > 1:\n        # Calculate dominance scores (simplified)\n        dominance_scores = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for other_sol, other_obj in archive:\n                if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated += 1\n            dominance_scores.append(dominated)\n\n        # Select the least dominated solution\n        selected_idx = dominance_scores.index(min(dominance_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Rotate the segment left by one position\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Randomly reinsert an edge\n    if n >= 4:\n        u = random.randint(0, n - 2)\n        v = random.randint(u + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[u-1], new_solution[u]] +\n                         distance_matrix_1[new_solution[v-1], new_solution[v]])\n        new_cost1 = (distance_matrix_1[new_solution[u-1], new_solution[v]] +\n                    distance_matrix_1[new_solution[v-1], new_solution[u]])\n\n        current_cost2 = (distance_matrix_2[new_solution[u-1], new_solution[u]] +\n                        distance_matrix_2[new_solution[v-1], new_solution[v]])\n        new_cost2 = (distance_matrix_2[new_solution[u-1], new_solution[v]] +\n                    distance_matrix_2[new_solution[v-1], new_solution[u]])\n\n        # Apply reinsertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Reinsert the edge (swap nodes)\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n",
        "score": [
            7.453258965842988,
            7.324123631601825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high dominance or diversity\n    if len(archive) > 1:\n        # Calculate dominance scores (simplified)\n        dominance_scores = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for other_sol, other_obj in archive:\n                if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated += 1\n            dominance_scores.append(dominated)\n\n        # Select the least dominated solution\n        selected_idx = dominance_scores.index(min(dominance_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Rotate the segment left by one position\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Randomly reinsert an edge\n    if n >= 4:\n        u = random.randint(0, n - 2)\n        v = random.randint(u + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[u-1], new_solution[u]] +\n                         distance_matrix_1[new_solution[v-1], new_solution[v]])\n        new_cost1 = (distance_matrix_1[new_solution[u-1], new_solution[v]] +\n                    distance_matrix_1[new_solution[v-1], new_solution[u]])\n\n        current_cost2 = (distance_matrix_2[new_solution[u-1], new_solution[u]] +\n                        distance_matrix_2[new_solution[v-1], new_solution[v]])\n        new_cost2 = (distance_matrix_2[new_solution[u-1], new_solution[v]] +\n                    distance_matrix_2[new_solution[v-1], new_solution[u]])\n\n        # Apply reinsertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Reinsert the edge (swap nodes)\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(obj[0] - obj[1] for obj in objectives)\n        selected_idx = [i for i, obj in enumerate(objectives) if abs(obj[0] - obj[1]) == max_diff][0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    if k < i or k > j:\n        inserted_segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], inserted_segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    reversed_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    reversed_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.372027483411268,
            5.052907828361045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(obj[0] - obj[1] for obj in objectives)\n        selected_idx = [i for i, obj in enumerate(objectives) if abs(obj[0] - obj[1]) == max_diff][0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    if k < i or k > j:\n        inserted_segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], inserted_segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    reversed_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    reversed_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(obj[0] - obj[1] for obj in objectives)\n        selected_idx = [i for i, obj in enumerate(objectives) if abs(obj[0] - obj[1]) == max_diff][0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    if k < i or k > j:\n        inserted_segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], inserted_segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    reversed_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    reversed_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.372027483411268,
            5.052907828361045
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(obj[0] - obj[1] for obj in objectives)\n        selected_idx = [i for i, obj in enumerate(objectives) if abs(obj[0] - obj[1]) == max_diff][0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    if k < i or k > j:\n        inserted_segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], inserted_segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    reversed_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    reversed_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a scoring function that combines Pareto dominance and objective diversity, then applies a combination of segment reversal and edge exchange operations with adaptive neighborhood selection to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective diversity\n        dominance = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        diversity = (obj[0] - obj[1]) ** 2  # Encourages solutions with balanced objectives\n        scores.append(dominance + diversity)\n\n    # Select solution with highest score\n    selected_idx = scores.index(max(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive neighborhood selection\n    segment_size = max(2, n // 5)\n    i = random.randint(0, n - segment_size - 1)\n    j = i + segment_size\n\n    # Segment reversal\n    middle_segment = new_solution[i:j]\n    new_solution[i:j] = middle_segment[::-1]\n\n    # Edge exchange with adaptive selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate potential improvement\n    delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n             (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n    delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n             (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n    # Apply if beneficial for at least one objective with adaptive threshold\n    threshold = 0.05 * (distance_matrix_1[0,0] + distance_matrix_2[0,0])  # Small fraction of average distance\n    if (delta1 < -threshold) or (delta2 < -threshold):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.495878372204778,
            10.545304195363698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective diversity\n        dominance = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        diversity = (obj[0] - obj[1]) ** 2  # Encourages solutions with balanced objectives\n        scores.append(dominance + diversity)\n\n    # Select solution with highest score\n    selected_idx = scores.index(max(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive neighborhood selection\n    segment_size = max(2, n // 5)\n    i = random.randint(0, n - segment_size - 1)\n    j = i + segment_size\n\n    # Segment reversal\n    middle_segment = new_solution[i:j]\n    new_solution[i:j] = middle_segment[::-1]\n\n    # Edge exchange with adaptive selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate potential improvement\n    delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n             (distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n    delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n             (distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n    # Apply if beneficial for at least one objective with adaptive threshold\n    threshold = 0.05 * (distance_matrix_1[0,0] + distance_matrix_2[0,0])  # Small fraction of average distance\n    if (delta1 < -threshold) or (delta2 < -threshold):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate weights based on objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        weights = 0.7 * norm_obj[:, 0] + 0.3 * norm_obj[:, 1] + 0.2 * np.random.rand(len(archive))\n        selected_idx = np.argmax(weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(1, j - i - 1)\n\n    # Rotate the segment\n    segment = new_solution[i+1:j+1]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node elsewhere if beneficial\n    if n > 4:\n        m = random.randint(0, n - 1)\n        p = random.randint(0, n - 1)\n        if m != p:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n            new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n            current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n            new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n            # Apply insertion if beneficial\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                node = new_solution[m]\n                new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n                insert_pos = p if p < m else p - 1\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            10.254693503095368,
            10.502337540723126
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate weights based on objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        weights = 0.7 * norm_obj[:, 0] + 0.3 * norm_obj[:, 1] + 0.2 * np.random.rand(len(archive))\n        selected_idx = np.argmax(weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(1, j - i - 1)\n\n    # Rotate the segment\n    segment = new_solution[i+1:j+1]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node elsewhere if beneficial\n    if n > 4:\n        m = random.randint(0, n - 1)\n        p = random.randint(0, n - 1)\n        if m != p:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n            new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n            current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n            new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n            # Apply insertion if beneficial\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                node = new_solution[m]\n                new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n                insert_pos = p if p < m else p - 1\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion, segment reversal, and edge exchange operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Node insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Segment reversal with benefit check\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n    new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n    new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Edge exchange with benefit check\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.782015261772404,
            6.753176121038091
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Node insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Segment reversal with benefit check\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n    new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n    new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j+1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Edge exchange with benefit check\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel combination of segment insertion and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy() if archive else np.array([])\n\n    # Identify solutions with potential for improvement in both objectives\n    median_obj1 = np.median([obj[0] for obj in objectives])\n    median_obj2 = np.median([obj[1] for obj in objectives])\n    candidates = [(i, s, obj) for i, (s, obj) in enumerate(archive)\n                  if obj[0] > median_obj1 or obj[1] > median_obj2]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = candidates[random.randint(0, len(candidates) - 1)][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply novel local search operator\n    # Step 1: Randomly select a segment to remove\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Step 2: Remove the segment and insert it elsewhere\n    removed_segment = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n    insert_pos = random.randint(0, n - seg_length - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], removed_segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply conditional edge swapping\n    for _ in range(2):  # Apply swaps a few times\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.684841065357129,
            6.809019432498408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy() if archive else np.array([])\n\n    # Identify solutions with potential for improvement in both objectives\n    median_obj1 = np.median([obj[0] for obj in objectives])\n    median_obj2 = np.median([obj[1] for obj in objectives])\n    candidates = [(i, s, obj) for i, (s, obj) in enumerate(archive)\n                  if obj[0] > median_obj1 or obj[1] > median_obj2]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive) - 1)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = candidates[random.randint(0, len(candidates) - 1)][1].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply novel local search operator\n    # Step 1: Randomly select a segment to remove\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(4, n - seg_start - 1))\n    seg_end = seg_start + seg_length\n\n    # Step 2: Remove the segment and insert it elsewhere\n    removed_segment = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n    insert_pos = random.randint(0, n - seg_length - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], removed_segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply conditional edge swapping\n    for _ in range(2):  # Apply swaps a few times\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined heuristic that considers both objective values and solution diversity, then applies a novel segment insertion and edge rotation operator to generate a neighbor solution while ensuring feasibility through careful validation of the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        combined_scores = np.sum(normalized, axis=1)\n        diversity_scores = np.array([np.std(normalized[i]) for i in range(len(archive))])\n        total_scores = combined_scores + diversity_scores\n        selected_idx = np.argmax(total_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Apply novel segment insertion and edge rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    segment = new_solution[i:j]\n\n    # Remove segment and insert at a different position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Rotate edges in the inserted segment\n    k = random.randint(0, len(segment) - 2)\n    segment = np.roll(segment, k)\n\n    # Reconstruct the solution with rotated segment\n    new_solution[insert_pos:insert_pos+len(segment)] = segment\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            10.456275654189083,
            10.633087194022673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        combined_scores = np.sum(normalized, axis=1)\n        diversity_scores = np.array([np.std(normalized[i]) for i in range(len(archive))])\n        total_scores = combined_scores + diversity_scores\n        selected_idx = np.argmax(total_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Apply novel segment insertion and edge rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    segment = new_solution[i:j]\n\n    # Remove segment and insert at a different position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Rotate edges in the inserted segment\n    k = random.randint(0, len(segment) - 2)\n    segment = np.roll(segment, k)\n\n    # Reconstruct the solution with rotated segment\n    new_solution[insert_pos:insert_pos+len(segment)] = segment\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a combination of edge insertion and segment inversion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Invert the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Randomly insert a node from one segment to another\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            10.501382827045314,
            10.631831490452267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Invert the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Randomly insert a node from one segment to another\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified: select the one with the best combined score)\n        scores = [sum(obj) for _, obj in archive]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.105070278368307,
            5.931977199948847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified: select the one with the best combined score)\n        scores = [sum(obj) for _, obj in archive]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This novel algorithm selects a solution from the archive with high Pareto dominance, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility by maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], x[1][0] * x[1][1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a new random position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.005353943060307,
            6.319787961540186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], x[1][0] * x[1][1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a new random position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This novel algorithm selects a solution from the archive with high Pareto dominance, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility by maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], x[1][0] * x[1][1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a new random position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.005353943060307,
            6.319787961540186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], x[1][0] * x[1][1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a new random position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = normalized.sum(axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select a segment and reverse it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent nodes if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            10.39358096201504,
            10.641553218941961
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = normalized.sum(axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select a segment and reverse it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent nodes if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for idx, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = idx\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select three random non-adjacent nodes\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform a 3-opt move (a, b, c) -> (a, c, b)\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 3: Check if the move improves at least one objective\n    def calculate_cost(sol, matrix):\n        cost = 0\n        for i in range(n):\n            cost += matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if (new_cost1 > current_cost1 and new_cost2 > current_cost2):\n        # If the move worsens both objectives, try another approach\n        # Step 4: Perform a node insertion\n        node = random.randint(0, n-1)\n        pos = random.randint(0, n-1)\n        if node != pos:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.3534887732394685,
            5.736407845752355
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for idx, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = idx\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select three random non-adjacent nodes\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform a 3-opt move (a, b, c) -> (a, c, b)\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 3: Check if the move improves at least one objective\n    def calculate_cost(sol, matrix):\n        cost = 0\n        for i in range(n):\n            cost += matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if (new_cost1 > current_cost1 and new_cost2 > current_cost2):\n        # If the move worsens both objectives, try another approach\n        # Step 4: Perform a node insertion\n        node = random.randint(0, n-1)\n        pos = random.randint(0, n-1)\n        if node != pos:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility, incorporating adaptive segment selection and probabilistic edge swapping based on objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective diversity\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n    else:\n        j = random.randint(2, n - 2)\n        i = random.randint(0, j - 2)\n\n    # Reverse the selected segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Probabilistic edge swapping based on objective improvements\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        improvement_prob = 0.7 if (new_cost1 < current_cost1 or new_cost2 < current_cost2) else 0.3\n        if random.random() < improvement_prob:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.492074453661905,
            6.961220494319837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective diversity\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n    else:\n        j = random.randint(2, n - 2)\n        i = random.randint(0, j - 2)\n\n    # Reverse the selected segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Probabilistic edge swapping based on objective improvements\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        improvement_prob = 0.7 if (new_cost1 < current_cost1 or new_cost2 < current_cost2) else 0.3\n        if random.random() < improvement_prob:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.828413874192279,
            6.415053189709719
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted score combining Pareto dominance and objective diversity, then applies a hybrid local search combining segment reversal and edge exchange with adaptive depth, ensuring feasibility while exploring diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective diversity\n        dominance = sum(1 for s, _ in archive if obj[0] < s[0] and obj[1] < s[1])\n        diversity = max(abs(obj[0] - obj[1]), 1.0)  # Avoid division by zero\n        score = dominance + 0.5 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 3))\n    i = random.randint(0, n - segment_length - 1)\n    segment = new_solution[i:i+segment_length]\n    new_solution[i:i+segment_length] = segment[::-1]\n\n    # Step 2: Edge exchange with adaptive depth\n    depth = random.randint(1, min(3, n // 4))\n    for _ in range(depth):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.543184157224607,
            9.149612748439996
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective diversity\n        dominance = sum(1 for s, _ in archive if obj[0] < s[0] and obj[1] < s[1])\n        diversity = max(abs(obj[0] - obj[1]), 1.0)  # Avoid division by zero\n        score = dominance + 0.5 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 3))\n    i = random.randint(0, n - segment_length - 1)\n    segment = new_solution[i:i+segment_length]\n    new_solution[i:i+segment_length] = segment[::-1]\n\n    # Step 2: Edge exchange with adaptive depth\n    depth = random.randint(1, min(3, n // 4))\n    for _ in range(depth):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and crowding distance, then applies a segment insertion and edge rotation operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance or highest crowding distance\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.choice([0, 1]) if len(archive_sorted) > 1 else 0\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Remove the segment and insert it at a different position\n    segment = new_solution[i:j].copy()\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Rotate a segment of the solution\n    k = random.randint(0, len(new_solution) - 4)\n    l = random.randint(k + 2, len(new_solution) - 1)\n    rotation = random.randint(1, l - k - 1)\n    new_solution[k:l] = np.roll(new_solution[k:l], rotation)\n\n    return new_solution\n\n",
        "score": [
            6.517237440446754,
            6.6750136248115055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance or highest crowding distance\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.choice([0, 1]) if len(archive_sorted) > 1 else 0\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Remove the segment and insert it at a different position\n    segment = new_solution[i:j].copy()\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Rotate a segment of the solution\n    k = random.randint(0, len(new_solution) - 4)\n    l = random.randint(k + 2, len(new_solution) - 1)\n    rotation = random.randint(1, l - k - 1)\n    new_solution[k:l] = np.roll(new_solution[k:l], rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of Pareto dominance and crowding distance to identify promising candidates, then applies a novel hybrid operator that combines segment reversal with adaptive edge insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: Segment reversal with adaptive edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.869790419061286,
            6.143612667861421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: Segment reversal with adaptive edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of Pareto dominance and crowding distance to identify promising candidates, then applies a novel hybrid operator that combines segment reversal with adaptive edge insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: Segment reversal with adaptive edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.869790419061286,
            6.143612667861421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: Segment reversal with adaptive edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random node and remove it from the tour\n    node_idx = random.randint(0, n - 1)\n    removed_node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Step 2: Find the best position to reinsert the removed node\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(1, n):\n        # Calculate cost before insertion\n        prev_node = new_solution[pos - 1]\n        next_node = new_solution[pos] if pos < n - 1 else new_solution[0]\n\n        old_cost1 = distance_matrix_1[prev_node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node]\n\n        # Calculate improvement (negative for worsening)\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 3: Apply segment rotation if beneficial\n    if n > 5:\n        # Randomly select a segment to rotate\n        seg_start = random.randint(0, n - 5)\n        seg_length = random.randint(2, min(4, n - seg_start - 1))\n\n        segment = new_solution[seg_start:seg_start + seg_length]\n        rotated_segment = np.roll(segment, 1)\n\n        # Calculate cost before and after rotation\n        prev_node = new_solution[seg_start - 1] if seg_start > 0 else new_solution[-1]\n        next_node = new_solution[seg_start + seg_length] if seg_start + seg_length < n else new_solution[0]\n\n        old_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        new_cost1 = distance_matrix_1[prev_node, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], next_node]\n\n        old_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        new_cost2 = distance_matrix_2[prev_node, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], next_node]\n\n        # Apply rotation if beneficial for at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[seg_start:seg_start + seg_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            7.57250413394346,
            6.250804629422383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random node and remove it from the tour\n    node_idx = random.randint(0, n - 1)\n    removed_node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Step 2: Find the best position to reinsert the removed node\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(1, n):\n        # Calculate cost before insertion\n        prev_node = new_solution[pos - 1]\n        next_node = new_solution[pos] if pos < n - 1 else new_solution[0]\n\n        old_cost1 = distance_matrix_1[prev_node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, next_node]\n\n        # Calculate cost after insertion\n        new_cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node]\n\n        # Calculate improvement (negative for worsening)\n        improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 3: Apply segment rotation if beneficial\n    if n > 5:\n        # Randomly select a segment to rotate\n        seg_start = random.randint(0, n - 5)\n        seg_length = random.randint(2, min(4, n - seg_start - 1))\n\n        segment = new_solution[seg_start:seg_start + seg_length]\n        rotated_segment = np.roll(segment, 1)\n\n        # Calculate cost before and after rotation\n        prev_node = new_solution[seg_start - 1] if seg_start > 0 else new_solution[-1]\n        next_node = new_solution[seg_start + seg_length] if seg_start + seg_length < n else new_solution[0]\n\n        old_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        new_cost1 = distance_matrix_1[prev_node, rotated_segment[0]] + distance_matrix_1[rotated_segment[-1], next_node]\n\n        old_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n        new_cost2 = distance_matrix_2[prev_node, rotated_segment[0]] + distance_matrix_2[rotated_segment[-1], next_node]\n\n        # Apply rotation if beneficial for at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[seg_start:seg_start + seg_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its crowding distance in the objective space, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distances for all solutions\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    # Sort objectives by each dimension\n    sorted_indices1 = np.argsort([obj[0] for obj in objectives])\n    sorted_indices2 = np.argsort([obj[1] for obj in objectives])\n\n    # Compute crowding distances\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices1[i+1]][0] - objectives[sorted_indices1[i-1]][0]) / (objectives[sorted_indices1[-1]][0] - objectives[sorted_indices1[0]][0]) + \\\n                                   (objectives[sorted_indices2[i+1]][1] - objectives[sorted_indices2[i-1]][1]) / (objectives[sorted_indices2[-1]][1] - objectives[sorted_indices2[0]][1])\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Rotate segment [i:j] to position k\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Apply node insertion if beneficial\n    l = random.randint(0, n - 1)\n    m = random.randint(0, n - 1)\n\n    if l != m:\n        current_cost1 = distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[m-1], new_solution[m]]\n        new_cost1 = distance_matrix_1[new_solution[l-1], new_solution[m]] + distance_matrix_1[new_solution[m-1], new_solution[l]]\n\n        current_cost2 = distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[m-1], new_solution[m]]\n        new_cost2 = distance_matrix_2[new_solution[l-1], new_solution[m]] + distance_matrix_2[new_solution[m-1], new_solution[l]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert node m after node l\n            new_solution = np.concatenate([new_solution[:l+1], [new_solution[m]], new_solution[l+1:m], new_solution[m+1:]])\n\n    return new_solution\n\n",
        "score": [
            9.6904565132118,
            10.082668303998808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distances for all solutions\n    objectives = [obj for _, obj in archive]\n    crowding_distances = np.zeros(len(objectives))\n\n    # Sort objectives by each dimension\n    sorted_indices1 = np.argsort([obj[0] for obj in objectives])\n    sorted_indices2 = np.argsort([obj[1] for obj in objectives])\n\n    # Compute crowding distances\n    for i in range(len(objectives)):\n        if i == 0 or i == len(objectives) - 1:\n            crowding_distances[i] = float('inf')\n        else:\n            crowding_distances[i] = (objectives[sorted_indices1[i+1]][0] - objectives[sorted_indices1[i-1]][0]) / (objectives[sorted_indices1[-1]][0] - objectives[sorted_indices1[0]][0]) + \\\n                                   (objectives[sorted_indices2[i+1]][1] - objectives[sorted_indices2[i-1]][1]) / (objectives[sorted_indices2[-1]][1] - objectives[sorted_indices2[0]][1])\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n\n    # Rotate segment [i:j] to position k\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Apply node insertion if beneficial\n    l = random.randint(0, n - 1)\n    m = random.randint(0, n - 1)\n\n    if l != m:\n        current_cost1 = distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[m-1], new_solution[m]]\n        new_cost1 = distance_matrix_1[new_solution[l-1], new_solution[m]] + distance_matrix_1[new_solution[m-1], new_solution[l]]\n\n        current_cost2 = distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[m-1], new_solution[m]]\n        new_cost2 = distance_matrix_2[new_solution[l-1], new_solution[m]] + distance_matrix_2[new_solution[m-1], new_solution[l]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert node m after node l\n            new_solution = np.concatenate([new_solution[:l+1], [new_solution[m]], new_solution[l+1:m], new_solution[m+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This novel algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility, and additionally incorporates a novel segment insertion strategy that intelligently relocates segments to improve both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Step 2: Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Step 3: Insert the segment at a random new position\n    k = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 4: Apply a segment reversal if beneficial\n    l = random.randint(0, n - 4)\n    m = random.randint(l + 2, n - 2)\n\n    current_cost1 = distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[m-1], new_solution[m]]\n    new_cost1 = distance_matrix_1[new_solution[l-1], new_solution[m]] + distance_matrix_1[new_solution[m-1], new_solution[l]]\n\n    current_cost2 = distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[m-1], new_solution[m]]\n    new_cost2 = distance_matrix_2[new_solution[l-1], new_solution[m]] + distance_matrix_2[new_solution[m-1], new_solution[l]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        middle_segment = new_solution[l+1:m]\n        new_solution[l+1:m] = middle_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            6.7413236306471855,
            6.934479169332863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Step 2: Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Step 3: Insert the segment at a random new position\n    k = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 4: Apply a segment reversal if beneficial\n    l = random.randint(0, n - 4)\n    m = random.randint(l + 2, n - 2)\n\n    current_cost1 = distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[m-1], new_solution[m]]\n    new_cost1 = distance_matrix_1[new_solution[l-1], new_solution[m]] + distance_matrix_1[new_solution[m-1], new_solution[l]]\n\n    current_cost2 = distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[m-1], new_solution[m]]\n    new_cost2 = distance_matrix_2[new_solution[l-1], new_solution[m]] + distance_matrix_2[new_solution[m-1], new_solution[l]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        middle_segment = new_solution[l+1:m]\n        new_solution[l+1:m] = middle_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a hybrid local search that combines segment insertion and node swapping with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by first objective (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        # Select from top 20% of solutions\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 5 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly swap two nodes with probability based on cost improvement\n    i, j = random.sample(range(n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Accept swap if at least one objective improves\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.808306659805302,
            9.712745174338405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by first objective (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        # Select from top 20% of solutions\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 5 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly swap two nodes with probability based on cost improvement\n    i, j = random.sample(range(n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Accept swap if at least one objective improves\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a hybrid local search that combines segment insertion and node swapping with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by first objective (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        # Select from top 20% of solutions\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 5 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly swap two nodes with probability based on cost improvement\n    i, j = random.sample(range(n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Accept swap if at least one objective improves\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.808306659805302,
            9.712745174338405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by first objective (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        # Select from top 20% of solutions\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 5 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly swap two nodes with probability based on cost improvement\n    i, j = random.sample(range(n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Accept swap if at least one objective improves\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of crowding distance and Pareto dominance, then applies a segment inversion and edge swap operation guided by a multi-objective improvement heuristic to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    crowding_distances = []\n    for sol, _ in archive:\n        crowding_dist = 0\n        for i in range(len(sol)):\n            prev_node = sol[i-1]\n            curr_node = sol[i]\n            next_node = sol[(i+1) % len(sol)]\n            crowding_dist += (distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node] +\n                              distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node])\n        crowding_distances.append(crowding_dist)\n\n    # Select the solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to invert\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly select two edges to swap if beneficial\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]])\n    new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[i]])\n\n    current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n    new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n       (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.510222037680887,
            10.625915772000843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    crowding_distances = []\n    for sol, _ in archive:\n        crowding_dist = 0\n        for i in range(len(sol)):\n            prev_node = sol[i-1]\n            curr_node = sol[i]\n            next_node = sol[(i+1) % len(sol)]\n            crowding_dist += (distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node] +\n                              distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node])\n        crowding_distances.append(crowding_dist)\n\n    # Select the solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to invert\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Step 2: Randomly select two edges to swap if beneficial\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]])\n    new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j-1], new_solution[i]])\n\n    current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]])\n    new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n       (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a hybrid of Pareto dominance and objective diversity, then applies a combination of segment insertion and edge rotation operations to create a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective values\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        diversity = np.sum(np.abs(objectives - mean_obj), axis=1)\n\n        # Combine Pareto dominance and diversity\n        dominance = np.array([sum(1 for _, obj2 in archive if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1])) for _, obj in archive])\n        scores = 0.7 * dominance + 0.3 * diversity\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and edge rotation\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a or abs(b - a) == 1:\n        b = random.randint(0, n-1)\n\n    # Insert segment between a and b\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a+1:b]\n    new_solution = np.concatenate([new_solution[:a+1], segment, new_solution[a+1:b], new_solution[b:]])\n\n    # Rotate edges around a random node\n    c = random.randint(1, n-2)\n    new_solution = np.roll(new_solution, -c)\n\n    # Check if beneficial for at least one objective\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Generate a random neighbor for comparison\n    temp_solution = new_solution.copy()\n    d = random.randint(0, n-1)\n    e = random.randint(0, n-1)\n    temp_solution[d], temp_solution[e] = temp_solution[e], temp_solution[d]\n\n    temp_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n    temp_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n    if (temp_cost1 < current_cost1) or (temp_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            10.50858061422606,
            10.651511714161233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective values\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        diversity = np.sum(np.abs(objectives - mean_obj), axis=1)\n\n        # Combine Pareto dominance and diversity\n        dominance = np.array([sum(1 for _, obj2 in archive if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1])) for _, obj in archive])\n        scores = 0.7 * dominance + 0.3 * diversity\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and edge rotation\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a or abs(b - a) == 1:\n        b = random.randint(0, n-1)\n\n    # Insert segment between a and b\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a+1:b]\n    new_solution = np.concatenate([new_solution[:a+1], segment, new_solution[a+1:b], new_solution[b:]])\n\n    # Rotate edges around a random node\n    c = random.randint(1, n-2)\n    new_solution = np.roll(new_solution, -c)\n\n    # Check if beneficial for at least one objective\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Generate a random neighbor for comparison\n    temp_solution = new_solution.copy()\n    d = random.randint(0, n-1)\n    e = random.randint(0, n-1)\n    temp_solution[d], temp_solution[e] = temp_solution[e], temp_solution[d]\n\n    temp_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n    temp_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n    if (temp_cost1 < current_cost1) or (temp_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance_scores = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            score = 0\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j:\n                    if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                        score += 1\n            dominance_scores.append(score)\n\n        # Select a solution with high dominance score or random if all equal\n        max_score = max(dominance_scores)\n        candidates = [i for i, score in enumerate(dominance_scores) if score == max_score]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.506884965225507,
            6.623146424827068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance_scores = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            score = 0\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j:\n                    if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                        score += 1\n            dominance_scores.append(score)\n\n        # Select a solution with high dominance score or random if all equal\n        max_score = max(dominance_scores)\n        candidates = [i for i, score in enumerate(dominance_scores) if score == max_score]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{An enhanced local search algorithm selects a solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of segment relocation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        selected_idx = random.randint(0, min(2, len(archive)-1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Remove the segment and insert it elsewhere\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly insert an edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[k+1], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[k+1], new_solution[(l+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[l:l+1], new_solution[k+1:l], new_solution[k:k+1], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.505500472164994,
            6.550971299370365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n        selected_idx = random.randint(0, min(2, len(archive)-1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Remove the segment and insert it elsewhere\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly insert an edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[k+1], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[k+1], new_solution[(l+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[l:l+1], new_solution[k+1:l], new_solution[k:k+1], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment reshuffling and adaptive edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reshuffle its nodes\n    segment_length = random.randint(2, min(5, n-1))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n    random.shuffle(segment)\n    new_solution[start_pos:start_pos+segment_length] = segment\n\n    # Step 2: Adaptive edge insertion based on objective improvement\n    for _ in range(2):\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a == b:\n            continue\n\n        # Calculate potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.61031113239934,
            7.653858179013752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reshuffle its nodes\n    segment_length = random.randint(2, min(5, n-1))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n    random.shuffle(segment)\n    new_solution[start_pos:start_pos+segment_length] = segment\n\n    # Step 2: Adaptive edge insertion based on objective improvement\n    for _ in range(2):\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a == b:\n            continue\n\n        # Calculate potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = abs(obj[0] - obj[1])\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.749940275768585,
            7.460490786294024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = abs(obj[0] - obj[1])\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere\n    node_to_insert = random.randint(0, n - 1)\n    insert_pos = random.randint(0, n - 1)\n    if insert_pos != node_to_insert:\n        node = new_solution[node_to_insert]\n        new_solution = np.delete(new_solution, node_to_insert)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.186168630912176,
            7.498317261923946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere\n    node_to_insert = random.randint(0, n - 1)\n    insert_pos = random.randint(0, n - 1)\n    if insert_pos != node_to_insert:\n        node = new_solution[node_to_insert]\n        new_solution = np.delete(new_solution, node_to_insert)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(archive[i][1][0] - archive[i][1][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c == d:\n        d = (d + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[d-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[d-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, c, new_solution[d])\n        new_solution = np.delete(new_solution, d + (1 if d > c else 0))\n\n    return new_solution\n\n",
        "score": [
            4.642535375401237,
            9.873569304166386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(archive[i][1][0] - archive[i][1][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c == d:\n        d = (d + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[d-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[d-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, c, new_solution[d])\n        new_solution = np.delete(new_solution, d + (1 if d > c else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(archive[i][1][0] - archive[i][1][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c == d:\n        d = (d + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[d-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[d-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, c, new_solution[d])\n        new_solution = np.delete(new_solution, d + (1 if d > c else 0))\n\n    return new_solution\n\n",
        "score": [
            4.642535375401237,
            9.873569304166386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(archive[i][1][0] - archive[i][1][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c == d:\n        d = (d + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[d-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[d-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, c, new_solution[d])\n        new_solution = np.delete(new_solution, d + (1 if d > c else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{This novel algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of adaptive segment insertion and multi-objective edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find the solution with the highest sum of objectives (diversity)\n        selected_idx = np.argmax([sum(obj) for obj in objectives])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Insert segment [i+1, j] at position i\n    segment = new_solution[i+1:j+1]\n    new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[j+1:]])\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(min(3, n // 2)):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply swap if beneficial for both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.85344973076735,
            8.891174460089108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find the solution with the highest sum of objectives (diversity)\n        selected_idx = np.argmax([sum(obj) for obj in objectives])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment insertion\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Insert segment [i+1, j] at position i\n    segment = new_solution[i+1:j+1]\n    new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[j+1:]])\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(min(3, n // 2)):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply swap if beneficial for both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a sequence of edge insertion and segment rotation operations to generate a neighbor solution while maintaining feasibility through careful validation of tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores\n        objectives = np.array([obj for (sol, obj) in archive])\n        diversity = np.linalg.norm(objectives[:, None] - objectives, axis=2).sum(axis=1)\n        # Select solution with high diversity or good quality\n        selected_idx = np.argmax(diversity + 1/(1 + np.linalg.norm(objectives, axis=1)))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Random segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Edge insertion with validation\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if l == k or l == (k + 1) % n:\n        l = (l + 1) % n\n\n    # Check if insertion is valid\n    if k != l and (k + 1) % n != l:\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        # Apply insertion if beneficial\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform insertion\n            if k < l:\n                new_solution = np.concatenate([new_solution[:k+1], new_solution[k+1:l+1], new_solution[k+1:k+2], new_solution[l+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:l+1], new_solution[k+1:k+2], new_solution[l+1:k+1], new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            7.858241482621262,
            8.973688673816275
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores\n        objectives = np.array([obj for (sol, obj) in archive])\n        diversity = np.linalg.norm(objectives[:, None] - objectives, axis=2).sum(axis=1)\n        # Select solution with high diversity or good quality\n        selected_idx = np.argmax(diversity + 1/(1 + np.linalg.norm(objectives, axis=1)))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Random segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Edge insertion with validation\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if l == k or l == (k + 1) % n:\n        l = (l + 1) % n\n\n    # Check if insertion is valid\n    if k != l and (k + 1) % n != l:\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        # Apply insertion if beneficial\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform insertion\n            if k < l:\n                new_solution = np.concatenate([new_solution[:k+1], new_solution[k+1:l+1], new_solution[k+1:k+2], new_solution[l+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:l+1], new_solution[k+1:k+2], new_solution[l+1:k+1], new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive using a weighted random selection based on normalized objective values, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Weighted random selection\n    weights = 1 / (normalized[:, 0] + normalized[:, 1] + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Randomly select two segments\n    i = np.random.randint(0, n - 3)\n    j = np.random.randint(i + 2, n - 1)\n\n    # Reverse the middle segment\n    middle_segment = new_solution[i+1:j+1]\n    new_solution[i+1:j+1] = middle_segment[::-1]\n\n    # Randomly select a position for insertion\n    k = np.random.randint(0, n - 1)\n    if k != i and k != j:\n        # Insert the reversed segment at a different position\n        inserted_segment = new_solution[i+1:j+1]\n        new_solution = np.concatenate([\n            new_solution[:k+1],\n            inserted_segment,\n            new_solution[k+1:i+1],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            7.030890248115019,
            6.972772417427044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Weighted random selection\n    weights = 1 / (normalized[:, 0] + normalized[:, 1] + 1e-10)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Randomly select two segments\n    i = np.random.randint(0, n - 3)\n    j = np.random.randint(i + 2, n - 1)\n\n    # Reverse the middle segment\n    middle_segment = new_solution[i+1:j+1]\n    new_solution[i+1:j+1] = middle_segment[::-1]\n\n    # Randomly select a position for insertion\n    k = np.random.randint(0, n - 1)\n    if k != i and k != j:\n        # Insert the reversed segment at a different position\n        inserted_segment = new_solution[i+1:j+1]\n        new_solution = np.concatenate([\n            new_solution[:k+1],\n            inserted_segment,\n            new_solution[k+1:i+1],\n            new_solution[j+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for diversity\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = np.max(objectives, axis=0)\n        min_obj = np.min(objectives, axis=0)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for m in range(2):\n                if max_obj[m] != min_obj[m]:\n                    crowding[i] += (objectives[(i+1)%len(archive), m] - objectives[(i-1)%len(archive), m]) / (max_obj[m] - min_obj[m])\n\n        # Combine Pareto dominance and crowding distance\n        scores = np.zeros(len(archive))\n        for i in range(len(archive)):\n            # Count how many solutions are dominated by this one\n            dominance = sum(1 for j in range(len(archive)) if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]))\n            scores[i] = dominance + crowding[i]\n\n        # Select the solution with the highest score\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.847730904143812,
            7.019046585981855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for diversity\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = np.max(objectives, axis=0)\n        min_obj = np.min(objectives, axis=0)\n        crowding = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for m in range(2):\n                if max_obj[m] != min_obj[m]:\n                    crowding[i] += (objectives[(i+1)%len(archive), m] - objectives[(i-1)%len(archive), m]) / (max_obj[m] - min_obj[m])\n\n        # Combine Pareto dominance and crowding distance\n        scores = np.zeros(len(archive))\n        for i in range(len(archive)):\n            # Count how many solutions are dominated by this one\n            dominance = sum(1 for j in range(len(archive)) if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]))\n            scores[i] = dominance + crowding[i]\n\n        # Select the solution with the highest score\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive using a score function that combines Pareto dominance and crowding distance, then applies a combination of edge exchange and segment reversal operations with adaptive segment lengths to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Score each solution in the archive\n    scores = []\n    objectives = [obj for _, obj in archive]\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                    dominated += 1\n        # Crowding distance calculation\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n        idx1 = sorted_obj1.index(objectives[i])\n        idx2 = sorted_obj2.index(objectives[i])\n        crowding = 0\n        if idx1 > 0 and idx1 < len(objectives)-1:\n            crowding += (sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]) / (max(obj[0] for obj in objectives) - min(obj[0] for obj in objectives))\n        if idx2 > 0 and idx2 < len(objectives)-1:\n            crowding += (sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]) / (max(obj[1] for obj in objectives) - min(obj[1] for obj in objectives))\n        scores.append(dominated + crowding)\n\n    # Select solution with highest score\n    selected_idx = scores.index(max(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_length = max(2, min(5, n // 4))\n    i = random.randint(0, n - 2 * segment_length - 1)\n    j = i + segment_length\n    k = j + random.randint(1, segment_length)\n\n    # Apply segment reversal\n    middle_segment = new_solution[j:k]\n    new_solution[j:k] = middle_segment[::-1]\n\n    # Apply edge exchange if beneficial\n    for _ in range(2):\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            9.396580140077457,
            9.783048737211534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Score each solution in the archive\n    scores = []\n    objectives = [obj for _, obj in archive]\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j:\n                if objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                    dominated += 1\n        # Crowding distance calculation\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n        idx1 = sorted_obj1.index(objectives[i])\n        idx2 = sorted_obj2.index(objectives[i])\n        crowding = 0\n        if idx1 > 0 and idx1 < len(objectives)-1:\n            crowding += (sorted_obj1[idx1+1][0] - sorted_obj1[idx1-1][0]) / (max(obj[0] for obj in objectives) - min(obj[0] for obj in objectives))\n        if idx2 > 0 and idx2 < len(objectives)-1:\n            crowding += (sorted_obj2[idx2+1][1] - sorted_obj2[idx2-1][1]) / (max(obj[1] for obj in objectives) - min(obj[1] for obj in objectives))\n        scores.append(dominated + crowding)\n\n    # Select solution with highest score\n    selected_idx = scores.index(max(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_length = max(2, min(5, n // 4))\n    i = random.randint(0, n - 2 * segment_length - 1)\n    j = i + segment_length\n    k = j + random.randint(1, segment_length)\n\n    # Apply segment reversal\n    middle_segment = new_solution[j:k]\n    new_solution[j:k] = middle_segment[::-1]\n\n    # Apply edge exchange if beneficial\n    for _ in range(2):\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        combined_obj = obj[0] + obj[1]\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 1)\n    length = random.randint(2, min(5, n - 1))\n    end = (start + length) % n\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Step 3: Randomly insert a node from outside the segment\n    if n > 4:\n        node_to_insert = random.randint(0, n - 1)\n        if node_to_insert not in segment:\n            pos = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, pos, node_to_insert)\n            new_solution = new_solution[:n]  # Ensure solution length remains the same\n\n    return new_solution\n\n",
        "score": [
            7.564092455770879,
            7.349524883695606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_obj = float('inf')\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        combined_obj = obj[0] + obj[1]\n        if combined_obj < best_obj:\n            best_obj = combined_obj\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a novel local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 1)\n    length = random.randint(2, min(5, n - 1))\n    end = (start + length) % n\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Step 3: Randomly insert a node from outside the segment\n    if n > 4:\n        node_to_insert = random.randint(0, n - 1)\n        if node_to_insert not in segment:\n            pos = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, pos, node_to_insert)\n            new_solution = new_solution[:n]  # Ensure solution length remains the same\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select a solution that is not dominated by others\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and \\\n                       (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                        dominated[i] = True\n                        break\n        non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator: segment relocation with edge exchange\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Relocate segment\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Edge exchange\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.155414854371953,
            7.311498388891053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select a solution that is not dominated by others\n        dominated = [False] * len(archive)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j:\n                    if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and \\\n                       (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                        dominated[i] = True\n                        break\n        non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n        if non_dominated:\n            selected_idx = random.choice(non_dominated)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator: segment relocation with edge exchange\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Relocate segment\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Edge exchange\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange, segment reversal, and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Randomly swap two non-adjacent nodes if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.097383407682383,
            6.831177640824556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and reverse it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly insert a node at a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Randomly swap two non-adjacent nodes if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge reversal and segment insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            10.476102149424825,
            10.626813849278136
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{This novel algorithm selects a solution from the archive with a high Pareto dominance score, then applies a combination of segment relinking and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest Pareto dominance\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_sol is sol:\n                continue\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated += 1\n        dominance_scores.append(-dominated)  # Higher score is better\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment relinking\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Find common segment in another solution\n    for other_sol, _ in archive:\n        if np.array_equal(other_sol, base_solution):\n            continue\n        common = np.intersect1d(new_solution[i:j], other_sol)\n        if len(common) > 1:\n            # Insert common segment\n            pos = np.where(new_solution == common[0])[0][0]\n            new_segment = other_sol[np.isin(other_sol, common)]\n            new_solution = np.concatenate([new_solution[:pos], new_segment, new_solution[pos+len(new_segment):]])\n            break\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 1)\n        l = (k + 1) % n\n        m = random.randint(0, n - 1)\n\n        if m != k and m != l and m != (k - 1) % n:\n            # Calculate potential benefit\n            old_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[m], new_solution[(m+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[k], new_solution[m]] + distance_matrix_1[new_solution[l], new_solution[(m+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[m], new_solution[(m+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[k], new_solution[m]] + distance_matrix_2[new_solution[l], new_solution[(m+1)%n]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                # Perform insertion\n                if m > k:\n                    new_solution = np.concatenate([new_solution[:k+1], new_solution[m:m+1], new_solution[l:m], new_solution[m+1:]])\n                else:\n                    new_solution = np.concatenate([new_solution[:m], new_solution[k+1:l+1], new_solution[m:k+1], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            7.533787928554465,
            7.308578533045452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest Pareto dominance\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if other_sol is sol:\n                continue\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated += 1\n        dominance_scores.append(-dominated)  # Higher score is better\n\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment relinking\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Find common segment in another solution\n    for other_sol, _ in archive:\n        if np.array_equal(other_sol, base_solution):\n            continue\n        common = np.intersect1d(new_solution[i:j], other_sol)\n        if len(common) > 1:\n            # Insert common segment\n            pos = np.where(new_solution == common[0])[0][0]\n            new_segment = other_sol[np.isin(other_sol, common)]\n            new_solution = np.concatenate([new_solution[:pos], new_segment, new_solution[pos+len(new_segment):]])\n            break\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 1)\n        l = (k + 1) % n\n        m = random.randint(0, n - 1)\n\n        if m != k and m != l and m != (k - 1) % n:\n            # Calculate potential benefit\n            old_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[m], new_solution[(m+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[k], new_solution[m]] + distance_matrix_1[new_solution[l], new_solution[(m+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[m], new_solution[(m+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[k], new_solution[m]] + distance_matrix_2[new_solution[l], new_solution[(m+1)%n]]\n\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                # Perform insertion\n                if m > k:\n                    new_solution = np.concatenate([new_solution[:k+1], new_solution[m:m+1], new_solution[l:m], new_solution[m+1:]])\n                else:\n                    new_solution = np.concatenate([new_solution[:m], new_solution[k+1:l+1], new_solution[m:k+1], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective values\n        objectives = [obj for _, obj in archive]\n        diversity_scores = []\n        for i in range(len(objectives)):\n            diversity = 0\n            for j in range(len(objectives)):\n                if i != j:\n                    diversity += (objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2\n            diversity_scores.append(diversity)\n\n        # Select a solution with high diversity or low objective values\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.06751163522647,
            7.951043098332659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective values\n        objectives = [obj for _, obj in archive]\n        diversity_scores = []\n        for i in range(len(objectives)):\n            diversity = 0\n            for j in range(len(objectives)):\n                if i != j:\n                    diversity += (objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2\n            diversity_scores.append(diversity)\n\n        # Select a solution with high diversity or low objective values\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by considering both objective diversity and dominance, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Step 2: Randomly insert a node from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            7.208554627329091,
            6.742461542863108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Step 2: Randomly insert a node from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{This new algorithm prioritizes solutions with high crowding distance in the Pareto front, applies a combination of segment reversal and edge insertion operations, and uses a novel scoring function to balance exploration and exploitation in the local search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distances\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if sorted_obj[-1] - sorted_obj[0] == 0:\n                continue\n            crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with segment reversal and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Segment reversal\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Edge insertion\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert l between k and k+1\n            new_solution = np.concatenate([new_solution[:k+1], [new_solution[l]], new_solution[k+1:l], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            10.49722043331765,
            10.609875796916931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distances\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):\n        sorted_idx = np.argsort(objectives[:, m])\n        sorted_obj = objectives[sorted_idx, m]\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            if sorted_obj[-1] - sorted_obj[0] == 0:\n                continue\n            crowding_distances[sorted_idx[i]] += (sorted_obj[i+1] - sorted_obj[i-1]) / (sorted_obj[-1] - sorted_obj[0])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with segment reversal and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Segment reversal\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Edge insertion\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert l between k and k+1\n            new_solution = np.concatenate([new_solution[:k+1], [new_solution[l]], new_solution[k+1:l], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment insertion, edge reversal, and node relocation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (diversity)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)] if len(archive_sorted) > 3 else archive_sorted\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a random position\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Reverse a random segment if beneficial\n    rev_start = random.randint(0, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[rev_start-1], new_solution[rev_start]] + distance_matrix_1[new_solution[rev_end-1], new_solution[rev_end]]\n    new_cost1 = distance_matrix_1[new_solution[rev_start-1], new_solution[rev_end]] + distance_matrix_1[new_solution[rev_start], new_solution[rev_end-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[rev_start-1], new_solution[rev_start]] + distance_matrix_2[new_solution[rev_end-1], new_solution[rev_end]]\n    new_cost2 = distance_matrix_2[new_solution[rev_start-1], new_solution[rev_end]] + distance_matrix_2[new_solution[rev_start], new_solution[rev_end-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[rev_start:rev_end+1] = new_solution[rev_start:rev_end+1][::-1]\n\n    # Step 4: Relocate a random node if beneficial\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n\n    best_pos = node_pos\n    best_cost1 = 0\n    best_cost2 = 0\n\n    for pos in range(n):\n        if pos == node_pos:\n            continue\n\n        # Calculate potential costs\n        if pos == 0:\n            cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n            cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n        elif pos == n - 1:\n            cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n            cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n        else:\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos+1]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos+1]]\n\n        if (cost1 < best_cost1) or (cost2 < best_cost2):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    if best_pos != node_pos:\n        # Remove node from current position\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Insert at best position\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.39271923928885,
            6.06021619539606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (diversity)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)] if len(archive_sorted) > 3 else archive_sorted\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a random position\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Reverse a random segment if beneficial\n    rev_start = random.randint(0, n - 2)\n    rev_end = random.randint(rev_start + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[rev_start-1], new_solution[rev_start]] + distance_matrix_1[new_solution[rev_end-1], new_solution[rev_end]]\n    new_cost1 = distance_matrix_1[new_solution[rev_start-1], new_solution[rev_end]] + distance_matrix_1[new_solution[rev_start], new_solution[rev_end-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[rev_start-1], new_solution[rev_start]] + distance_matrix_2[new_solution[rev_end-1], new_solution[rev_end]]\n    new_cost2 = distance_matrix_2[new_solution[rev_start-1], new_solution[rev_end]] + distance_matrix_2[new_solution[rev_start], new_solution[rev_end-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[rev_start:rev_end+1] = new_solution[rev_start:rev_end+1][::-1]\n\n    # Step 4: Relocate a random node if beneficial\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n\n    best_pos = node_pos\n    best_cost1 = 0\n    best_cost2 = 0\n\n    for pos in range(n):\n        if pos == node_pos:\n            continue\n\n        # Calculate potential costs\n        if pos == 0:\n            cost1 = distance_matrix_1[new_solution[-1], node] + distance_matrix_1[node, new_solution[1]]\n            cost2 = distance_matrix_2[new_solution[-1], node] + distance_matrix_2[node, new_solution[1]]\n        elif pos == n - 1:\n            cost1 = distance_matrix_1[new_solution[-2], node] + distance_matrix_1[node, new_solution[0]]\n            cost2 = distance_matrix_2[new_solution[-2], node] + distance_matrix_2[node, new_solution[0]]\n        else:\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos+1]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos+1]]\n\n        if (cost1 < best_cost1) or (cost2 < best_cost2):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    if best_pos != node_pos:\n        # Remove node from current position\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        # Insert at best position\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations, while also incorporating a dynamic selection of segments based on their contribution to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance_scores = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for j, (other_sol, other_obj) in enumerate(archive):\n                if i != j:\n                    if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                        dominated += 1\n            diversity = obj[0] * obj[1]  # Simple diversity measure\n            score = -dominated + 0.5 * diversity  # Higher score is better\n            dominance_scores.append(score)\n\n        selected_idx = np.argmax(dominance_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select segments based on their contribution to both objectives\n    segment_scores = []\n    for i in range(n - 1):\n        cost1 = distance_matrix_1[base_solution[i], base_solution[i+1]]\n        cost2 = distance_matrix_2[base_solution[i], base_solution[i+1]]\n        segment_scores.append(cost1 * cost2)  # Combined score\n\n    # Select top 3 segments to potentially modify\n    top_segments = np.argsort(segment_scores)[-3:]\n\n    if len(top_segments) > 0:\n        # Step 2: Reverse a selected segment\n        i = random.choice(top_segments)\n        j = (i + 1) % n\n\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Handle wrap-around case\n            segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([reversed_segment[n-i:], new_solution[j+1:i], reversed_segment[:n-i]])\n\n        # Step 3: Apply edge exchange if beneficial\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            9.290166181344057,
            8.666826991617
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance_scores = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for j, (other_sol, other_obj) in enumerate(archive):\n                if i != j:\n                    if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                        dominated += 1\n            diversity = obj[0] * obj[1]  # Simple diversity measure\n            score = -dominated + 0.5 * diversity  # Higher score is better\n            dominance_scores.append(score)\n\n        selected_idx = np.argmax(dominance_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select segments based on their contribution to both objectives\n    segment_scores = []\n    for i in range(n - 1):\n        cost1 = distance_matrix_1[base_solution[i], base_solution[i+1]]\n        cost2 = distance_matrix_2[base_solution[i], base_solution[i+1]]\n        segment_scores.append(cost1 * cost2)  # Combined score\n\n    # Select top 3 segments to potentially modify\n    top_segments = np.argsort(segment_scores)[-3:]\n\n    if len(top_segments) > 0:\n        # Step 2: Reverse a selected segment\n        i = random.choice(top_segments)\n        j = (i + 1) % n\n\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Handle wrap-around case\n            segment = np.concatenate([new_solution[i:], new_solution[:j+1]])\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([reversed_segment[n-i:], new_solution[j+1:i], reversed_segment[:n-i]])\n\n        # Step 3: Apply edge exchange if beneficial\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This novel algorithm selects a high-quality solution from the archive by considering both Pareto dominance and objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly insert an edge from another segment\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 2)\n    if k != l:\n        # Insert node at position l into position k\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n        # Remove duplicate if created\n        duplicates = np.where(new_solution == node)[0]\n        if len(duplicates) > 1:\n            new_solution = np.delete(new_solution, duplicates[1])\n\n    # Ensure solution remains valid\n    missing_nodes = set(range(n)) - set(new_solution)\n    extra_nodes = set(new_solution) - set(range(n))\n    if missing_nodes or extra_nodes:\n        # Reconstruct solution if invalid\n        new_solution = np.array(list(set(range(n)) - set(extra_nodes)))\n        new_solution = np.concatenate([new_solution, np.array(list(missing_nodes))])\n\n    return new_solution\n\n",
        "score": [
            6.959173543844568,
            6.852050523120792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly insert an edge from another segment\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 2)\n    if k != l:\n        # Insert node at position l into position k\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:k], [node], new_solution[k:]])\n\n        # Remove duplicate if created\n        duplicates = np.where(new_solution == node)[0]\n        if len(duplicates) > 1:\n            new_solution = np.delete(new_solution, duplicates[1])\n\n    # Ensure solution remains valid\n    missing_nodes = set(range(n)) - set(new_solution)\n    extra_nodes = set(new_solution) - set(range(n))\n    if missing_nodes or extra_nodes:\n        # Reconstruct solution if invalid\n        new_solution = np.array(list(set(range(n)) - set(extra_nodes)))\n        new_solution = np.concatenate([new_solution, np.array(list(missing_nodes))])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A novel local search algorithm selects a solution from the archive based on both its objective values and diversity, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a node to remove\n    remove_pos = random.randint(0, n - 1)\n    removed_node = new_solution[remove_pos]\n\n    # Step 2: Randomly select a position to insert the removed node\n    insert_pos = random.randint(0, n - 2)\n    if insert_pos >= remove_pos:\n        insert_pos += 1\n\n    # Step 3: Remove the node and insert it at the new position\n    new_solution = np.delete(new_solution, remove_pos)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 4: Randomly rotate a segment of the tour\n    if n >= 4:\n        seg_start = random.randint(0, n - 4)\n        seg_length = random.randint(2, n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        segment = new_solution[seg_start:seg_end]\n        rotation = random.randint(1, seg_length - 1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[seg_start:seg_end] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            6.921261264396257,
            7.03799702461461
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a node to remove\n    remove_pos = random.randint(0, n - 1)\n    removed_node = new_solution[remove_pos]\n\n    # Step 2: Randomly select a position to insert the removed node\n    insert_pos = random.randint(0, n - 2)\n    if insert_pos >= remove_pos:\n        insert_pos += 1\n\n    # Step 3: Remove the node and insert it at the new position\n    new_solution = np.delete(new_solution, remove_pos)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 4: Randomly rotate a segment of the tour\n    if n >= 4:\n        seg_start = random.randint(0, n - 4)\n        seg_length = random.randint(2, n - seg_start - 1)\n        seg_end = seg_start + seg_length\n\n        segment = new_solution[seg_start:seg_end]\n        rotation = random.randint(1, seg_length - 1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[seg_start:seg_end] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        max_div_idx = np.argmax(np.max(objectives, axis=0) - np.min(objectives, axis=0))\n        base_solution = archive[max_div_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotate = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.concatenate([segment[rotate:], segment[:rotate]])\n\n    # Step 2: Randomly insert a node elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [node], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            7.852489399119801,
            7.78576576819845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        max_div_idx = np.argmax(np.max(objectives, axis=0) - np.min(objectives, axis=0))\n        base_solution = archive[max_div_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotate = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.concatenate([segment[rotate:], segment[:rotate]])\n\n    # Step 2: Randomly insert a node elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l+1], [node], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{A novel local search approach selects a promising solution from the archive based on both objective diversity and solution quality, then generates a neighbor by strategically relocating a segment of nodes to a different position while ensuring feasibility and potentially improving both objectives through a combination of segment reversal and edge insertion operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n        selected_idx = np.argmax(np.sum(diversity, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Step 2: Remove the segment from the current position\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    # Step 3: Insert the segment at a new position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 4: Reverse the inserted segment with probability 0.5\n    if random.random() < 0.5:\n        new_solution[insert_pos:insert_pos+len(segment)] = new_solution[insert_pos:insert_pos+len(segment)][::-1]\n\n    # Step 5: Apply edge insertion if beneficial\n    if len(new_solution) >= 4:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.2554685150901115,
            7.530041048889962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n        selected_idx = np.argmax(np.sum(diversity, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    seg_start = random.randint(0, n - 3)\n    seg_end = random.randint(seg_start + 1, min(seg_start + 3, n - 1))\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Step 2: Remove the segment from the current position\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    # Step 3: Insert the segment at a new position\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 4: Reverse the inserted segment with probability 0.5\n    if random.random() < 0.5:\n        new_solution[insert_pos:insert_pos+len(segment)] = new_solution[insert_pos:insert_pos+len(segment)][::-1]\n\n    # Step 5: Apply edge insertion if beneficial\n    if len(new_solution) >= 4:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{This novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1+obj[0]+obj[1]) for obj in objectives], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 1)\n    while k in [i, i+1, j, j+1]:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+2)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+2)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:k+2], new_solution[k:k+1], new_solution[k+2:]])\n\n    return new_solution\n\n",
        "score": [
            6.932718085761559,
            6.653195081036407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=[1/(1+obj[0]+obj[1]) for obj in objectives], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotate_amount)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 1)\n    while k in [i, i+1, j, j+1]:\n        k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+2)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+2)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:k+2], new_solution[k:k+1], new_solution[k+2:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by combined objective value (sum of both objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution (balancing diversity and quality)\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.818771200181494,
            8.005479907216952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by combined objective value (sum of both objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution (balancing diversity and quality)\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.45288408602608,
            6.983990370121529
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized = []\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        normalized.append((sol, obj, 0.7 * norm_obj1 + 0.3 * norm_obj2))\n\n    selected = max(normalized, key=lambda x: x[2])[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge insertion with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            temp = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n    return new_solution\n\n",
        "score": [
            10.45393683368699,
            10.695795034092537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized = []\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        normalized.append((sol, obj, 0.7 * norm_obj1 + 0.3 * norm_obj2))\n\n    selected = max(normalized, key=lambda x: x[2])[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge insertion with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            temp = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This novel algorithm selects a high-quality solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of adaptive segment relocation and conditional edge reinsertion to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate Pareto rank (simplified approximation)\n        pareto_rank = sum(1 for s, (c1, c2) in archive if (c1 < cost1 and c2 < cost2))\n        # Calculate objective diversity\n        diversity = abs(cost1 - cost2)\n        scores.append((pareto_rank, diversity))\n    selected_idx = min(range(len(scores)), key=lambda i: (scores[i][0], -scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:],\n        segment\n    ])\n\n    # Conditional edge reinsertion\n    for _ in range(2):\n        # Select a random edge\n        i = random.randint(0, n-2)\n        edge = (new_solution[i], new_solution[i+1])\n\n        # Calculate current cost\n        current_cost1 = distance_matrix_1[edge[0], edge[1]]\n        current_cost2 = distance_matrix_2[edge[0], edge[1]]\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n        for j in range(n):\n            if j == i or j == i+1:\n                continue\n            # Calculate potential insertion cost\n            new_cost1 = (distance_matrix_1[new_solution[j-1], edge[0]] +\n                         distance_matrix_1[edge[1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[j-1], edge[0]] +\n                         distance_matrix_2[edge[1], new_solution[j]])\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = j\n\n        # Perform insertion if beneficial\n        if best_pos != -1 and best_improvement > 0:\n            # Remove edge\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+2:]\n            ])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([edge[0], edge[1]]),\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            5.571812828856179,
            9.33488329910366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate Pareto rank (simplified approximation)\n        pareto_rank = sum(1 for s, (c1, c2) in archive if (c1 < cost1 and c2 < cost2))\n        # Calculate objective diversity\n        diversity = abs(cost1 - cost2)\n        scores.append((pareto_rank, diversity))\n    selected_idx = min(range(len(scores)), key=lambda i: (scores[i][0], -scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:],\n        segment\n    ])\n\n    # Conditional edge reinsertion\n    for _ in range(2):\n        # Select a random edge\n        i = random.randint(0, n-2)\n        edge = (new_solution[i], new_solution[i+1])\n\n        # Calculate current cost\n        current_cost1 = distance_matrix_1[edge[0], edge[1]]\n        current_cost2 = distance_matrix_2[edge[0], edge[1]]\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n        for j in range(n):\n            if j == i or j == i+1:\n                continue\n            # Calculate potential insertion cost\n            new_cost1 = (distance_matrix_1[new_solution[j-1], edge[0]] +\n                         distance_matrix_1[edge[1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[j-1], edge[0]] +\n                         distance_matrix_2[edge[1], new_solution[j]])\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = j\n\n        # Perform insertion if beneficial\n        if best_pos != -1 and best_improvement > 0:\n            # Remove edge\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+2:]\n            ])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([edge[0], edge[1]]),\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on objective diversity, then applies a combination of node insertion and segment rotation to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        diversity = abs(obj[0] - obj[1])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Step 2: Rotate the segment by one position\n    rotated_segment = np.roll(segment, 1)\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            6.800031486970561,
            8.45822967914029
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        diversity = abs(obj[0] - obj[1])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Step 2: Rotate the segment by one position\n    rotated_segment = np.roll(segment, 1)\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{This algorithm selects a solution from the archive, identifies critical nodes based on their contributions to both objectives, then performs a multi-segment shuffle where segments are reordered to balance improvements in both objectives while ensuring feasibility through careful boundary handling.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value (potential for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution  # No meaningful operation possible\n\n    # Identify critical nodes (high impact on both objectives)\n    critical_nodes = set()\n    for i in range(n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        if (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) > np.mean(distance_matrix_1) or \\\n           (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) > np.mean(distance_matrix_2):\n            critical_nodes.add(curr)\n\n    # Segment the tour based on critical nodes\n    segments = []\n    start = 0\n    for i in range(1, n):\n        if base_solution[i] in critical_nodes:\n            segments.append(base_solution[start:i])\n            start = i\n    segments.append(base_solution[start:])\n\n    # Shuffle segments while preserving critical nodes at boundaries\n    shuffled_segments = segments.copy()\n    if len(shuffled_segments) > 2:\n        # Keep first and last segments fixed, shuffle middle segments\n        middle = shuffled_segments[1:-1]\n        random.shuffle(middle)\n        shuffled_segments[1:-1] = middle\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(shuffled_segments)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            8.642154653730273,
            8.762182373475145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value (potential for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution  # No meaningful operation possible\n\n    # Identify critical nodes (high impact on both objectives)\n    critical_nodes = set()\n    for i in range(n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        if (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]) > np.mean(distance_matrix_1) or \\\n           (distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]) > np.mean(distance_matrix_2):\n            critical_nodes.add(curr)\n\n    # Segment the tour based on critical nodes\n    segments = []\n    start = 0\n    for i in range(1, n):\n        if base_solution[i] in critical_nodes:\n            segments.append(base_solution[start:i])\n            start = i\n    segments.append(base_solution[start:])\n\n    # Shuffle segments while preserving critical nodes at boundaries\n    shuffled_segments = segments.copy()\n    if len(shuffled_segments) > 2:\n        # Keep first and last segments fixed, shuffle middle segments\n        middle = shuffled_segments[1:-1]\n        random.shuffle(middle)\n        shuffled_segments[1:-1] = middle\n\n    # Reconstruct the solution\n    new_solution = np.concatenate(shuffled_segments)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 4: Reverse a random edge if beneficial\n    l = random.randint(0, n - 2)\n    m = random.randint(l + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[m-1], new_solution[m]]\n    new_cost1 = distance_matrix_1[new_solution[l-1], new_solution[m]] + distance_matrix_1[new_solution[m-1], new_solution[l]]\n\n    current_cost2 = distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[m-1], new_solution[m]]\n    new_cost2 = distance_matrix_2[new_solution[l-1], new_solution[m]] + distance_matrix_2[new_solution[m-1], new_solution[l]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            6.769448925366548,
            6.568165194145325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 4: Reverse a random edge if beneficial\n    l = random.randint(0, n - 2)\n    m = random.randint(l + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[m-1], new_solution[m]]\n    new_cost1 = distance_matrix_1[new_solution[l-1], new_solution[m]] + distance_matrix_1[new_solution[m-1], new_solution[l]]\n\n    current_cost2 = distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[m-1], new_solution[m]]\n    new_cost2 = distance_matrix_2[new_solution[l-1], new_solution[m]] + distance_matrix_2[new_solution[m-1], new_solution[l]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its Pareto dominance and applies a combination of segment insertion and edge reversal operations to generate a neighbor solution, while ensuring feasibility through careful validation of node visits.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate Pareto dominance scores\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select the least dominated solution\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n    while k == i or k == i + 1 or k == j or k == j + 1:\n        k = random.randint(0, n - 1)\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    for _ in range(2):  # Try a few reversals\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        reversed_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        reversed_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.575618924237803,
            8.20416868402036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate Pareto dominance scores\n    dominance_scores = []\n    for sol, obj in archive:\n        dominated = 0\n        for other_sol, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated += 1\n        dominance_scores.append(dominated)\n\n    # Select the least dominated solution\n    selected_idx = np.argmin(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n    while k == i or k == i + 1 or k == j or k == j + 1:\n        k = random.randint(0, n - 1)\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    for _ in range(2):  # Try a few reversals\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        reversed_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        reversed_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{This novel algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance, then applies a combination of segment relocation and edge insertion operations to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Identify a segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Find the best insertion point for the segment\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(0, n - len(segment) + 1):\n        if pos >= i and pos <= j:\n            continue\n\n        # Remove segment from current position\n        temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Insert segment at new position\n        candidate = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate improvement in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n))\n        new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, n))\n\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n))\n        new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, n))\n\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove segment from original position\n        temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Insert segment at best position\n        new_solution = np.concatenate([temp_solution[:best_pos], segment, temp_solution[best_pos:]])\n\n    # Step 3: Randomly insert a node to create diversity\n    if n > 4:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.6365358956437355,
            6.170783212804297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Identify a segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Find the best insertion point for the segment\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(0, n - len(segment) + 1):\n        if pos >= i and pos <= j:\n            continue\n\n        # Remove segment from current position\n        temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Insert segment at new position\n        candidate = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate improvement in both objectives\n        original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n))\n        new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, n))\n\n        original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n))\n        new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, n))\n\n        improvement = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove segment from original position\n        temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Insert segment at best position\n        new_solution = np.concatenate([temp_solution[:best_pos], segment, temp_solution[best_pos:]])\n\n    # Step 3: Randomly insert a node to create diversity\n    if n > 4:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n            insert_pos = random.randint(0, n - 2)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive based on objective value spread, then applies a combination of node insertion and segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    spreads = [abs(obj[0] - obj[1]) for (sol, obj) in archive]\n    selected_idx = spreads.index(max(spreads)) if spreads else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(3, n - start - 1))\n    segment = new_solution[start:start+length]\n\n    # Rotate the segment\n    rotated = np.roll(segment, random.randint(1, length - 1))\n    new_solution[start:start+length] = rotated\n\n    # Randomly insert a node from elsewhere\n    if n > 4:\n        insert_pos = random.randint(0, n - 2)\n        node_to_insert = random.choice([node for node in base_solution if node not in new_solution[:insert_pos] and node not in new_solution[insert_pos+1:]])\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            10.438075945588533,
            10.665982161826207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    spreads = [abs(obj[0] - obj[1]) for (sol, obj) in archive]\n    selected_idx = spreads.index(max(spreads)) if spreads else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(3, n - start - 1))\n    segment = new_solution[start:start+length]\n\n    # Rotate the segment\n    rotated = np.roll(segment, random.randint(1, length - 1))\n    new_solution[start:start+length] = rotated\n\n    # Randomly insert a node from elsewhere\n    if n > 4:\n        insert_pos = random.randint(0, n - 2)\n        node_to_insert = random.choice([node for node in base_solution if node not in new_solution[:insert_pos] and node not in new_solution[insert_pos+1:]])\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection to prioritize diverse solutions, then applies a segment inversion and edge insertion operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion and edge insertion\n    a = random.randint(0, n-4)\n    b = random.randint(a+2, n-2)\n    c = random.randint(b+1, n-1)\n\n    # Invert segment\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Insert edge\n    if random.random() < 0.5:\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    return new_solution\n\n",
        "score": [
            8.8225089592764,
            9.741161635147574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion and edge insertion\n    a = random.randint(0, n-4)\n    b = random.randint(a+2, n-2)\n    c = random.randint(b+1, n-1)\n\n    # Invert segment\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Insert edge\n    if random.random() < 0.5:\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The new algorithm selects a solution from the archive prioritizing those with high Pareto dominance, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while l == k or l == (k - 1) % n or l == (k + 1) % n:\n        l = random.randint(0, n - 1)\n\n    # Insert the node at a new position\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            10.477838105420934,
            10.710154011954412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while l == k or l == (k - 1) % n or l == (k + 1) % n:\n        l = random.randint(0, n - 1)\n\n    # Insert the node at a new position\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted score combining Pareto dominance and objective diversity, then applies a hybrid local search using adaptive segment reversal and edge exchange operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives\n        norm_obj1 = obj[0] / (sum(distance_matrix_1[i, i+1] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]) if len(sol) > 1 else 1.0\n        norm_obj2 = obj[1] / (sum(distance_matrix_2[i, i+1] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]) if len(sol) > 1 else 1.0\n\n        # Calculate diversity score (distance to other solutions)\n        diversity = sum(np.linalg.norm(np.array(obj) - np.array(other_obj)) for _, other_obj in archive) / len(archive)\n\n        # Combine scores with weights\n        score = 0.6 * (1 - norm_obj1) + 0.3 * (1 - norm_obj2) + 0.1 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(base_solution) < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    n = len(base_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Edge exchange with probability based on improvement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]))\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]))\n\n        # Apply exchange if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.926484730840558,
            8.28264541828828
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives\n        norm_obj1 = obj[0] / (sum(distance_matrix_1[i, i+1] for i in range(len(sol)-1)) + distance_matrix_1[sol[-1], sol[0]]) if len(sol) > 1 else 1.0\n        norm_obj2 = obj[1] / (sum(distance_matrix_2[i, i+1] for i in range(len(sol)-1)) + distance_matrix_2[sol[-1], sol[0]]) if len(sol) > 1 else 1.0\n\n        # Calculate diversity score (distance to other solutions)\n        diversity = sum(np.linalg.norm(np.array(obj) - np.array(other_obj)) for _, other_obj in archive) / len(archive)\n\n        # Combine scores with weights\n        score = 0.6 * (1 - norm_obj1) + 0.3 * (1 - norm_obj2) + 0.1 * diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if len(base_solution) < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    n = len(base_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 2: Edge exchange with probability based on improvement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost change\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]] -\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]))\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]] -\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]))\n\n        # Apply exchange if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a novel \"path inversion and edge relocation\" strategy to generate a neighbor solution by inverting a random segment and relocating edges while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance and diversity scores\n        dominance_scores = []\n        diversity_scores = []\n\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for j, (_, other_obj) in enumerate(archive):\n                if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated += 1\n            dominance_scores.append(dominated)\n\n            # Calculate diversity as average distance to other solutions in objective space\n            diversity = 0\n            for j, (_, other_obj) in enumerate(archive):\n                if i != j:\n                    diversity += np.sqrt((obj[0] - other_obj[0])**2 + (obj[1] - other_obj[1])**2)\n            diversity_scores.append(diversity)\n\n        # Normalize scores\n        if max(dominance_scores) > 0:\n            dominance_scores = [x / max(dominance_scores) for x in dominance_scores]\n        if max(diversity_scores) > 0:\n            diversity_scores = [x / max(diversity_scores) for x in diversity_scores]\n\n        # Combine scores with weights (80% dominance, 20% diversity)\n        combined_scores = [0.8 * d + 0.2 * v for d, v in zip(dominance_scores, diversity_scores)]\n\n        # Select the solution with the highest combined score\n        selected_idx = combined_scores.index(max(combined_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to invert\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 1)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Relocate edges to improve both objectives\n    for _ in range(min(3, n // 2)):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply relocation if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the relocation\n            temp = new_solution[i]\n            if i < j:\n                new_solution[i:j] = new_solution[i+1:j+1]\n                new_solution[j] = temp\n            else:\n                new_solution[j+1:i+1] = new_solution[j:i]\n                new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            9.500935097536743,
            9.75414275869573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance and diversity scores\n        dominance_scores = []\n        diversity_scores = []\n\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for j, (_, other_obj) in enumerate(archive):\n                if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated += 1\n            dominance_scores.append(dominated)\n\n            # Calculate diversity as average distance to other solutions in objective space\n            diversity = 0\n            for j, (_, other_obj) in enumerate(archive):\n                if i != j:\n                    diversity += np.sqrt((obj[0] - other_obj[0])**2 + (obj[1] - other_obj[1])**2)\n            diversity_scores.append(diversity)\n\n        # Normalize scores\n        if max(dominance_scores) > 0:\n            dominance_scores = [x / max(dominance_scores) for x in dominance_scores]\n        if max(diversity_scores) > 0:\n            diversity_scores = [x / max(diversity_scores) for x in diversity_scores]\n\n        # Combine scores with weights (80% dominance, 20% diversity)\n        combined_scores = [0.8 * d + 0.2 * v for d, v in zip(dominance_scores, diversity_scores)]\n\n        # Select the solution with the highest combined score\n        selected_idx = combined_scores.index(max(combined_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to invert\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 1)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Relocate edges to improve both objectives\n    for _ in range(min(3, n // 2)):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply relocation if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the relocation\n            temp = new_solution[i]\n            if i < j:\n                new_solution[i:j] = new_solution[i+1:j+1]\n                new_solution[j] = temp\n            else:\n                new_solution[j+1:i+1] = new_solution[j:i]\n                new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel combination of segment insertion and edge rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 2: Insert the segment at a new position\n    pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    # Step 3: Rotate a segment to improve both objectives\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_1[new_solution[l-1], new_solution[l]])\n    new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[k], new_solution[l-1]])\n\n    current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_2[new_solution[l-1], new_solution[l]])\n    new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[k], new_solution[l-1]])\n\n    # Apply rotation if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k:l+1] = np.roll(new_solution[k:l+1], 1)\n\n    return new_solution\n\n",
        "score": [
            7.749889883838215,
            8.499468835654714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 2: Insert the segment at a new position\n    pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n    # Step 3: Rotate a segment to improve both objectives\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_1[new_solution[l-1], new_solution[l]])\n    new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                distance_matrix_1[new_solution[k], new_solution[l-1]])\n\n    current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                     distance_matrix_2[new_solution[l-1], new_solution[l]])\n    new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                distance_matrix_2[new_solution[k], new_solution[l-1]])\n\n    # Apply rotation if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k:l+1] = np.roll(new_solution[k:l+1], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate((segment[rotation:], segment[:rotation]))\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert a node from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            6.909582238259532,
            6.970763422524623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate((segment[rotation:], segment[:rotation]))\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert a node from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node_to_insert = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a segment insertion and edge reversal operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # Step 2: Remove the segment and insert it in a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random edge if beneficial\n    if n >= 2:\n        k = random.randint(0, n - 2)\n        current_cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        new_cost1 = distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        new_cost2 = distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.51402045759518,
            10.634670873417743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # Step 2: Remove the segment and insert it in a new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random edge if beneficial\n    if n >= 2:\n        k = random.randint(0, n - 2)\n        current_cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]]\n        new_cost1 = distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]]\n        new_cost2 = distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel adaptive segment insertion and edge reallocation algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of adaptive segment insertion and edge reallocation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Adaptive segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n\n    # Remove segment [i+1, j] and insert it after position k\n    segment = new_solution[i+1:j+1]\n    k = random.randint(0, n - len(segment) - 1)\n    if k >= i:\n        k += len(segment)\n\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Step 2: Edge reallocation\n    for _ in range(2):  # Perform multiple reallocations\n        u = random.randint(0, n - 1)\n        v = random.randint(0, n - 1)\n        if u != v and u != (v - 1) % n and v != (u - 1) % n:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[u-1], new_solution[u]] + distance_matrix_1[new_solution[v-1], new_solution[v]]\n            new_cost1 = distance_matrix_1[new_solution[u-1], new_solution[v]] + distance_matrix_1[new_solution[v-1], new_solution[u]]\n\n            current_cost2 = distance_matrix_2[new_solution[u-1], new_solution[u]] + distance_matrix_2[new_solution[v-1], new_solution[v]]\n            new_cost2 = distance_matrix_2[new_solution[u-1], new_solution[v]] + distance_matrix_2[new_solution[v-1], new_solution[u]]\n\n            # Apply reallocation if beneficial for at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n",
        "score": [
            7.384898223262502,
            7.290088807023372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Adaptive segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n\n    # Remove segment [i+1, j] and insert it after position k\n    segment = new_solution[i+1:j+1]\n    k = random.randint(0, n - len(segment) - 1)\n    if k >= i:\n        k += len(segment)\n\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Step 2: Edge reallocation\n    for _ in range(2):  # Perform multiple reallocations\n        u = random.randint(0, n - 1)\n        v = random.randint(0, n - 1)\n        if u != v and u != (v - 1) % n and v != (u - 1) % n:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[u-1], new_solution[u]] + distance_matrix_1[new_solution[v-1], new_solution[v]]\n            new_cost1 = distance_matrix_1[new_solution[u-1], new_solution[v]] + distance_matrix_1[new_solution[v-1], new_solution[u]]\n\n            current_cost2 = distance_matrix_2[new_solution[u-1], new_solution[u]] + distance_matrix_2[new_solution[v-1], new_solution[v]]\n            new_cost2 = distance_matrix_2[new_solution[u-1], new_solution[v]] + distance_matrix_2[new_solution[v-1], new_solution[u]]\n\n            # Apply reallocation if beneficial for at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations with adaptive segment lengths and probabilistic edge swaps to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate Pareto dominance and diversity scores\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = objectives.max(axis=0)\n        normalized = objectives / max_obj\n\n        # Score based on dominance (lower is better) and diversity (higher is better)\n        dominance_scores = normalized.sum(axis=1)\n        diversity_scores = np.linalg.norm(normalized - np.mean(normalized, axis=0), axis=1)\n        combined_scores = 0.7 * dominance_scores + 0.3 * diversity_scores\n\n        # Select the solution with the best combined score\n        selected_idx = np.argmin(combined_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    i = random.randint(0, n - segment_length - 2)\n    j = i + segment_length\n\n    # Reverse the selected segment\n    middle_segment = new_solution[i:j]\n    new_solution[i:j] = middle_segment[::-1]\n\n    # Probabilistic edge swaps\n    for _ in range(3):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Accept swap if beneficial for at least one objective or with some probability\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or random.random() < 0.3:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.345620079948176,
            7.18865781329667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate Pareto dominance and diversity scores\n        objectives = np.array([obj for _, obj in archive])\n        max_obj = objectives.max(axis=0)\n        normalized = objectives / max_obj\n\n        # Score based on dominance (lower is better) and diversity (higher is better)\n        dominance_scores = normalized.sum(axis=1)\n        diversity_scores = np.linalg.norm(normalized - np.mean(normalized, axis=0), axis=1)\n        combined_scores = 0.7 * dominance_scores + 0.3 * diversity_scores\n\n        # Select the solution with the best combined score\n        selected_idx = np.argmin(combined_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_length = max(2, min(n // 4, random.randint(2, n // 2)))\n    i = random.randint(0, n - segment_length - 2)\n    j = i + segment_length\n\n    # Reverse the selected segment\n    middle_segment = new_solution[i:j]\n    new_solution[i:j] = middle_segment[::-1]\n\n    # Probabilistic edge swaps\n    for _ in range(3):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Accept swap if beneficial for at least one objective or with some probability\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or random.random() < 0.3:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment shifting and edge insertion operations to create a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to shift\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    remaining = np.delete(new_solution, np.arange(i, j+1))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, segment)\n\n    # Step 3: Randomly insert a node from the segment into a different position\n    if len(segment) > 1:\n        node_to_move = random.choice(segment)\n        pos_to_insert = random.randint(0, n - 1)\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_move)), pos_to_insert, node_to_move)\n\n    # Step 4: Check if the move improves at least one objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(n):\n            cost += distance_matrix[solution[k-1], solution[k]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    base_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    base_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    if not ((current_cost1 < base_cost1) or (current_cost2 < base_cost2)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.164249655321572,
            6.302734409785825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to shift\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    remaining = np.delete(new_solution, np.arange(i, j+1))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, segment)\n\n    # Step 3: Randomly insert a node from the segment into a different position\n    if len(segment) > 1:\n        node_to_move = random.choice(segment)\n        pos_to_insert = random.randint(0, n - 1)\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_move)), pos_to_insert, node_to_move)\n\n    # Step 4: Check if the move improves at least one objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for k in range(n):\n            cost += distance_matrix[solution[k-1], solution[k]]\n        return cost\n\n    current_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(new_solution, distance_matrix_2)\n    base_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    base_cost2 = calculate_cost(base_solution, distance_matrix_2)\n\n    if not ((current_cost1 < base_cost1) or (current_cost2 < base_cost2)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{The new algorithm selects a solution from the archive by considering both Pareto dominance and objective diversity, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to remove and reinsert\n    node_to_move = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_move]\n\n    # Step 2: Remove the node from the solution\n    new_solution = np.delete(new_solution, node_to_move)\n\n    # Step 3: Find the best insertion position for the removed node\n    best_pos = 0\n    best_improvement = 0\n    for pos in range(n - 1):\n        # Calculate cost difference for both objectives\n        cost_diff1 = (distance_matrix_1[new_solution[pos-1], removed_node] +\n                      distance_matrix_1[removed_node, new_solution[pos]] -\n                      distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n        cost_diff2 = (distance_matrix_2[new_solution[pos-1], removed_node] +\n                      distance_matrix_2[removed_node, new_solution[pos]] -\n                      distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n        # Combine improvements for both objectives\n        total_improvement = -cost_diff1 - cost_diff2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 4: Randomly rotate a segment if beneficial\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Try rotating the segment left and right\n    rotated_left = np.concatenate([segment[1:], [segment[0]]])\n    rotated_right = np.concatenate([[segment[-1]], segment[:-1]])\n\n    # Calculate cost differences for both rotations\n    cost_diff1_left = (distance_matrix_1[new_solution[i-1], rotated_left[0]] +\n                       distance_matrix_1[rotated_left[-1], new_solution[j]] -\n                       distance_matrix_1[new_solution[i-1], segment[0]] -\n                       distance_matrix_1[segment[-1], new_solution[j]])\n\n    cost_diff2_left = (distance_matrix_2[new_solution[i-1], rotated_left[0]] +\n                       distance_matrix_2[rotated_left[-1], new_solution[j]] -\n                       distance_matrix_2[new_solution[i-1], segment[0]] -\n                       distance_matrix_2[segment[-1], new_solution[j]])\n\n    cost_diff1_right = (distance_matrix_1[new_solution[i-1], rotated_right[0]] +\n                       distance_matrix_1[rotated_right[-1], new_solution[j]] -\n                       distance_matrix_1[new_solution[i-1], segment[0]] -\n                       distance_matrix_1[segment[-1], new_solution[j]])\n\n    cost_diff2_right = (distance_matrix_2[new_solution[i-1], rotated_right[0]] +\n                       distance_matrix_2[rotated_right[-1], new_solution[j]] -\n                       distance_matrix_2[new_solution[i-1], segment[0]] -\n                       distance_matrix_2[segment[-1], new_solution[j]])\n\n    # Apply the better rotation if beneficial for at least one objective\n    if (cost_diff1_left + cost_diff2_left < 0) or (cost_diff1_right + cost_diff2_right < 0):\n        if (cost_diff1_left + cost_diff2_left) < (cost_diff1_right + cost_diff2_right):\n            new_solution[i:j+1] = rotated_left\n        else:\n            new_solution[i:j+1] = rotated_right\n\n    return new_solution\n\n",
        "score": [
            7.280921769221203,
            6.674826390836893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to remove and reinsert\n    node_to_move = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_move]\n\n    # Step 2: Remove the node from the solution\n    new_solution = np.delete(new_solution, node_to_move)\n\n    # Step 3: Find the best insertion position for the removed node\n    best_pos = 0\n    best_improvement = 0\n    for pos in range(n - 1):\n        # Calculate cost difference for both objectives\n        cost_diff1 = (distance_matrix_1[new_solution[pos-1], removed_node] +\n                      distance_matrix_1[removed_node, new_solution[pos]] -\n                      distance_matrix_1[new_solution[pos-1], new_solution[pos]])\n\n        cost_diff2 = (distance_matrix_2[new_solution[pos-1], removed_node] +\n                      distance_matrix_2[removed_node, new_solution[pos]] -\n                      distance_matrix_2[new_solution[pos-1], new_solution[pos]])\n\n        # Combine improvements for both objectives\n        total_improvement = -cost_diff1 - cost_diff2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 4: Randomly rotate a segment if beneficial\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Try rotating the segment left and right\n    rotated_left = np.concatenate([segment[1:], [segment[0]]])\n    rotated_right = np.concatenate([[segment[-1]], segment[:-1]])\n\n    # Calculate cost differences for both rotations\n    cost_diff1_left = (distance_matrix_1[new_solution[i-1], rotated_left[0]] +\n                       distance_matrix_1[rotated_left[-1], new_solution[j]] -\n                       distance_matrix_1[new_solution[i-1], segment[0]] -\n                       distance_matrix_1[segment[-1], new_solution[j]])\n\n    cost_diff2_left = (distance_matrix_2[new_solution[i-1], rotated_left[0]] +\n                       distance_matrix_2[rotated_left[-1], new_solution[j]] -\n                       distance_matrix_2[new_solution[i-1], segment[0]] -\n                       distance_matrix_2[segment[-1], new_solution[j]])\n\n    cost_diff1_right = (distance_matrix_1[new_solution[i-1], rotated_right[0]] +\n                       distance_matrix_1[rotated_right[-1], new_solution[j]] -\n                       distance_matrix_1[new_solution[i-1], segment[0]] -\n                       distance_matrix_1[segment[-1], new_solution[j]])\n\n    cost_diff2_right = (distance_matrix_2[new_solution[i-1], rotated_right[0]] +\n                       distance_matrix_2[rotated_right[-1], new_solution[j]] -\n                       distance_matrix_2[new_solution[i-1], segment[0]] -\n                       distance_matrix_2[segment[-1], new_solution[j]])\n\n    # Apply the better rotation if beneficial for at least one objective\n    if (cost_diff1_left + cost_diff2_left < 0) or (cost_diff1_right + cost_diff2_right < 0):\n        if (cost_diff1_left + cost_diff2_left) < (cost_diff1_right + cost_diff2_right):\n            new_solution[i:j+1] = rotated_left\n        else:\n            new_solution[i:j+1] = rotated_right\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by considering both Pareto dominance and objective diversity, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        selected_idx = random.choice([0, 1]) if len(archive_sorted) > 1 else 0\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    segment_length = random.randint(2, min(4, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 3: Randomly insert a node from elsewhere in the tour\n    if n > 4:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-1)\n        if node_to_move != insert_pos and abs(node_to_move - insert_pos) > 1:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            10.541707584645705,
            10.611056650168532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        selected_idx = random.choice([0, 1]) if len(archive_sorted) > 1 else 0\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    segment_length = random.randint(2, min(4, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 3: Randomly insert a node from elsewhere in the tour\n    if n > 4:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-1)\n        if node_to_move != insert_pos and abs(node_to_move - insert_pos) > 1:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on both objective diversity and dominance, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Find the solution with the most extreme objective values\n        max_diff = -1\n        selected_idx = 0\n        for i, obj in enumerate(objectives):\n            diff = abs(obj[0] - obj[1])\n            if diff > max_diff:\n                max_diff = diff\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    # Apply edge insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            7.347866969821781,
            6.9817382798376775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Find the solution with the most extreme objective values\n        max_diff = -1\n        selected_idx = 0\n        for i, obj in enumerate(objectives):\n            diff = abs(obj[0] - obj[1])\n            if diff > max_diff:\n                max_diff = diff\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    # Apply edge insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (diverse selection)\n        objectives = np.array([(obj[0] + obj[1]) for (sol, obj) in archive])\n        selected_idx = np.argmax(objectives)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[j-1:i: -1]\n\n    # Step 2: Perform a 3-opt operation for diversity\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Step 3: Apply a biased edge swap based on objective improvement\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective with a bias towards the worse objective\n    if (new_cost1 < current_cost1 and (new_cost1 < new_cost2 or random.random() < 0.3)) or \\\n       (new_cost2 < current_cost2 and (new_cost2 < new_cost1 or random.random() < 0.3)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.507223199639483,
            10.609314781764832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (diverse selection)\n        objectives = np.array([(obj[0] + obj[1]) for (sol, obj) in archive])\n        selected_idx = np.argmax(objectives)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[j-1:i: -1]\n\n    # Step 2: Perform a 3-opt operation for diversity\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Step 3: Apply a biased edge swap based on objective improvement\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective with a bias towards the worse objective\n    if (new_cost1 < current_cost1 and (new_cost1 < new_cost2 or random.random() < 0.3)) or \\\n       (new_cost2 < current_cost2 and (new_cost2 < new_cost1 or random.random() < 0.3)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] - obj[1])**2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select two edges to swap if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.752277723487163,
            8.650471939575205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] - obj[1])**2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select two edges to swap if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{A novel local search algorithm prioritizes solutions with high crowding distance in the Pareto front, then applies a combination of node insertion and multi-segment reversal to generate a neighbor solution while ensuring feasibility through a novel validation mechanism that checks for node uniqueness and tour completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([], dtype=int)\n\n    # Select solution with highest crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0] * len(solutions)\n\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(solutions)-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply multi-segment reversal with node insertion\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    c = random.randint(0, n-1)\n\n    # Ensure all indices are distinct\n    while b == a or c == a or c == b:\n        b = random.randint(0, n-1)\n        c = random.randint(0, n-1)\n\n    # Sort indices\n    a, b, c = sorted([a, b, c])\n\n    # Insert node b between a and c\n    if b < a or b > c:\n        segment = new_solution[b:a] if b < a else new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], [new_solution[b]], new_solution[a:b], new_solution[b+1:c+1], new_solution[c+1:]])\n    else:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c+1:]])\n\n    # Reverse the middle segment\n    if a < c:\n        new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    # Validate solution\n    if len(np.unique(new_solution)) == n and set(new_solution) == set(base_solution):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            8.450254609604302,
            7.82347844658973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([], dtype=int)\n\n    # Select solution with highest crowding distance\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return [0] * len(solutions)\n\n        objectives = np.array([obj for _, obj in solutions])\n        distances = np.zeros(len(solutions))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(solutions)-1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply multi-segment reversal with node insertion\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    c = random.randint(0, n-1)\n\n    # Ensure all indices are distinct\n    while b == a or c == a or c == b:\n        b = random.randint(0, n-1)\n        c = random.randint(0, n-1)\n\n    # Sort indices\n    a, b, c = sorted([a, b, c])\n\n    # Insert node b between a and c\n    if b < a or b > c:\n        segment = new_solution[b:a] if b < a else new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], [new_solution[b]], new_solution[a:b], new_solution[b+1:c+1], new_solution[c+1:]])\n    else:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[a:b], new_solution[c+1:]])\n\n    # Reverse the middle segment\n    if a < c:\n        new_solution[a:c+1] = new_solution[a:c+1][::-1]\n\n    # Validate solution\n    if len(np.unique(new_solution)) == n and set(new_solution) == set(base_solution):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{The new algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility, but uses a dynamic segment selection strategy that adapts to the current solution's structure and objective values to guide the local search more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        # Select based on diversity (maximize sum of normalized objectives)\n        selected_idx = np.argmax(np.sum(normalized, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on current solution's structure\n    # Identify segments with high cost in either objective\n    segment_costs1 = []\n    segment_costs2 = []\n    for i in range(n - 1):\n        segment_costs1.append(distance_matrix_1[new_solution[i], new_solution[i+1]])\n        segment_costs2.append(distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n    # Combine costs and select the worst segment to improve\n    combined_costs = np.array(segment_costs1) + np.array(segment_costs2)\n    worst_segment = np.argmax(combined_costs)\n\n    # Apply segment reversal around the worst segment\n    i = max(0, worst_segment - 2)\n    j = min(n - 1, worst_segment + 2)\n    if i < j - 1:\n        middle_segment = new_solution[i:j]\n        new_solution[i:j] = middle_segment[::-1]\n\n    # Apply edge exchange based on dynamic selection\n    # Select edges with high cost in either objective\n    edge_costs1 = []\n    edge_costs2 = []\n    for i in range(n - 1):\n        edge_costs1.append(distance_matrix_1[new_solution[i], new_solution[i+1]])\n        edge_costs2.append(distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n    # Find the worst edges in either objective\n    worst_edge1 = np.argmax(edge_costs1)\n    worst_edge2 = np.argmax(edge_costs2)\n\n    # Choose the worst edge in either objective\n    if edge_costs1[worst_edge1] + edge_costs2[worst_edge1] > edge_costs1[worst_edge2] + edge_costs2[worst_edge2]:\n        k = worst_edge1\n    else:\n        k = worst_edge2\n\n    # Find a compatible edge to swap with\n    l = (k + random.randint(2, n - 2)) % (n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]] + distance_matrix_1[new_solution[l], new_solution[l+1]]\n    new_cost1 = distance_matrix_1[new_solution[k], new_solution[l+1]] + distance_matrix_1[new_solution[l], new_solution[k+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]] + distance_matrix_2[new_solution[l], new_solution[l+1]]\n    new_cost2 = distance_matrix_2[new_solution[k], new_solution[l+1]] + distance_matrix_2[new_solution[l], new_solution[k+1]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the swap\n        if k < l:\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n        else:\n            new_solution[l+1:k+1] = new_solution[l+1:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            10.522958261620404,
            10.588956777072614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        # Select based on diversity (maximize sum of normalized objectives)\n        selected_idx = np.argmax(np.sum(normalized, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on current solution's structure\n    # Identify segments with high cost in either objective\n    segment_costs1 = []\n    segment_costs2 = []\n    for i in range(n - 1):\n        segment_costs1.append(distance_matrix_1[new_solution[i], new_solution[i+1]])\n        segment_costs2.append(distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n    # Combine costs and select the worst segment to improve\n    combined_costs = np.array(segment_costs1) + np.array(segment_costs2)\n    worst_segment = np.argmax(combined_costs)\n\n    # Apply segment reversal around the worst segment\n    i = max(0, worst_segment - 2)\n    j = min(n - 1, worst_segment + 2)\n    if i < j - 1:\n        middle_segment = new_solution[i:j]\n        new_solution[i:j] = middle_segment[::-1]\n\n    # Apply edge exchange based on dynamic selection\n    # Select edges with high cost in either objective\n    edge_costs1 = []\n    edge_costs2 = []\n    for i in range(n - 1):\n        edge_costs1.append(distance_matrix_1[new_solution[i], new_solution[i+1]])\n        edge_costs2.append(distance_matrix_2[new_solution[i], new_solution[i+1]])\n\n    # Find the worst edges in either objective\n    worst_edge1 = np.argmax(edge_costs1)\n    worst_edge2 = np.argmax(edge_costs2)\n\n    # Choose the worst edge in either objective\n    if edge_costs1[worst_edge1] + edge_costs2[worst_edge1] > edge_costs1[worst_edge2] + edge_costs2[worst_edge2]:\n        k = worst_edge1\n    else:\n        k = worst_edge2\n\n    # Find a compatible edge to swap with\n    l = (k + random.randint(2, n - 2)) % (n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k], new_solution[k+1]] + distance_matrix_1[new_solution[l], new_solution[l+1]]\n    new_cost1 = distance_matrix_1[new_solution[k], new_solution[l+1]] + distance_matrix_1[new_solution[l], new_solution[k+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[k], new_solution[k+1]] + distance_matrix_2[new_solution[l], new_solution[l+1]]\n    new_cost2 = distance_matrix_2[new_solution[k], new_solution[l+1]] + distance_matrix_2[new_solution[l], new_solution[k+1]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the swap\n        if k < l:\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n        else:\n            new_solution[l+1:k+1] = new_solution[l+1:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive using a combination of Pareto dominance and crowding distance metrics, then applies a segment inversion and edge exchange operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        combined = obj[0] + obj[1]\n        if combined < best_value:\n            best_value = combined\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a segment inversion operation\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 1)\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply an edge exchange operation\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.316917933927426,
            6.507641983442583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        combined = obj[0] + obj[1]\n        if combined < best_value:\n            best_value = combined\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a segment inversion operation\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 1)\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Apply an edge exchange operation\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This novel algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, len(archive_sorted) - 1])  # Prefer extremes\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Rotate a segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Insert a node at a different position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            6.955537988214084,
            7.545464321022352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, len(archive_sorted) - 1])  # Prefer extremes\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Rotate a segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Insert a node at a different position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance_scores = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for j, (other_sol, other_obj) in enumerate(archive):\n                if i == j:\n                    continue\n                if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                    dominated += 1\n            dominance_scores.append(dominated)\n\n        # Select the solution with the highest dominance score\n        selected_idx = dominance_scores.index(max(dominance_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.469268041492507,
            10.538858342586142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores\n        dominance_scores = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = 0\n            for j, (other_sol, other_obj) in enumerate(archive):\n                if i == j:\n                    continue\n                if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                    dominated += 1\n            dominance_scores.append(dominated)\n\n        # Select the solution with the highest dominance score\n        selected_idx = dominance_scores.index(max(dominance_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive based on objective space coverage, then applies a combination of segment reversal and edge exchange operations with adaptive neighborhood selection to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum objective space coverage\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive neighborhood selection\n    segment_size = max(2, min(5, n // 4))\n    i = random.randint(0, n - segment_size - 2)\n    j = i + segment_size\n\n    # Segment reversal with adaptive step\n    middle_segment = new_solution[i:j]\n    new_solution[i:j] = middle_segment[::-1]\n\n    # Edge exchange with objective-aware selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap based on combined objective improvement\n    if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.709523440021984,
            8.523340876039349
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with maximum objective space coverage\n    selected_idx = np.argmax([abs(obj[0] - obj[1]) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive neighborhood selection\n    segment_size = max(2, min(5, n // 4))\n    i = random.randint(0, n - segment_size - 2)\n    j = i + segment_size\n\n    # Segment reversal with adaptive step\n    middle_segment = new_solution[i:j]\n    new_solution[i:j] = middle_segment[::-1]\n\n    # Edge exchange with objective-aware selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap based on combined objective improvement\n    if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A novel multi-objective local search algorithm selects a solution from the archive based on objective diversity, then applies a combination of segment rotation and edge insertion operations to create a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diversity_idx = np.argmax([abs(obj[0] - obj[1]) for obj in objectives])\n        base_solution = archive[max_diversity_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Step 2: Randomly insert a node between two edges if beneficial\n    k = random.randint(1, n - 2)\n    l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[k+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[k+1]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, k+1, new_solution[l])\n        new_solution = np.delete(new_solution, l if l < k+1 else l+1)\n\n    return new_solution\n\n",
        "score": [
            7.324809238884607,
            6.952929548744228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diversity_idx = np.argmax([abs(obj[0] - obj[1]) for obj in objectives])\n        base_solution = archive[max_diversity_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Step 2: Randomly insert a node between two edges if beneficial\n    k = random.randint(1, n - 2)\n    l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[k+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[k+1]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, k+1, new_solution[l])\n        new_solution = np.delete(new_solution, l if l < k+1 else l+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Apply a series of edge swaps if beneficial\n    for _ in range(3):  # Perform 3 swaps\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 3: Apply a segment shift operation\n    shift_size = random.randint(2, min(4, n//2))\n    shift_pos = random.randint(0, n - shift_size - 1)\n    segment = new_solution[shift_pos:shift_pos+shift_size]\n    new_solution = np.concatenate([new_solution[:shift_pos], new_solution[shift_pos+shift_size:], segment])\n\n    return new_solution\n\n",
        "score": [
            6.82528211712118,
            6.531889154687553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Apply a series of edge swaps if beneficial\n    for _ in range(3):  # Perform 3 swaps\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 3: Apply a segment shift operation\n    shift_size = random.randint(2, min(4, n//2))\n    shift_pos = random.randint(0, n - shift_size - 1)\n    segment = new_solution[shift_pos:shift_pos+shift_size]\n    new_solution = np.concatenate([new_solution[:shift_pos], new_solution[shift_pos+shift_size:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This algorithm selects a solution from the archive based on high Pareto efficiency, then applies a combination of node insertion and segment rotation to generate a neighbor solution while ensuring feasibility by carefully maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, n - 1)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Step 3: Randomly select a node to reinsert elsewhere\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n\n    # Remove the node and reinsert it in a random position\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.789726623082105,
            6.642623442964636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 2, n - 1)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Step 3: Randomly select a node to reinsert elsewhere\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n\n    # Remove the node and reinsert it in a random position\n    new_solution = np.delete(new_solution, node_pos)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and distance diversity, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first and second objective\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform edge insertion\n    temp = new_solution.copy()\n    temp[b], temp[a] = temp[a], temp[b]\n    temp[c], temp[b] = temp[b], temp[c]\n\n    # Calculate costs\n    def calc_cost(sol, dm):\n        return sum(dm[sol[i-1], sol[i]] for i in range(len(sol)))\n\n    current_cost1 = calc_cost(new_solution, distance_matrix_1)\n    current_cost2 = calc_cost(new_solution, distance_matrix_2)\n    new_cost1 = calc_cost(temp, distance_matrix_1)\n    new_cost2 = calc_cost(temp, distance_matrix_2)\n\n    # Apply if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = temp\n\n    # Step 3: Random segment reversal\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            5.396432221194397,
            6.610125780907585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first and second objective\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform edge insertion\n    temp = new_solution.copy()\n    temp[b], temp[a] = temp[a], temp[b]\n    temp[c], temp[b] = temp[b], temp[c]\n\n    # Calculate costs\n    def calc_cost(sol, dm):\n        return sum(dm[sol[i-1], sol[i]] for i in range(len(sol)))\n\n    current_cost1 = calc_cost(new_solution, distance_matrix_1)\n    current_cost2 = calc_cost(new_solution, distance_matrix_2)\n    new_cost1 = calc_cost(temp, distance_matrix_1)\n    new_cost2 = calc_cost(temp, distance_matrix_2)\n\n    # Apply if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = temp\n\n    # Step 3: Random segment reversal\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{This novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a novel segment relocation and edge insertion operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 50% or random if too few\n        candidates = sorted_archive[:max(1, len(archive)//2)]\n        selected_idx = random.randint(0, len(candidates)-1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel segment relocation and edge insertion\n    # Select a segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-1)\n\n    # Extract the segment\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Find insertion point that minimizes both objectives\n    best_insert = 0\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for i in range(n-1):\n        if i >= seg_start and i <= seg_end:\n            continue\n\n        # Calculate cost for inserting after position i\n        cost1 = distance_matrix_1[new_solution[i], segment[0]] + distance_matrix_1[segment[-1], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], segment[0]] + distance_matrix_2[segment[-1], new_solution[(i+1)%n]]\n\n        if i > seg_start:  # Account for removed edges\n            cost1 += distance_matrix_1[new_solution[seg_start-1], new_solution[seg_end+1]]\n            cost2 += distance_matrix_2[new_solution[seg_start-1], new_solution[seg_end+1]]\n\n        if cost1 < best_cost1 or (cost1 == best_cost1 and cost2 < best_cost2):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_insert = i\n\n    # Insert the segment\n    if best_insert > seg_start:\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:best_insert+1],\n            segment,\n            new_solution[best_insert+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:best_insert+1],\n            segment,\n            new_solution[best_insert+1:seg_start],\n            new_solution[seg_end+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            4.92634912170131,
            8.877590845860304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 50% or random if too few\n        candidates = sorted_archive[:max(1, len(archive)//2)]\n        selected_idx = random.randint(0, len(candidates)-1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Novel segment relocation and edge insertion\n    # Select a segment to relocate\n    seg_start = random.randint(0, n-3)\n    seg_end = random.randint(seg_start+1, n-1)\n\n    # Extract the segment\n    segment = new_solution[seg_start:seg_end+1]\n\n    # Find insertion point that minimizes both objectives\n    best_insert = 0\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for i in range(n-1):\n        if i >= seg_start and i <= seg_end:\n            continue\n\n        # Calculate cost for inserting after position i\n        cost1 = distance_matrix_1[new_solution[i], segment[0]] + distance_matrix_1[segment[-1], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i], segment[0]] + distance_matrix_2[segment[-1], new_solution[(i+1)%n]]\n\n        if i > seg_start:  # Account for removed edges\n            cost1 += distance_matrix_1[new_solution[seg_start-1], new_solution[seg_end+1]]\n            cost2 += distance_matrix_2[new_solution[seg_start-1], new_solution[seg_end+1]]\n\n        if cost1 < best_cost1 or (cost1 == best_cost1 and cost2 < best_cost2):\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_insert = i\n\n    # Insert the segment\n    if best_insert > seg_start:\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:best_insert+1],\n            segment,\n            new_solution[best_insert+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:best_insert+1],\n            segment,\n            new_solution[best_insert+1:seg_start],\n            new_solution[seg_end+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A new hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (diversity) and pick top 20% or the best one\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(3, len(sorted_archive) - 1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, n - segment_start - 1)\n\n    # Step 2: Rotate the segment left by one position\n    rotated_segment = np.roll(new_solution[segment_start:segment_start+segment_length], -1)\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere in the tour\n    if n > 4:\n        insert_pos = random.randint(0, n - 1)\n        node_to_insert = new_solution[insert_pos]\n        new_solution = np.delete(new_solution, insert_pos)\n        new_insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, new_insert_pos, node_to_insert)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            7.560021567514551,
            6.892785229299687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives (diversity) and pick top 20% or the best one\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(3, len(sorted_archive) - 1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, n - segment_start - 1)\n\n    # Step 2: Rotate the segment left by one position\n    rotated_segment = np.roll(new_solution[segment_start:segment_start+segment_length], -1)\n    new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere in the tour\n    if n > 4:\n        insert_pos = random.randint(0, n - 1)\n        node_to_insert = new_solution[insert_pos]\n        new_solution = np.delete(new_solution, insert_pos)\n        new_insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, new_insert_pos, node_to_insert)\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on objective diversity and applies a combination of node insertion and segment rotation operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated_segment\n\n    # Apply node insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.760784178575703,
            8.671304263647118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated_segment\n\n    # Apply node insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        # Calculate crowding distance to prioritize diverse solutions\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and swap them if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 4: Randomly shift a segment\n    if n > 4:\n        shift_size = random.randint(1, min(3, n // 4))\n        shift_pos = random.randint(0, n - shift_size)\n        segment = new_solution[shift_pos:shift_pos+shift_size]\n        new_solution = np.concatenate([new_solution[:shift_pos], new_solution[shift_pos+shift_size:], segment])\n\n    return new_solution\n\n",
        "score": [
            8.533702585845742,
            9.487498012269388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        # Calculate crowding distance to prioritize diverse solutions\n        crowding = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(objectives)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (objectives[sorted_idx[-1]][m] - objectives[sorted_idx[0]][m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and swap them if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 4: Randomly shift a segment\n    if n > 4:\n        shift_size = random.randint(1, min(3, n // 4))\n        shift_pos = random.randint(0, n - shift_size)\n        segment = new_solution[shift_pos:shift_pos+shift_size]\n        new_solution = np.concatenate([new_solution[:shift_pos], new_solution[shift_pos+shift_size:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{This algorithm selects a solution from the archive based on its Pareto dominance and applies a novel combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l and new_solution[k] != new_solution[l]:\n        # Find positions to insert\n        pos_k = np.where(new_solution == new_solution[k])[0][0]\n        pos_l = np.where(new_solution == new_solution[l])[0][0]\n\n        # Insert node l after node k\n        new_solution = np.concatenate([\n            new_solution[:pos_k+1],\n            [new_solution[pos_l]],\n            new_solution[pos_k+1:pos_l],\n            new_solution[pos_l+1:]\n        ])\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.17513070574814,
            6.946811984099006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l and new_solution[k] != new_solution[l]:\n        # Find positions to insert\n        pos_k = np.where(new_solution == new_solution[k])[0][0]\n        pos_l = np.where(new_solution == new_solution[l])[0][0]\n\n        # Insert node l after node k\n        new_solution = np.concatenate([\n            new_solution[:pos_k+1],\n            [new_solution[pos_l]],\n            new_solution[pos_k+1:pos_l],\n            new_solution[pos_l+1:]\n        ])\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on crowding distance and applies a dynamic segment insertion and edge crossover operator to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 1:\n        return instance[:, 0].copy()\n\n    # Select the solution with highest crowding distance in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment insertion\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a or (b == (a+1)%n or b == (a-1)%n):\n        b = random.randint(0, n-1)\n\n    segment = new_solution[a:b] if a < b else np.concatenate([new_solution[a:], new_solution[:b]])\n\n    # Find insertion point that minimizes both objectives\n    min_cost = float('inf')\n    best_pos = -1\n    for pos in range(n):\n        if pos in range(a, b) if a < b else (pos in range(a, n) or pos in range(0, b)):\n            continue\n\n        # Create potential new solution\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n        if len(temp_solution) > n:\n            temp_solution = temp_solution[:n]\n\n        # Calculate total cost\n        total_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        total_cost = total_cost1 + total_cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n    # Edge crossover with a random solution\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find common edges\n        edges = set()\n        for i in range(n):\n            edges.add((min(new_solution[i-1], new_solution[i]), max(new_solution[i-1], new_solution[i])))\n            edges.add((min(other_solution[i-1], other_solution[i]), max(other_solution[i-1], other_solution[i])))\n\n        # Create new solution from common edges\n        if edges:\n            from collections import defaultdict\n            graph = defaultdict(list)\n            for a, b in edges:\n                graph[a].append(b)\n                graph[b].append(a)\n\n            # Find a cycle\n            visited = set()\n            tour = []\n            start = next(iter(graph))\n            stack = [(start, None)]\n            while stack:\n                node, parent = stack.pop()\n                if node in visited:\n                    continue\n                visited.add(node)\n                tour.append(node)\n                for neighbor in graph[node]:\n                    if neighbor != parent:\n                        stack.append((neighbor, node))\n\n            if len(tour) >= n:\n                new_solution = np.array(tour[:n])\n            else:\n                # Fill remaining nodes\n                remaining_nodes = [node for node in range(n) if node not in tour]\n                new_solution = np.concatenate([new_solution[:n-len(remaining_nodes)], remaining_nodes])\n\n    return new_solution\n\n",
        "score": [
            7.188444827563174,
            7.524942123306637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 1:\n        return instance[:, 0].copy()\n\n    # Select the solution with highest crowding distance in the objective space\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n    for i in range(2):\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding_distances[sorted_idx[0]] = np.inf\n        crowding_distances[sorted_idx[-1]] = np.inf\n        for j in range(1, len(sorted_idx)-1):\n            crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment insertion\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a or (b == (a+1)%n or b == (a-1)%n):\n        b = random.randint(0, n-1)\n\n    segment = new_solution[a:b] if a < b else np.concatenate([new_solution[a:], new_solution[:b]])\n\n    # Find insertion point that minimizes both objectives\n    min_cost = float('inf')\n    best_pos = -1\n    for pos in range(n):\n        if pos in range(a, b) if a < b else (pos in range(a, n) or pos in range(0, b)):\n            continue\n\n        # Create potential new solution\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n        if len(temp_solution) > n:\n            temp_solution = temp_solution[:n]\n\n        # Calculate total cost\n        total_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        total_cost = total_cost1 + total_cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n    # Edge crossover with a random solution\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find common edges\n        edges = set()\n        for i in range(n):\n            edges.add((min(new_solution[i-1], new_solution[i]), max(new_solution[i-1], new_solution[i])))\n            edges.add((min(other_solution[i-1], other_solution[i]), max(other_solution[i-1], other_solution[i])))\n\n        # Create new solution from common edges\n        if edges:\n            from collections import defaultdict\n            graph = defaultdict(list)\n            for a, b in edges:\n                graph[a].append(b)\n                graph[b].append(a)\n\n            # Find a cycle\n            visited = set()\n            tour = []\n            start = next(iter(graph))\n            stack = [(start, None)]\n            while stack:\n                node, parent = stack.pop()\n                if node in visited:\n                    continue\n                visited.add(node)\n                tour.append(node)\n                for neighbor in graph[node]:\n                    if neighbor != parent:\n                        stack.append((neighbor, node))\n\n            if len(tour) >= n:\n                new_solution = np.array(tour[:n])\n            else:\n                # Fill remaining nodes\n                remaining_nodes = [node for node in range(n) if node not in tour]\n                new_solution = np.concatenate([new_solution[:n-len(remaining_nodes)], remaining_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity and applies a combination of node insertion, segment reversal, and edge exchange operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversities = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node and remove it\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n    new_solution = np.delete(new_solution, node_to_remove)\n\n    # Step 2: Find the best insertion point for the removed node\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(n - 1):\n        prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node]\n\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 + improvement2 > best_improvement:\n            best_improvement = improvement1 + improvement2\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 3: Apply segment reversal if beneficial\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    original_segment_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i+1, j+1))\n    reversed_segment_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in reversed(range(i, j)))\n\n    original_segment_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i+1, j+1))\n    reversed_segment_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in reversed(range(i, j)))\n\n    if (reversed_segment_cost1 < original_segment_cost1) or (reversed_segment_cost2 < original_segment_cost2):\n        new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Step 4: Apply edge exchange if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.434627673047626,
            5.729418970608263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    diversities = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(diversities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node and remove it\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n    new_solution = np.delete(new_solution, node_to_remove)\n\n    # Step 2: Find the best insertion point for the removed node\n    best_pos = 0\n    best_improvement = 0\n\n    for pos in range(n - 1):\n        prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos]\n\n        current_cost1 = distance_matrix_1[prev_node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node]\n\n        current_cost2 = distance_matrix_2[prev_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 + improvement2 > best_improvement:\n            best_improvement = improvement1 + improvement2\n            best_pos = pos\n\n    # Insert the node at the best position\n    new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Step 3: Apply segment reversal if beneficial\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    original_segment_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i+1, j+1))\n    reversed_segment_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in reversed(range(i, j)))\n\n    original_segment_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i+1, j+1))\n    reversed_segment_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in reversed(range(i, j)))\n\n    if (reversed_segment_cost1 < original_segment_cost1) or (reversed_segment_cost2 < original_segment_cost2):\n        new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    # Step 4: Apply edge exchange if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel hybrid local search algorithm that selects a solution from the archive based on both objective diversity and dominance, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = 0\n    else:\n        # Calculate diversity scores\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n        diversity = np.sum(diversity, axis=1)\n        diversity = diversity / np.max(diversity)\n\n        # Calculate dominance scores\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i == j:\n                    continue\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                   (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                    dominance[i] += 1\n\n        # Combine scores and select\n        scores = 0.7 * diversity + 0.3 * dominance\n        selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(i, j)\n\n    segment = new_solution[i:j+1]\n    rotated = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i:j+1] = rotated\n\n    # Apply edge insertion\n    if n > 4:\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        while abs(a - b) < 2:\n            b = random.randint(0, n - 1)\n\n        # Calculate costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert node b after a\n            if a < b:\n                new_solution = np.concatenate([new_solution[:a+1], [new_solution[b]], new_solution[a+1:b], new_solution[b+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:b], new_solution[b+1:a], [new_solution[b]], new_solution[a:]])\n\n    return new_solution\n\n",
        "score": [
            7.429588091826828,
            7.562008216018395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        selected_idx = 0\n    else:\n        # Calculate diversity scores\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n        diversity = np.sum(diversity, axis=1)\n        diversity = diversity / np.max(diversity)\n\n        # Calculate dominance scores\n        dominance = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i == j:\n                    continue\n                if (archive[i][1][0] <= archive[j][1][0] and archive[i][1][1] < archive[j][1][1]) or \\\n                   (archive[i][1][0] < archive[j][1][0] and archive[i][1][1] <= archive[j][1][1]):\n                    dominance[i] += 1\n\n        # Combine scores and select\n        scores = 0.7 * diversity + 0.3 * dominance\n        selected_idx = np.argmax(scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(i, j)\n\n    segment = new_solution[i:j+1]\n    rotated = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i:j+1] = rotated\n\n    # Apply edge insertion\n    if n > 4:\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        while abs(a - b) < 2:\n            b = random.randint(0, n - 1)\n\n        # Calculate costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert node b after a\n            if a < b:\n                new_solution = np.concatenate([new_solution[:a+1], [new_solution[b]], new_solution[a+1:b], new_solution[b+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:b], new_solution[b+1:a], [new_solution[b]], new_solution[a:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        if sum(obj) > max_sum:\n            max_sum = sum(obj)\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply a 3-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    new_solution[a:c] = base_solution[a:c][::-1]\n\n    # Step 3: Randomly swap two nodes if beneficial\n    k, l = random.sample(range(n), 2)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.475122282199841,
            10.608855318821679
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_sum = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        if sum(obj) > max_sum:\n            max_sum = sum(obj)\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Apply a 3-opt move\n    new_solution[a:b] = base_solution[a:b][::-1]\n    new_solution[b:c] = base_solution[b:c][::-1]\n    new_solution[a:c] = base_solution[a:c][::-1]\n\n    # Step 3: Randomly swap two nodes if beneficial\n    k, l = random.sample(range(n), 2)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This novel local search algorithm selects a solution from the archive by prioritizing those with high Pareto dominance, then applies a combination of edge insertion and segment shifting operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to shift\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Extract the segment and remove it from the solution\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Randomly select a new position to insert the segment\n    insert_pos = random.randint(0, len(remaining))\n\n    # Step 4: Insert the segment back into the new position\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 5: Randomly select an edge to insert elsewhere\n    k = random.randint(0, n - 2)\n    edge_node = new_solution[k]\n\n    # Step 6: Find the best position to insert the edge\n    best_pos = k\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n):\n        if pos == k or pos == k + 1:\n            continue\n\n        # Calculate potential cost\n        if pos == 0:\n            cost1 = distance_matrix_1[new_solution[-1], edge_node] + distance_matrix_1[edge_node, new_solution[pos]] + distance_matrix_1[new_solution[k-1], new_solution[k+1]]\n            cost2 = distance_matrix_2[new_solution[-1], edge_node] + distance_matrix_2[edge_node, new_solution[pos]] + distance_matrix_2[new_solution[k-1], new_solution[k+1]]\n        elif pos == n - 1:\n            cost1 = distance_matrix_1[new_solution[k-1], edge_node] + distance_matrix_1[edge_node, new_solution[0]] + distance_matrix_1[new_solution[pos-1], new_solution[0]]\n            cost2 = distance_matrix_2[new_solution[k-1], edge_node] + distance_matrix_2[edge_node, new_solution[0]] + distance_matrix_2[new_solution[pos-1], new_solution[0]]\n        else:\n            cost1 = distance_matrix_1[new_solution[k-1], edge_node] + distance_matrix_1[edge_node, new_solution[pos]] + distance_matrix_1[new_solution[pos-1], new_solution[k+1]]\n            cost2 = distance_matrix_2[new_solution[k-1], edge_node] + distance_matrix_2[edge_node, new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[k+1]]\n\n        if cost1 < best_cost1 or cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    # Step 7: Insert the edge at the best position\n    if best_pos != k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:best_pos+1], [edge_node], new_solution[best_pos+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.88518822210974,
            7.106262554923979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to shift\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Extract the segment and remove it from the solution\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Randomly select a new position to insert the segment\n    insert_pos = random.randint(0, len(remaining))\n\n    # Step 4: Insert the segment back into the new position\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 5: Randomly select an edge to insert elsewhere\n    k = random.randint(0, n - 2)\n    edge_node = new_solution[k]\n\n    # Step 6: Find the best position to insert the edge\n    best_pos = k\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n):\n        if pos == k or pos == k + 1:\n            continue\n\n        # Calculate potential cost\n        if pos == 0:\n            cost1 = distance_matrix_1[new_solution[-1], edge_node] + distance_matrix_1[edge_node, new_solution[pos]] + distance_matrix_1[new_solution[k-1], new_solution[k+1]]\n            cost2 = distance_matrix_2[new_solution[-1], edge_node] + distance_matrix_2[edge_node, new_solution[pos]] + distance_matrix_2[new_solution[k-1], new_solution[k+1]]\n        elif pos == n - 1:\n            cost1 = distance_matrix_1[new_solution[k-1], edge_node] + distance_matrix_1[edge_node, new_solution[0]] + distance_matrix_1[new_solution[pos-1], new_solution[0]]\n            cost2 = distance_matrix_2[new_solution[k-1], edge_node] + distance_matrix_2[edge_node, new_solution[0]] + distance_matrix_2[new_solution[pos-1], new_solution[0]]\n        else:\n            cost1 = distance_matrix_1[new_solution[k-1], edge_node] + distance_matrix_1[edge_node, new_solution[pos]] + distance_matrix_1[new_solution[pos-1], new_solution[k+1]]\n            cost2 = distance_matrix_2[new_solution[k-1], edge_node] + distance_matrix_2[edge_node, new_solution[pos]] + distance_matrix_2[new_solution[pos-1], new_solution[k+1]]\n\n        if cost1 < best_cost1 or cost2 < best_cost2:\n            best_cost1 = cost1\n            best_cost2 = cost2\n            best_pos = pos\n\n    # Step 7: Insert the edge at the best position\n    if best_pos != k:\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:best_pos+1], [edge_node], new_solution[best_pos+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive by prioritizing those with high crowding distance or extreme objective values, then applies a combination of segment insertion and edge rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(2):\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    a = random.randint(0, n-3)\n    b = random.randint(a+1, n-2)\n\n    # Step 2: Remove the segment and insert it elsewhere\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Rotate a random segment by 1 position\n    c = random.randint(0, n-2)\n    d = random.randint(c+1, n-1)\n    new_solution[c:d] = np.roll(new_solution[c:d], 1)\n\n    return new_solution\n\n",
        "score": [
            8.509747852854415,
            8.641826858386244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(2):\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i]) / (objectives[sorted_indices[-1], i] - objectives[sorted_indices[0], i])\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    a = random.randint(0, n-3)\n    b = random.randint(a+1, n-2)\n\n    # Step 2: Remove the segment and insert it elsewhere\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Rotate a random segment by 1 position\n    c = random.randint(0, n-2)\n    d = random.randint(c+1, n-1)\n    new_solution[c:d] = np.roll(new_solution[c:d], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its Pareto dominance and applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n\n    # Step 2: Rotate the segment\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 3: Insert a randomly selected node into a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure uniqueness by removing duplicates (keeping first occurrence)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If we removed nodes, add them back in random positions\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(base_solution, new_solution)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.882494730952439,
            6.881275253675939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n\n    # Step 2: Rotate the segment\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 3: Insert a randomly selected node into a random position\n    node_to_insert = random.choice(new_solution)\n    insert_pos = random.randint(0, n - 1)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Ensure uniqueness by removing duplicates (keeping first occurrence)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # If we removed nodes, add them back in random positions\n    if len(new_solution) < n:\n        missing_nodes = np.setdiff1d(base_solution, new_solution)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations with adaptive segment selection to generate improved neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective differences\n    obj1 = sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n))\n    obj2 = sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n))\n    obj_ratio = obj1 / (obj2 + 1e-6)\n\n    # Select segments based on objective ratio\n    if obj_ratio > 1.2:\n        i = random.randint(0, n//3)\n        j = random.randint(2*n//3, n-2)\n    elif obj_ratio < 0.8:\n        i = random.randint(n//3, 2*n//3)\n        j = random.randint(i+2, n-2)\n    else:\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n\n    # Reverse the selected segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability based on objective improvement\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    improvement_prob = 0.5 * (min(1, (current_cost1 - new_cost1)/current_cost1) + min(1, (current_cost2 - new_cost2)/current_cost2))\n\n    if random.random() < improvement_prob:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.513608229451929,
            10.60733056690124
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection based on objective differences\n    obj1 = sum(distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n))\n    obj2 = sum(distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n))\n    obj_ratio = obj1 / (obj2 + 1e-6)\n\n    # Select segments based on objective ratio\n    if obj_ratio > 1.2:\n        i = random.randint(0, n//3)\n        j = random.randint(2*n//3, n-2)\n    elif obj_ratio < 0.8:\n        i = random.randint(n//3, 2*n//3)\n        j = random.randint(i+2, n-2)\n    else:\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n\n    # Reverse the selected segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability based on objective improvement\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    improvement_prob = 0.5 * (min(1, (current_cost1 - new_cost1)/current_cost1) + min(1, (current_cost2 - new_cost2)/current_cost2))\n\n    if random.random() < improvement_prob:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search algorithm that selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation, edge insertion, and node relocation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Rotate a random segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Insert a random node at a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 4: Relocate a node to the position that minimizes the combined cost\n    best_pos = 0\n    min_cost = float('inf')\n    node = new_solution[random.randint(0, n - 1)]\n\n    for pos in range(n):\n        temp_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        temp_solution = np.insert(temp_solution, pos, node)\n        current_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        current_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = current_cost1 + current_cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.911665865337648,
            8.21643585043314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 2: Rotate a random segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Insert a random node at a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 4: Relocate a node to the position that minimizes the combined cost\n    best_pos = 0\n    min_cost = float('inf')\n    node = new_solution[random.randint(0, n - 1)]\n\n    for pos in range(n):\n        temp_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        temp_solution = np.insert(temp_solution, pos, node)\n        current_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        current_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        total_cost = current_cost1 + current_cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(sorted_archive) - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.099517587769177,
            6.135317234464969
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(sorted_archive) - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (normalized distance to other solutions)\n        diversity_scores = []\n        for i, (sol1, obj1) in enumerate(archive):\n            diversity = 0.0\n            for j, (sol2, obj2) in enumerate(archive):\n                if i != j:\n                    diversity += np.sum(sol1 != sol2)\n            diversity_scores.append(diversity / (len(archive) - 1))\n\n        # Combine objective values and diversity (weighted sum)\n        scores = []\n        for (sol, obj), diversity in zip(archive, diversity_scores):\n            score = 0.6 * (obj[0] + obj[1]) + 0.4 * diversity\n            scores.append(score)\n\n        # Select the solution with the lowest score (better objectives and more diverse)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    if n > 3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            # Remove node at position l and insert it after position k\n            node = new_solution[l]\n            new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n            insert_pos = (k + 1) % (n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.96706028534863,
            6.591552691846373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (normalized distance to other solutions)\n        diversity_scores = []\n        for i, (sol1, obj1) in enumerate(archive):\n            diversity = 0.0\n            for j, (sol2, obj2) in enumerate(archive):\n                if i != j:\n                    diversity += np.sum(sol1 != sol2)\n            diversity_scores.append(diversity / (len(archive) - 1))\n\n        # Combine objective values and diversity (weighted sum)\n        scores = []\n        for (sol, obj), diversity in zip(archive, diversity_scores):\n            score = 0.6 * (obj[0] + obj[1]) + 0.4 * diversity\n            scores.append(score)\n\n        # Select the solution with the lowest score (better objectives and more diverse)\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    if n > 3:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            # Remove node at position l and insert it after position k\n            node = new_solution[l]\n            new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n            insert_pos = (k + 1) % (n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find the solution with the most diverse objectives\n        selected_idx = max(range(len(archive)), key=lambda i: (objectives[i][0] - objectives[i][1])**2)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if k != l and k != (l - 1) % n and (k + 1) % n != l:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the insertion\n            if k < l:\n                new_solution[k+1:l+1] = new_solution[k:l]\n                new_solution[k] = new_solution[l]\n            else:\n                new_solution[l+1:k+1] = new_solution[l:k]\n                new_solution[k] = new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            7.560439952890598,
            7.2068885062891
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find the solution with the most diverse objectives\n        selected_idx = max(range(len(archive)), key=lambda i: (objectives[i][0] - objectives[i][1])**2)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 2, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if k != l and k != (l - 1) % n and (k + 1) % n != l:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Perform the insertion\n            if k < l:\n                new_solution[k+1:l+1] = new_solution[k:l]\n                new_solution[k] = new_solution[l]\n            else:\n                new_solution[l+1:k+1] = new_solution[l:k]\n                new_solution[k] = new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This new algorithm prioritizes solutions with high crowding distance in the Pareto front, then applies a combination of segment rotation and edge relocation operations to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_indices]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives_sorted[j+1, i] - objectives_sorted[j-1, i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i + 1, j - 1)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k - i)\n    new_solution[i:j] = rotated_segment\n\n    # Apply edge relocation if beneficial\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.768342549023797,
            7.581919977000959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Calculate crowding distances\n    objectives = np.array([obj for _, obj in archive])\n    sorted_indices = np.argsort(objectives[:, 0])\n    objectives_sorted = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):\n        sorted_indices = np.argsort(objectives[:, i])\n        objectives_sorted = objectives[sorted_indices]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (objectives_sorted[j+1, i] - objectives_sorted[j-1, i])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i + 1, j - 1)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k - i)\n    new_solution[i:j] = rotated_segment\n\n    # Apply edge relocation if beneficial\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This novel algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment insertion and edge rotation operations to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distance to prioritize diverse solutions\n    objectives = np.array([obj for _, obj in archive])\n    n_obj = objectives.shape[1]\n\n    # Normalize objectives for crowding distance calculation\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(n_obj):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and edge rotation\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1].copy()\n\n    # Step 2: Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 4: Apply edge rotation if beneficial\n    if len(new_solution) >= 4:\n        l = random.randint(0, len(new_solution) - 4)\n        # Rotate edges (a-b-c-d) to (a-c-b-d)\n        a, b, c, d = new_solution[l], new_solution[l+1], new_solution[l+2], new_solution[l+3]\n\n        current_cost1 = distance_matrix_1[a,b] + distance_matrix_1[b,c] + distance_matrix_1[c,d]\n        new_cost1 = distance_matrix_1[a,c] + distance_matrix_1[c,b] + distance_matrix_1[b,d]\n\n        current_cost2 = distance_matrix_2[a,b] + distance_matrix_2[b,c] + distance_matrix_2[c,d]\n        new_cost2 = distance_matrix_2[a,c] + distance_matrix_2[c,b] + distance_matrix_2[b,d]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[l+1], new_solution[l+2] = new_solution[l+2], new_solution[l+1]\n\n    return new_solution\n\n",
        "score": [
            9.443992657920198,
            9.928817435590048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distance to prioritize diverse solutions\n    objectives = np.array([obj for _, obj in archive])\n    n_obj = objectives.shape[1]\n\n    # Normalize objectives for crowding distance calculation\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-10)\n\n    # Calculate crowding distance\n    crowding = np.zeros(len(archive))\n    for m in range(n_obj):\n        sorted_idx = np.argsort(normalized[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (normalized[sorted_idx[i+1], m] - normalized[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance (most diverse)\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and edge rotation\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1].copy()\n\n    # Step 2: Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    k = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 4: Apply edge rotation if beneficial\n    if len(new_solution) >= 4:\n        l = random.randint(0, len(new_solution) - 4)\n        # Rotate edges (a-b-c-d) to (a-c-b-d)\n        a, b, c, d = new_solution[l], new_solution[l+1], new_solution[l+2], new_solution[l+3]\n\n        current_cost1 = distance_matrix_1[a,b] + distance_matrix_1[b,c] + distance_matrix_1[c,d]\n        new_cost1 = distance_matrix_1[a,c] + distance_matrix_1[c,b] + distance_matrix_1[b,d]\n\n        current_cost2 = distance_matrix_2[a,b] + distance_matrix_2[b,c] + distance_matrix_2[c,d]\n        new_cost2 = distance_matrix_2[a,c] + distance_matrix_2[c,b] + distance_matrix_2[b,d]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[l+1], new_solution[l+2] = new_solution[l+2], new_solution[l+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    while l == k or l == k + 1 or l == k - 1:\n        l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Insert edge (k, l) by swapping positions\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.152365139321217,
            7.013636031961424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        diversity_scores = [abs(obj[0] - obj[1]) for obj in objectives]\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    while l == k or l == k + 1 or l == k - 1:\n        l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Insert edge (k, l) by swapping positions\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of objective values and topological features, then applies a sequence of edge insertions and segment rotations to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    new_solution[i:j] = rotated_segment\n\n    # Apply edge insertion\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n    c = random.randint(0, n - 1)\n    while c == a or c == b:\n        c = random.randint(0, n - 1)\n\n    if random.random() < 0.5:\n        new_solution = np.insert(new_solution, c, new_solution[b])\n        new_solution = np.delete(new_solution, b + 1 if b > c else b)\n    else:\n        new_solution = np.insert(new_solution, c, new_solution[a])\n        new_solution = np.delete(new_solution, a + 1 if a > c else a)\n\n    return new_solution\n\n",
        "score": [
            10.465195362991244,
            10.627121232756998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    new_solution[i:j] = rotated_segment\n\n    # Apply edge insertion\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n    c = random.randint(0, n - 1)\n    while c == a or c == b:\n        c = random.randint(0, n - 1)\n\n    if random.random() < 0.5:\n        new_solution = np.insert(new_solution, c, new_solution[b])\n        new_solution = np.delete(new_solution, b + 1 if b > c else b)\n    else:\n        new_solution = np.insert(new_solution, c, new_solution[a])\n        new_solution = np.delete(new_solution, a + 1 if a > c else a)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid local search operator that combines segment insertion, edge crossover, and adaptive perturbation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Calculate diversity as sum of normalized differences\n        normalized = np.array(objectives)\n        normalized = (normalized - normalized.min(axis=0)) / (normalized.max(axis=0) - normalized.min(axis=0) + 1e-8)\n        diversity = normalized.std(axis=0).sum()\n        candidates = [i for i in range(len(archive)) if np.linalg.norm(normalized[i] - normalized.mean(axis=0)) > diversity * 0.5]\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Segment insertion with adaptive length\n    seg_length = min(3, max(1, n // 4))\n    i = random.randint(0, n - seg_length - 2)\n    j = random.randint(i + seg_length, n - 1)\n    segment = new_solution[i:i+seg_length]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+seg_length:j], segment, new_solution[j:]])\n\n    # Step 2: Edge crossover between two random positions\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply edge crossover if beneficial for both objectives\n    if (new_cost1 < current_cost1 * 0.95) and (new_cost2 < current_cost2 * 0.95):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 3: Adaptive perturbation\n    if random.random() < 0.3:\n        m = random.randint(0, n - 2)\n        new_solution[m], new_solution[m+1] = new_solution[m+1], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            7.893642830548361,
            6.90636791878722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest diversity in objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Calculate diversity as sum of normalized differences\n        normalized = np.array(objectives)\n        normalized = (normalized - normalized.min(axis=0)) / (normalized.max(axis=0) - normalized.min(axis=0) + 1e-8)\n        diversity = normalized.std(axis=0).sum()\n        candidates = [i for i in range(len(archive)) if np.linalg.norm(normalized[i] - normalized.mean(axis=0)) > diversity * 0.5]\n        if candidates:\n            selected_idx = random.choice(candidates)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Segment insertion with adaptive length\n    seg_length = min(3, max(1, n // 4))\n    i = random.randint(0, n - seg_length - 2)\n    j = random.randint(i + seg_length, n - 1)\n    segment = new_solution[i:i+seg_length]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+seg_length:j], segment, new_solution[j:]])\n\n    # Step 2: Edge crossover between two random positions\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply edge crossover if beneficial for both objectives\n    if (new_cost1 < current_cost1 * 0.95) and (new_cost2 < current_cost2 * 0.95):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 3: Adaptive perturbation\n    if random.random() < 0.3:\n        m = random.randint(0, n - 2)\n        new_solution[m], new_solution[m+1] = new_solution[m+1], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_diversity = -1\n    for sol, obj in archive:\n        diversity = abs(obj[0] - obj[1])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.805796670402092,
            8.873868813403675
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_diversity = -1\n    for sol, obj in archive:\n        diversity = abs(obj[0] - obj[1])\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{A new algorithm that selects solutions based on a weighted combination of Pareto dominance and objective diversity, then applies a combination of segment reversal and edge insertion operations to generate neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate Pareto dominance score (simplified)\n        dominated = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        # Calculate diversity score (simplified)\n        diversity = (obj[0] - obj[1])**2\n        scores.append(dominated * 0.7 + diversity * 0.3)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Insert a random edge from elsewhere in the tour\n    if n > 4:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l and abs(k - l) > 1:\n            # Insert edge (k,l) after position m\n            m = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, m, new_solution[l])\n            # Ensure no duplicates\n            new_solution = np.unique(new_solution, return_index=False)\n\n    return new_solution\n\n",
        "score": [
            10.507415846177839,
            10.480440322170633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate Pareto dominance score (simplified)\n        dominated = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        # Calculate diversity score (simplified)\n        diversity = (obj[0] - obj[1])**2\n        scores.append(dominated * 0.7 + diversity * 0.3)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Insert a random edge from elsewhere in the tour\n    if n > 4:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l and abs(k - l) > 1:\n            # Insert edge (k,l) after position m\n            m = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, m, new_solution[l])\n            # Ensure no duplicates\n            new_solution = np.unique(new_solution, return_index=False)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This novel local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: prioritize solutions with better objective values)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Reverse a random edge if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k+1], new_solution[(k+2)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k], new_solution[(k+2)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k+1], new_solution[(k+2)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k], new_solution[(k+2)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.972709292283635,
            7.130045950672671
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: prioritize solutions with better objective values)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Reverse a random edge if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k+1], new_solution[(k+2)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k], new_solution[(k+2)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k+1], new_solution[(k+2)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k], new_solution[(k+2)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive by prioritizing those with high objective variance, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = variances.index(max(variances)) if variances else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate segment by random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node elsewhere if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            node = new_solution[l]\n            new_solution = np.delete(new_solution, l)\n            insert_pos = k if k < len(new_solution) else len(new_solution)-1\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.485966688316514,
            6.201425627196084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    variances = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = variances.index(max(variances)) if variances else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate segment by random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node elsewhere if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            node = new_solution[l]\n            new_solution = np.delete(new_solution, l)\n            insert_pos = k if k < len(new_solution) else len(new_solution)-1\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The new algorithm selects a solution from the archive based on a hybrid of Pareto dominance and objective diversity, then applies a combination of segment rotation and cross-exchange operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(objectives, axis=1) * np.random.random(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Step 2: Cross-exchange between two random positions\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply cross-exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.967448657402297,
            8.30921359421743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.sum(objectives, axis=1) * np.random.random(len(archive)))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Step 2: Cross-exchange between two random positions\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply cross-exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on crowding distance and applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge insertion\n    if n > 4:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            new_solution = np.insert(new_solution, k, new_solution[l])\n            new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    return new_solution\n\n",
        "score": [
            7.11506511677268,
            7.389923459314795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, i])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge insertion\n    if n > 4:\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k != l:\n            new_solution = np.insert(new_solution, k, new_solution[l])\n            new_solution = np.delete(new_solution, l + (1 if l > k else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Apply a conditional edge swap based on both objectives\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.4893025621465705,
            6.973172768553319
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotate_amount = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Apply a conditional edge swap based on both objectives\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n       (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two positions for edge exchange\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply edge exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 4: Randomly select a segment and rotate it\n    if n > 3:\n        segment_start = random.randint(0, n - 3)\n        segment_length = random.randint(2, min(4, n - segment_start - 1))\n        segment = new_solution[segment_start:segment_start+segment_length]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            6.849382312706581,
            6.72793856155536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two positions for edge exchange\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply edge exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 4: Randomly select a segment and rotate it\n    if n > 3:\n        segment_start = random.randint(0, n - 3)\n        segment_length = random.randint(2, min(4, n - segment_start - 1))\n        segment = new_solution[segment_start:segment_start+segment_length]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[segment_start:segment_start+segment_length] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{The new algorithm will prioritize solutions with high Pareto dominance or diverse objective values, then apply a combination of segment insertion and edge reallocation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate Pareto dominance and diversity\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    # Normalize objectives\n    norm_objectives = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n\n    # Select the solution with maximum sum of normalized objectives (diverse)\n    selected_idx = max(range(len(norm_objectives)), key=lambda i: norm_objectives[i][0] + norm_objectives[i][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n\n    # Step 2: Remove the segment and insert it at a new position\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Reallocate edges to improve both objectives\n    for _ in range(2):  # Perform limited reallocations\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            10.470685548590097,
            10.350839927336384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate Pareto dominance and diversity\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives)\n    max_obj2 = max(obj[1] for obj in objectives)\n\n    # Normalize objectives\n    norm_objectives = [(obj[0]/max_obj1, obj[1]/max_obj2) for obj in objectives]\n\n    # Select the solution with maximum sum of normalized objectives (diverse)\n    selected_idx = max(range(len(norm_objectives)), key=lambda i: norm_objectives[i][0] + norm_objectives[i][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n\n    # Step 2: Remove the segment and insert it at a new position\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Reallocate edges to improve both objectives\n    for _ in range(2):  # Perform limited reallocations\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{This algorithm selects a solution from the archive with high objective diversity, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility through careful node tracking and swap validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find the solution with the most extreme objective values\n        max_diff_idx = np.argmax([abs(obj[0] - obj[1]) for obj in objectives])\n        selected_idx = max_diff_idx\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and insert it elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment from its current position\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.209419951366483,
            7.541864399509921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high objective diversity\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find the solution with the most extreme objective values\n        max_diff_idx = np.argmax([abs(obj[0] - obj[1]) for obj in objectives])\n        selected_idx = max_diff_idx\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and insert it elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Remove the segment from its current position\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 2: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a sequence of edge relinking and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -x[1][0], -x[1][1]))\n        selected_idx = random.choice([0, len(archive_sorted) - 1])\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Perform edge relinking with a random solution from archive\n    if len(archive) > 1:\n        ref_solution = archive[random.randint(0, len(archive) - 1)][0]\n        for k in range(n):\n            if new_solution[k] != ref_solution[k]:\n                l = np.where(new_solution == ref_solution[k])[0][0]\n                if l != k:\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            9.044139893126045,
            9.319655039159926
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -x[1][0], -x[1][1]))\n        selected_idx = random.choice([0, len(archive_sorted) - 1])\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Perform edge relinking with a random solution from archive\n    if len(archive) > 1:\n        ref_solution = archive[random.randint(0, len(archive) - 1)][0]\n        for k in range(n):\n            if new_solution[k] != ref_solution[k]:\n                l = np.where(new_solution == ref_solution[k])[0][0]\n                if l != k:\n                    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on crowding distance to maintain diversity, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_idx = np.argsort(objectives[:, 0])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = objectives[sorted_idx[i+1], 0] - objectives[sorted_idx[i-1], 0]\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Remove segment and insert it in a different position\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.166295141496324,
            6.572030215391475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        sorted_idx = np.argsort(objectives[:, 0])\n        crowding = np.zeros(len(archive))\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] = objectives[sorted_idx[i+1], 0] - objectives[sorted_idx[i-1], 0]\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Remove segment and insert it in a different position\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Reverse a random segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations, while also incorporating a probabilistic selection of nodes based on their relative distances in both objective spaces to generate a neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values (simplified diversity measure)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply hybrid local search with probabilistic node selection\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Calculate relative distances for probabilistic selection\n    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n    total_dist = dist1 + dist2\n    if total_dist == 0:\n        total_dist = 1\n\n    # Probabilistic selection based on relative distances\n    if random.random() < (dist1 / total_dist):\n        # Reverse segment between i and j\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap nodes i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.3666505054818066,
            6.3031815805790625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values (simplified diversity measure)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply hybrid local search with probabilistic node selection\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Calculate relative distances for probabilistic selection\n    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n    total_dist = dist1 + dist2\n    if total_dist == 0:\n        total_dist = 1\n\n    # Probabilistic selection based on relative distances\n    if random.random() < (dist1 / total_dist):\n        # Reverse segment between i and j\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap nodes i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.696161357045368,
            6.840854273548436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj = []\n    for obj in objectives:\n        norm1 = obj[0] / np.max([o[0] for o in objectives]) if np.max([o[0] for o in objectives]) != 0 else 0\n        norm2 = obj[1] / np.max([o[1] for o in objectives]) if np.max([o[1] for o in objectives]) != 0 else 0\n        normalized_obj.append((norm1 + norm2) / 2)\n\n    selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three non-adjacent segments\n    i = random.randint(0, n - 6)\n    j = random.randint(i + 2, n - 4)\n    k = random.randint(j + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[j+1:k]\n    new_solution[j+1:k] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            10.469147926409292,
            10.616015849334513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj = []\n    for obj in objectives:\n        norm1 = obj[0] / np.max([o[0] for o in objectives]) if np.max([o[0] for o in objectives]) != 0 else 0\n        norm2 = obj[1] / np.max([o[1] for o in objectives]) if np.max([o[1] for o in objectives]) != 0 else 0\n        normalized_obj.append((norm1 + norm2) / 2)\n\n    selected_idx = np.argmax(normalized_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three non-adjacent segments\n    i = random.randint(0, n - 6)\n    j = random.randint(i + 2, n - 4)\n    k = random.randint(j + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[j+1:k]\n    new_solution[j+1:k] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Step 2: Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert an edge from a different part of the tour\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l and k != l - 1 and k != l + 1:\n        # Insert the edge (k, l) into the tour\n        new_solution = np.concatenate([new_solution[:k], [new_solution[l]], new_solution[k:l], [new_solution[k]], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            8.253850181737509,
            7.620895304777806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Step 2: Rotate the segment by a random amount\n    rotate_amount = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert an edge from a different part of the tour\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l and k != l - 1 and k != l + 1:\n        # Insert the edge (k, l) into the tour\n        new_solution = np.concatenate([new_solution[:k], [new_solution[l]], new_solution[k:l], [new_solution[k]], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive based on both objective diversity and dominance, then applies a combination of segment rotation and edge swapping with a novel acceptance criterion that balances improvement in both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity and dominance scores\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum(np.std(objectives, axis=0))\n\n        # Select solution with highest diversity or random if all equal\n        if np.all(objectives == objectives[0]):\n            selected_idx = random.randint(0, len(archive) - 1)\n        else:\n            diversity_scores = np.sum(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n            selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    k = random.randint(1, n - 3)\n    segment_length = random.randint(2, min(5, n - k - 1))\n    segment = new_solution[k:k+segment_length]\n    rotated = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[k:k+segment_length] = rotated\n\n    # Apply edge swap with novel acceptance criterion\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Novel acceptance criterion: accept if at least one objective improves\n    # or if both objectives don't worsen significantly\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or \\\n       (new_cost1 <= 1.05 * current_cost1 and new_cost2 <= 1.05 * current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            6.839374583728274,
            8.376767394277964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity and dominance scores\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum(np.std(objectives, axis=0))\n\n        # Select solution with highest diversity or random if all equal\n        if np.all(objectives == objectives[0]):\n            selected_idx = random.randint(0, len(archive) - 1)\n        else:\n            diversity_scores = np.sum(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n            selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    k = random.randint(1, n - 3)\n    segment_length = random.randint(2, min(5, n - k - 1))\n    segment = new_solution[k:k+segment_length]\n    rotated = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[k:k+segment_length] = rotated\n\n    # Apply edge swap with novel acceptance criterion\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Novel acceptance criterion: accept if at least one objective improves\n    # or if both objectives don't worsen significantly\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or \\\n       (new_cost1 <= 1.05 * current_cost1 and new_cost2 <= 1.05 * current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    # Step 2: Rotate the segment to create a new order\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Step 3: Insert a random node at a random position\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Step 4: Apply a conditional edge swap if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            9.947448726067941,
            9.985262821268567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    # Step 2: Rotate the segment to create a new order\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Step 3: Insert a random node at a random position\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Step 4: Apply a conditional edge swap if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This novel algorithm selects a solution from the archive with high Pareto dominance, then applies a combination of node insertion and segment rotation to generate a neighbor solution while ensuring feasibility, leveraging both objective-specific distance matrices to guide the search.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj1 = [obj[0] / max(o[0] for o in objectives) for obj in objectives]\n    normalized_obj2 = [obj[1] / max(o[1] for o in objectives) for obj in objectives]\n    scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(objectives))]\n    selected_idx = scores.index(min(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(5, n - start - 1))\n    segment = new_solution[start:start+length]\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+length] = rotated_segment\n\n    # Step 3: Randomly insert a node from elsewhere in the tour\n    if n > 4:\n        node_to_insert = random.choice([node for node in base_solution if node not in segment])\n        insert_pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        if len(new_solution) > n:\n            new_solution = np.delete(new_solution, -1)\n\n    # Step 4: Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [node for node in base_solution if node not in unique_nodes]\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution[:n]\n\n",
        "score": [
            7.6439581275257575,
            7.221090920569228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_obj1 = [obj[0] / max(o[0] for o in objectives) for obj in objectives]\n    normalized_obj2 = [obj[1] / max(o[1] for o in objectives) for obj in objectives]\n    scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(objectives))]\n    selected_idx = scores.index(min(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    start = random.randint(0, n - 3)\n    length = random.randint(2, min(5, n - start - 1))\n    segment = new_solution[start:start+length]\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+length] = rotated_segment\n\n    # Step 3: Randomly insert a node from elsewhere in the tour\n    if n > 4:\n        node_to_insert = random.choice([node for node in base_solution if node not in segment])\n        insert_pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        if len(new_solution) > n:\n            new_solution = np.delete(new_solution, -1)\n\n    # Step 4: Ensure feasibility by checking for duplicates and missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [node for node in base_solution if node not in unique_nodes]\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution[:n]\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{A novel hybrid local search algorithm that selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange, segment reversal, and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.248170204371538,
            6.553842646804677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(2, len(archive)-1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Rotate segment left by one position\n    segment = new_solution[i+1:j+1]\n    rotated_segment = np.roll(segment, -1)\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n-1)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.485855516294042,
            6.461787839472614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: lower sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(2, len(archive)-1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Rotate segment left by one position\n    segment = new_solution[i+1:j+1]\n    rotated_segment = np.roll(segment, -1)\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n-1)\n    if k != i and k != j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Calculate current and potential costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n    # Step 4: Evaluate insertion benefits\n    for pos in range(1, n):\n        for node_pos in range(n):\n            if node_pos == pos or node_pos == pos - 1:\n                continue\n            temp_solution = new_solution.copy()\n            node = temp_solution[node_pos]\n            temp_solution = np.delete(temp_solution, node_pos)\n            temp_solution = np.insert(temp_solution, pos, node)\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n               (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                return temp_solution\n\n    return new_solution\n\n",
        "score": [
            6.7463358672293685,
            6.429757561031186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Calculate current and potential costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n))\n\n    # Step 4: Evaluate insertion benefits\n    for pos in range(1, n):\n        for node_pos in range(n):\n            if node_pos == pos or node_pos == pos - 1:\n                continue\n            temp_solution = new_solution.copy()\n            node = temp_solution[node_pos]\n            temp_solution = np.delete(temp_solution, node_pos)\n            temp_solution = np.insert(temp_solution, pos, node)\n            new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n               (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                return temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values to find diverse solutions\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        selected_idx = random.choice([0, len(sorted_archive) // 2, -1])  # Select from extremes or middle\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with a probability based on segment length\n    if random.random() < 0.7:  # Higher probability for longer segments\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective or if the improvement is significant\n    if (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.055461669213292,
            6.172947304874084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values to find diverse solutions\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        selected_idx = random.choice([0, len(sorted_archive) // 2, -1])  # Select from extremes or middle\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with a probability based on segment length\n    if random.random() < 0.7:  # Higher probability for longer segments\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective or if the improvement is significant\n    if (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high crowding distance in the Pareto front, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest crowding distance (diverse solutions)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Rotate segment\n    segment = new_solution[i+1:j+1]\n    rotated = np.roll(segment, 1)\n    new_solution[i+1:j+1] = rotated\n\n    # Edge insertion\n    k = random.randint(0, n-2)\n    l = random.randint(0, n-1)\n    if k != l and k != (l-1) % n and k != (l+1) % n:\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert node k after node l\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, (l+1)%n, node)\n\n    return new_solution\n\n",
        "score": [
            8.64413757662644,
            8.377259649990528
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest crowding distance (diverse solutions)\n    objectives = np.array([obj for _, obj in archive])\n    crowding_dist = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n\n    selected_idx = np.argmax(crowding_dist)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Rotate segment\n    segment = new_solution[i+1:j+1]\n    rotated = np.roll(segment, 1)\n    new_solution[i+1:j+1] = rotated\n\n    # Edge insertion\n    k = random.randint(0, n-2)\n    l = random.randint(0, n-1)\n    if k != l and k != (l-1) % n and k != (l+1) % n:\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Insert node k after node l\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, (l+1)%n, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on crowding distance in the objective space, then applies a combination of segment insertion and edge swapping operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([], dtype=int)\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For both objectives\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while abs(a - b) < 2:\n        b = random.randint(0, n-1)\n\n    a, b = min(a, b), max(a, b)\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Apply edge swapping if beneficial\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.20758160098088,
            9.595221113297187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([], dtype=int)\n\n    # Calculate crowding distance for each solution\n    objectives = np.array([obj for _, obj in archive])\n    crowding = np.zeros(len(archive))\n\n    for m in range(2):  # For both objectives\n        sorted_idx = np.argsort(objectives[:, m])\n        crowding[sorted_idx[0]] = np.inf\n        crowding[sorted_idx[-1]] = np.inf\n\n        for i in range(1, len(archive)-1):\n            crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while abs(a - b) < 2:\n        b = random.randint(0, n-1)\n\n    a, b = min(a, b), max(a, b)\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Apply edge swapping if beneficial\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Normalize objectives\n        norm_obj1 = obj1 / np.max([o[0] for _, o in archive]) if any([o[0] for _, o in archive]) else 0\n        norm_obj2 = obj2 / np.max([o[1] for _, o in archive]) if any([o[1] for _, o in archive]) else 0\n        # Calculate diversity score (distance from centroid)\n        centroid = np.mean([o for _, o in archive], axis=0)\n        diversity = np.sqrt((norm_obj1 - centroid[0])**2 + (norm_obj2 - centroid[1])**2)\n        scores.append(norm_obj1 * 0.6 + norm_obj2 * 0.4 + diversity * 0.2)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 2: Randomly insert a node from elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    return new_solution\n\n",
        "score": [
            10.499570764411942,
            10.569057700091768
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Normalize objectives\n        norm_obj1 = obj1 / np.max([o[0] for _, o in archive]) if any([o[0] for _, o in archive]) else 0\n        norm_obj2 = obj2 / np.max([o[1] for _, o in archive]) if any([o[1] for _, o in archive]) else 0\n        # Calculate diversity score (distance from centroid)\n        centroid = np.mean([o for _, o in archive], axis=0)\n        diversity = np.sqrt((norm_obj1 - centroid[0])**2 + (norm_obj2 - centroid[1])**2)\n        scores.append(norm_obj1 * 0.6 + norm_obj2 * 0.4 + diversity * 0.2)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 2: Randomly insert a node from elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:l], [node], new_solution[l:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive using a combination of crowding distance and Pareto dominance to prioritize solutions, then applies a segment relocation operation that considers both objectives to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        if i == 0:\n            crowding = float('inf')\n        else:\n            left_obj = archive[i-1][1]\n            right_obj = archive[(i+1)%len(archive)][1]\n            crowding = abs(obj[0] - left_obj[0]) + abs(obj[1] - left_obj[1]) + abs(obj[0] - right_obj[0]) + abs(obj[1] - right_obj[1])\n\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment relocation operation considering both objectives\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n    # Apply relocation if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            9.275356978828835,
            8.328911238641684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or Pareto dominance\n    selected_idx = 0\n    max_crowding = -1\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        if i == 0:\n            crowding = float('inf')\n        else:\n            left_obj = archive[i-1][1]\n            right_obj = archive[(i+1)%len(archive)][1]\n            crowding = abs(obj[0] - left_obj[0]) + abs(obj[1] - left_obj[1]) + abs(obj[0] - right_obj[0]) + abs(obj[1] - right_obj[1])\n\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment relocation operation considering both objectives\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n    # Apply relocation if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its diversity in objective values, then applies a combination of edge insertion, segment rotation, and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with diverse objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotate_by = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.roll(segment, rotate_by)\n\n    # Step 2: Insert a node into a new position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        l = min(l, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Relocate a node if beneficial\n    m = random.randint(0, n - 1)\n    p = random.randint(0, n - 1)\n    if m != p:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n        p = min(p, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, p, node)\n\n    return new_solution\n\n",
        "score": [
            7.381901575203582,
            7.348577478605838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with diverse objective values\n    objectives = np.array([obj for (sol, obj) in archive])\n    selected_idx = np.argmax(np.std(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotate_by = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.roll(segment, rotate_by)\n\n    # Step 2: Insert a node into a new position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        l = min(l, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Relocate a node if beneficial\n    m = random.randint(0, n - 1)\n    p = random.randint(0, n - 1)\n    if m != p:\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n        p = min(p, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, p, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] + archive[i][1][1]) * random.random())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n\n    # Step 2: Rotate the selected segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length - 1))\n    new_solution[start_idx:start_idx + segment_length] = rotated_segment\n\n    # Step 3: Randomly apply a crossover-like operation with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find a common subsequence and preserve it\n        subsequence = []\n        for i in range(n):\n            if new_solution[i] in other_solution:\n                subsequence.append(new_solution[i])\n\n        if len(subsequence) > 1:\n            # Preserve the subsequence in order\n            new_solution = np.array(subsequence + [node for node in base_solution if node not in subsequence])\n\n    return new_solution\n\n",
        "score": [
            9.086877512670894,
            8.982653155373283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] + archive[i][1][1]) * random.random())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    segment_length = random.randint(2, min(5, n // 2))\n    start_idx = random.randint(0, n - segment_length)\n\n    # Step 2: Rotate the selected segment\n    segment = new_solution[start_idx:start_idx + segment_length]\n    rotated_segment = np.roll(segment, random.randint(1, segment_length - 1))\n    new_solution[start_idx:start_idx + segment_length] = rotated_segment\n\n    # Step 3: Randomly apply a crossover-like operation with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find a common subsequence and preserve it\n        subsequence = []\n        for i in range(n):\n            if new_solution[i] in other_solution:\n                subsequence.append(new_solution[i])\n\n        if len(subsequence) > 1:\n            # Preserve the subsequence in order\n            new_solution = np.array(subsequence + [node for node in base_solution if node not in subsequence])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on crowding distance to ensure diversity, then applies a combination of segment rotation and edge insertion to generate a neighbor solution while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(objectives))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(objectives)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Rotate a random segment\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.concatenate((segment[rotation:], segment[:rotation]))\n\n    # Step 2: Insert a random edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.605276722299575,
            8.042540724449779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(objectives))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(objectives)-1):\n                crowding[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Rotate a random segment\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.concatenate((segment[rotation:], segment[:rotation]))\n\n    # Step 2: Insert a random edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment inversion and edge rotation operations to generate a neighbor solution, while ensuring feasibility through careful node repositioning.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy() if archive else np.array([])\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for obj in objectives:\n        diversity = abs(obj[0] - obj[1])\n        diversity_scores.append(diversity)\n\n    if not diversity_scores:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to invert\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Rotate a segment of nodes\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n    segment = new_solution[k:l+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[k:l+1] = np.roll(segment, rotation)\n\n    # Step 3: Verify feasibility\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    # Step 4: Check for improvement\n    old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or (random.random() < 0.1):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            8.298794614175264,
            8.822562838973676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy() if archive else np.array([])\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for obj in objectives:\n        diversity = abs(obj[0] - obj[1])\n        diversity_scores.append(diversity)\n\n    if not diversity_scores:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to invert\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Rotate a segment of nodes\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n    segment = new_solution[k:l+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[k:l+1] = np.roll(segment, rotation)\n\n    # Step 3: Verify feasibility\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    # Step 4: Check for improvement\n    old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))\n\n    if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) or (random.random() < 0.1):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    k = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n    # Step 2: Randomly insert an edge if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(0, n - 1)\n    while b == a or b == a + 1 or b == a - 1:\n        b = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n",
        "score": [
            6.685986222827893,
            6.777641525721403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    k = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.concatenate([segment[k:], segment[:k]])\n\n    # Step 2: Randomly insert an edge if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(0, n - 1)\n    while b == a or b == a + 1 or b == a - 1:\n        b = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[a+1], new_solution[(b+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a hybrid local search combining segment reversal and edge exchange with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominance = sum(1 for _, o in archive if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        diversity = max(abs(obj[0] - o[0]) + abs(obj[1] - o[1]) for _, o in archive)\n        scores.append(0.7 * dominance + 0.3 * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    for _ in range(2):\n        # Segment reversal with probabilistic acceptance\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            if random.random() > 0.5:  # 50% chance to accept\n                break\n\n    # Edge exchange with cost improvement check\n    for _ in range(2):\n        a, b, c, d = random.sample(range(n), 4)\n        if {a, b, c, d} == {0, 1, 2, 3}:  # Ensure all distinct\n            old_cost = (distance_matrix_1[base_solution[a], base_solution[b]] +\n                        distance_matrix_1[base_solution[c], base_solution[d]])\n            new_cost = (distance_matrix_1[base_solution[a], base_solution[d]] +\n                        distance_matrix_1[base_solution[c], base_solution[b]])\n            if new_cost < old_cost:\n                new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            10.493195295980367,
            10.601873135119698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominance = sum(1 for _, o in archive if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        diversity = max(abs(obj[0] - o[0]) + abs(obj[1] - o[1]) for _, o in archive)\n        scores.append(0.7 * dominance + 0.3 * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search\n    for _ in range(2):\n        # Segment reversal with probabilistic acceptance\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            if random.random() > 0.5:  # 50% chance to accept\n                break\n\n    # Edge exchange with cost improvement check\n    for _ in range(2):\n        a, b, c, d = random.sample(range(n), 4)\n        if {a, b, c, d} == {0, 1, 2, 3}:  # Ensure all distinct\n            old_cost = (distance_matrix_1[base_solution[a], base_solution[b]] +\n                        distance_matrix_1[base_solution[c], base_solution[d]])\n            new_cost = (distance_matrix_1[base_solution[a], base_solution[d]] +\n                        distance_matrix_1[base_solution[c], base_solution[b]])\n            if new_cost < old_cost:\n                new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a novel segment relocation and edge crossover operator to generate a neighbor solution while ensuring feasibility through a validity check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Pareto dominance count\n        dom_count = sum(1 for s, o in archive if o[0] < obj[0] and o[1] < obj[1])\n        # Objective diversity\n        diversity = np.std([o[0] for _, o in archive]) + np.std([o[1] for _, o in archive])\n        scores.append(dom_count + diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and relocate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Find optimal insertion point for segment\n    min_cost = float('inf')\n    best_pos = i\n    for pos in range(0, n):\n        if pos >= i and pos <= j:\n            continue\n        # Try inserting at position pos\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(temp_sol) != n:\n            continue\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(1, n))\n        cost2 = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(1, n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    new_solution = new_solution[:n]\n\n    # Step 3: Apply edge crossover with another random segment\n    k = random.randint(0, n - 4)\n    l = random.randint(k + 2, n - 2)\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[k:l+1]\n\n    # Create a new solution by combining segments\n    temp_sol = np.concatenate([segment1, segment2])\n    temp_sol = np.unique(temp_sol)\n    if len(temp_sol) == n:\n        new_solution = temp_sol\n    else:\n        # If not complete, fill with remaining nodes\n        remaining = [node for node in base_solution if node not in temp_sol]\n        new_solution = np.concatenate([temp_sol, remaining])\n\n    return new_solution\n\n",
        "score": [
            9.79900625556212,
            10.110527513402944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Pareto dominance count\n        dom_count = sum(1 for s, o in archive if o[0] < obj[0] and o[1] < obj[1])\n        # Objective diversity\n        diversity = np.std([o[0] for _, o in archive]) + np.std([o[1] for _, o in archive])\n        scores.append(dom_count + diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and relocate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Find optimal insertion point for segment\n    min_cost = float('inf')\n    best_pos = i\n    for pos in range(0, n):\n        if pos >= i and pos <= j:\n            continue\n        # Try inserting at position pos\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        if len(temp_sol) != n:\n            continue\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(1, n))\n        cost2 = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(1, n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    new_solution = new_solution[:n]\n\n    # Step 3: Apply edge crossover with another random segment\n    k = random.randint(0, n - 4)\n    l = random.randint(k + 2, n - 2)\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[k:l+1]\n\n    # Create a new solution by combining segments\n    temp_sol = np.concatenate([segment1, segment2])\n    temp_sol = np.unique(temp_sol)\n    if len(temp_sol) == n:\n        new_solution = temp_sol\n    else:\n        # If not complete, fill with remaining nodes\n        remaining = [node for node in base_solution if node not in temp_sol]\n        new_solution = np.concatenate([temp_sol, remaining])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on a weighted combination of objective diversity and Pareto dominance, then applies a hybrid of partial segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection weights based on objective diversity and dominance\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n\n    weights = []\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on distance from mean (diversity) and dominance (better solutions)\n        diversity = np.sqrt((obj[0] - mean_obj1)**2 + (obj[1] - mean_obj2)**2)\n        dominance = sum(1 for o in objectives if (o[0] <= obj[0] and o[1] <= obj[1] and (o[0] < obj[0] or o[1] < obj[1])))\n        weights.append(diversity * (1 + dominance))\n\n    # Select solution with highest weight\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive local search operations\n    operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n    if operation == 'segment_reversal':\n        # Select two random non-adjacent segments\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        k = random.randint(j + 1, n - 1)\n\n        # Reverse the middle segment\n        middle_segment = new_solution[j:k]\n        new_solution[j:k] = middle_segment[::-1]\n\n    else:  # edge_insertion\n        # Select a random edge to remove\n        a = random.randint(0, n - 2)\n        b = a + 1\n\n        # Select a random position to insert it\n        c = random.randint(0, n - 2)\n        while c == a or c == b or c == a - 1 or c == b + 1:\n            c = random.randint(0, n - 2)\n\n        # Remove the edge and insert it at new position\n        edge = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:c], edge, new_solution[c:]])\n\n    return new_solution\n\n",
        "score": [
            10.540730995233277,
            10.62218165804326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate selection weights based on objective diversity and dominance\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = np.mean([obj[0] for obj in objectives])\n    mean_obj2 = np.mean([obj[1] for obj in objectives])\n\n    weights = []\n    for i, (sol, obj) in enumerate(archive):\n        # Weight based on distance from mean (diversity) and dominance (better solutions)\n        diversity = np.sqrt((obj[0] - mean_obj1)**2 + (obj[1] - mean_obj2)**2)\n        dominance = sum(1 for o in objectives if (o[0] <= obj[0] and o[1] <= obj[1] and (o[0] < obj[0] or o[1] < obj[1])))\n        weights.append(diversity * (1 + dominance))\n\n    # Select solution with highest weight\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive local search operations\n    operation = random.choice(['segment_reversal', 'edge_insertion'])\n\n    if operation == 'segment_reversal':\n        # Select two random non-adjacent segments\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        k = random.randint(j + 1, n - 1)\n\n        # Reverse the middle segment\n        middle_segment = new_solution[j:k]\n        new_solution[j:k] = middle_segment[::-1]\n\n    else:  # edge_insertion\n        # Select a random edge to remove\n        a = random.randint(0, n - 2)\n        b = a + 1\n\n        # Select a random position to insert it\n        c = random.randint(0, n - 2)\n        while c == a or c == b or c == a - 1 or c == b + 1:\n            c = random.randint(0, n - 2)\n\n        # Remove the edge and insert it at new position\n        edge = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.concatenate([new_solution[:c], edge, new_solution[c:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.386010331135532,
            10.586138765546014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity, then applies a novel segment-based crossover operation with a random solution from the archive to create a neighbor solution while ensuring feasibility through careful segment merging and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select a solution with diverse objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = sum(o[0] for o in objectives) / len(objectives)\n    mean_obj2 = sum(o[1] for o in objectives) / len(objectives)\n    selected_idx = max(range(len(objectives)), key=lambda i: abs(objectives[i][0] - mean_obj1) + abs(objectives[i][1] - mean_obj2))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Select a random solution for crossover\n    random_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n    random_solution = archive[random_idx][0].copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select a random segment from base solution\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = base_solution[start:end]\n\n    # Step 2: Find the position to insert the segment in random solution\n    new_solution = []\n    used_nodes = set()\n    segment_nodes = set(segment)\n\n    # First add nodes before the segment in random solution\n    for node in random_solution:\n        if node not in segment_nodes:\n            new_solution.append(node)\n            used_nodes.add(node)\n        if len(new_solution) >= start:\n            break\n\n    # Add the segment\n    new_solution.extend(segment)\n    used_nodes.update(segment_nodes)\n\n    # Add remaining nodes from random solution\n    for node in random_solution:\n        if node not in used_nodes:\n            new_solution.append(node)\n            used_nodes.add(node)\n\n    # Add remaining nodes from base solution if needed\n    for node in base_solution:\n        if node not in used_nodes:\n            new_solution.append(node)\n\n    # Ensure it's a valid tour\n    if len(new_solution) != n:\n        # Fallback to base solution if something went wrong\n        return base_solution\n\n    return np.array(new_solution)\n\n",
        "score": [
            7.3262435431916435,
            7.913531348853044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select a solution with diverse objectives\n    objectives = [obj for _, obj in archive]\n    mean_obj1 = sum(o[0] for o in objectives) / len(objectives)\n    mean_obj2 = sum(o[1] for o in objectives) / len(objectives)\n    selected_idx = max(range(len(objectives)), key=lambda i: abs(objectives[i][0] - mean_obj1) + abs(objectives[i][1] - mean_obj2))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Select a random solution for crossover\n    random_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n    random_solution = archive[random_idx][0].copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return base_solution\n\n    # Step 1: Select a random segment from base solution\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = base_solution[start:end]\n\n    # Step 2: Find the position to insert the segment in random solution\n    new_solution = []\n    used_nodes = set()\n    segment_nodes = set(segment)\n\n    # First add nodes before the segment in random solution\n    for node in random_solution:\n        if node not in segment_nodes:\n            new_solution.append(node)\n            used_nodes.add(node)\n        if len(new_solution) >= start:\n            break\n\n    # Add the segment\n    new_solution.extend(segment)\n    used_nodes.update(segment_nodes)\n\n    # Add remaining nodes from random solution\n    for node in random_solution:\n        if node not in used_nodes:\n            new_solution.append(node)\n            used_nodes.add(node)\n\n    # Add remaining nodes from base solution if needed\n    for node in base_solution:\n        if node not in used_nodes:\n            new_solution.append(node)\n\n    # Ensure it's a valid tour\n    if len(new_solution) != n:\n        # Fallback to base solution if something went wrong\n        return base_solution\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{This novel algorithm selects a high-quality solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (distance in objective space)\n        objectives = [obj for _, obj in archive]\n        diversity_scores = []\n        for i in range(len(objectives)):\n            distances = [np.sqrt((objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2)\n                        for j in range(len(objectives)) if j != i]\n            diversity_scores.append(np.mean(distances))\n\n        # Combine dominance and diversity (simple approach)\n        scores = [1/(dominance + 1) + diversity_scores[i] for i, dominance in enumerate(range(len(archive)))]\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation and edge insertion\n    # Step 1: Select a segment to rotate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Step 2: Rotate the segment\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 3: Insert a random edge if beneficial\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a == b:\n        b = (b + 1) % n\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.1284508531356,
            8.697888117397179
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (distance in objective space)\n        objectives = [obj for _, obj in archive]\n        diversity_scores = []\n        for i in range(len(objectives)):\n            distances = [np.sqrt((objectives[i][0] - objectives[j][0])**2 + (objectives[i][1] - objectives[j][1])**2)\n                        for j in range(len(objectives)) if j != i]\n            diversity_scores.append(np.mean(distances))\n\n        # Combine dominance and diversity (simple approach)\n        scores = [1/(dominance + 1) + diversity_scores[i] for i, dominance in enumerate(range(len(archive)))]\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation and edge insertion\n    # Step 1: Select a segment to rotate\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Step 2: Rotate the segment\n    rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 3: Insert a random edge if beneficial\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a == b:\n        b = (b + 1) % n\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This novel local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.10992458195693,
            6.542398445078076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node from another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of Pareto dominance and crowding distance, then applies a hybrid local search combining segment reversal and edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment and reverse it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly insert a node into a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            6.152608655214424,
            6.493812776955636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment and reverse it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly insert a node into a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment reversal and edge exchange operations, followed by a novel node insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_diff = max(abs(o1 - o2) for o1, o2 in objectives)\n    diverse_idx = [i for i, (o1, o2) in enumerate(objectives) if abs(o1 - o2) >= max_diff * 0.8]\n    selected_idx = random.choice(diverse_idx) if diverse_idx else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Apply novel node insertion with probability\n    if random.random() < 0.3:\n        pos = random.randint(0, n - 1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.750468538632223,
            6.0787100767983215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    max_diff = max(abs(o1 - o2) for o1, o2 in objectives)\n    diverse_idx = [i for i, (o1, o2) in enumerate(objectives) if abs(o1 - o2) >= max_diff * 0.8]\n    selected_idx = random.choice(diverse_idx) if diverse_idx else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[j-1:i:-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Apply novel node insertion with probability\n    if random.random() < 0.3:\n        pos = random.randint(0, n - 1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This novel algorithm combines multi-objective selection with a segment-based crossover and edge insertion heuristic, where promising solutions are chosen based on their objective diversity and dominance, then a new tour is constructed by combining segments from multiple solutions while strategically inserting edges to maintain feasibility and potentially improve both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two diverse solutions from the archive\n    candidates = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    sol1 = candidates[0][0]\n    sol2 = candidates[-1][0]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Randomly select a segment from each solution\n    start = random.randint(0, n-2)\n    length = random.randint(2, min(10, n//2))\n    end = min(start + length, n-1)\n\n    segment1 = sol1[start:end]\n    segment2 = sol2[start:end]\n\n    # Initialize with one segment\n    new_solution[:len(segment1)] = segment1\n    remaining_nodes = set(range(n)) - set(segment1)\n\n    # Insert remaining nodes from the other segment\n    for node in segment2:\n        if node not in new_solution:\n            # Find insertion position that minimizes both objectives\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)-1):\n                if new_solution[i] in remaining_nodes or new_solution[i+1] in remaining_nodes:\n                    continue\n\n                cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[i+1]] - distance_matrix_1[new_solution[i], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[i+1]] - distance_matrix_2[new_solution[i], new_solution[i+1]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i+1\n\n            if best_pos != -1:\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Complete the tour with remaining nodes\n    remaining_nodes = list(set(range(n)) - set(new_solution))\n    for node in remaining_nodes:\n        # Find insertion position that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)-1):\n            cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[i+1]] - distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[i+1]] - distance_matrix_2[new_solution[i], new_solution[i+1]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i+1\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            10.478049016299439,
            10.655215315889233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two diverse solutions from the archive\n    candidates = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    sol1 = candidates[0][0]\n    sol2 = candidates[-1][0]\n\n    n = len(sol1)\n    new_solution = np.zeros(n, dtype=int)\n\n    # Randomly select a segment from each solution\n    start = random.randint(0, n-2)\n    length = random.randint(2, min(10, n//2))\n    end = min(start + length, n-1)\n\n    segment1 = sol1[start:end]\n    segment2 = sol2[start:end]\n\n    # Initialize with one segment\n    new_solution[:len(segment1)] = segment1\n    remaining_nodes = set(range(n)) - set(segment1)\n\n    # Insert remaining nodes from the other segment\n    for node in segment2:\n        if node not in new_solution:\n            # Find insertion position that minimizes both objectives\n            best_pos = -1\n            best_cost = float('inf')\n\n            for i in range(len(new_solution)-1):\n                if new_solution[i] in remaining_nodes or new_solution[i+1] in remaining_nodes:\n                    continue\n\n                cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[i+1]] - distance_matrix_1[new_solution[i], new_solution[i+1]]\n                cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[i+1]] - distance_matrix_2[new_solution[i], new_solution[i+1]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i+1\n\n            if best_pos != -1:\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    # Complete the tour with remaining nodes\n    remaining_nodes = list(set(range(n)) - set(new_solution))\n    for node in remaining_nodes:\n        # Find insertion position that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(len(new_solution)-1):\n            cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[i+1]] - distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[i+1]] - distance_matrix_2[new_solution[i], new_solution[i+1]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i+1\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to remove\n    remove_idx = random.randint(1, n - 2)\n    removed_node = new_solution[remove_idx]\n\n    # Step 2: Insert the removed node at a different position\n    insert_pos = random.randint(0, n - 2)\n    if insert_pos >= remove_idx:\n        insert_pos += 1\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n    if insert_pos < remove_idx:\n        new_solution = np.delete(new_solution, remove_idx + 1)\n    else:\n        new_solution = np.delete(new_solution, remove_idx)\n\n    # Step 3: Randomly rotate a segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 4: Evaluate and potentially revert if not beneficial\n    current_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n    for i in range(n - 1):\n        current_cost1 += distance_matrix_1[new_solution[i], new_solution[i+1]]\n        new_cost1 += distance_matrix_1[new_solution[i], new_solution[i+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n    for i in range(n - 1):\n        current_cost2 += distance_matrix_2[new_solution[i], new_solution[i+1]]\n        new_cost2 += distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n    if (new_cost1 > current_cost1 and new_cost2 > current_cost2) or (new_cost1 == current_cost1 and new_cost2 == current_cost2):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            9.106183876581397,
            9.678410496678795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to remove\n    remove_idx = random.randint(1, n - 2)\n    removed_node = new_solution[remove_idx]\n\n    # Step 2: Insert the removed node at a different position\n    insert_pos = random.randint(0, n - 2)\n    if insert_pos >= remove_idx:\n        insert_pos += 1\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n    if insert_pos < remove_idx:\n        new_solution = np.delete(new_solution, remove_idx + 1)\n    else:\n        new_solution = np.delete(new_solution, remove_idx)\n\n    # Step 3: Randomly rotate a segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 4: Evaluate and potentially revert if not beneficial\n    current_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n    for i in range(n - 1):\n        current_cost1 += distance_matrix_1[new_solution[i], new_solution[i+1]]\n        new_cost1 += distance_matrix_1[new_solution[i], new_solution[i+1]]\n\n    current_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n    new_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n    for i in range(n - 1):\n        current_cost2 += distance_matrix_2[new_solution[i], new_solution[i+1]]\n        new_cost2 += distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n    if (new_cost1 > current_cost1 and new_cost2 > current_cost2) or (new_cost1 == current_cost1 and new_cost2 == current_cost2):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Reverse the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.453628781567367,
            6.383075211878392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Reverse the selected segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel algorithm selects a solution from the archive using diversity-aware selection, then applies a combination of node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Diversity-aware selection: choose a solution with unique objective values\n    unique_objectives = set()\n    candidates = []\n    for sol, obj in archive:\n        if obj not in unique_objectives:\n            unique_objectives.add(obj)\n            candidates.append(sol)\n    if len(candidates) == 0:\n        candidates = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(candidates) - 1)\n    base_solution = candidates[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to insert elsewhere\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Step 2: Insert the node at a new random position\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Rotate a random segment\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            7.016418245516424,
            6.856514298233224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Diversity-aware selection: choose a solution with unique objective values\n    unique_objectives = set()\n    candidates = []\n    for sol, obj in archive:\n        if obj not in unique_objectives:\n            unique_objectives.add(obj)\n            candidates.append(sol)\n    if len(candidates) == 0:\n        candidates = [sol for sol, _ in archive]\n    selected_idx = random.randint(0, len(candidates) - 1)\n    base_solution = candidates[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to insert elsewhere\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Step 2: Insert the node at a new random position\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Rotate a random segment\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with high Pareto dominance, then applies a novel combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply node insertion and segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Remove node at position j and insert it after position i+1\n    node = new_solution[j]\n    new_solution = np.concatenate((new_solution[:j], new_solution[j+1:]))\n    new_solution = np.insert(new_solution, i+1, node)\n\n    # Rotate a segment of length 3\n    k = random.randint(0, n - 4)\n    segment = new_solution[k:k+3]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[k:k+3] = rotated_segment\n\n    return new_solution\n\n",
        "score": [
            6.935421366831473,
            6.618725573572608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply node insertion and segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Remove node at position j and insert it after position i+1\n    node = new_solution[j]\n    new_solution = np.concatenate((new_solution[:j], new_solution[j+1:]))\n    new_solution = np.insert(new_solution, i+1, node)\n\n    # Rotate a segment of length 3\n    k = random.randint(0, n - 4)\n    segment = new_solution[k:k+3]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[k:k+3] = rotated_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -abs(x[1][0] - x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Apply edge exchange with objective-aware selection\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.640527831043936,
            6.272921451487142
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -abs(x[1][0] - x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with adaptive length\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length - 1)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Apply edge exchange with objective-aware selection\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high Pareto dominance\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(3, len(sorted_archive) - 1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with probability 0.7\n    if random.random() < 0.7:\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 4: Apply a 2-opt move with probability 0.4\n    if random.random() < 0.4:\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.236062921912867,
            6.899215077283399
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high Pareto dominance\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(3, len(sorted_archive) - 1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with probability 0.7\n    if random.random() < 0.7:\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 4: Apply a 2-opt move with probability 0.4\n    if random.random() < 0.4:\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation, edge insertion, and conditional path reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate crowding distance to prioritize diverse solutions\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Randomly select a node and insert it in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 3: Conditionally reverse a path if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            8.547885696069496,
            7.747850022560914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate crowding distance to prioritize diverse solutions\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Randomly select a node and insert it in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 3: Conditionally reverse a path if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a hybrid of segment insertion and edge exchange operations to generate a neighbor solution while ensuring feasibility through careful selection of insertion points and edge exchanges that preserve tour validity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by normalized objective values\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)  # Simple combined score\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment insertion with edge exchange\n    # Step 1: Randomly select a segment to remove\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(3, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start+seg_length]\n\n    # Step 2: Remove the segment and find insertion point\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Edge exchange to improve objectives\n    for _ in range(2):  # Try multiple exchanges\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Apply exchange if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            10.12950585720401,
            9.811382196123738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Rank solutions by normalized objective values\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized.sum(axis=1)  # Simple combined score\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment insertion with edge exchange\n    # Step 1: Randomly select a segment to remove\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(3, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start+seg_length]\n\n    # Step 2: Remove the segment and find insertion point\n    remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n    insert_pos = random.randint(0, len(remaining) - 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Edge exchange to improve objectives\n    for _ in range(2):  # Try multiple exchanges\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Apply exchange if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This novel algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment relocation and edge crossover operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Perform edge crossover between two random nodes\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply crossover if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.119028939717897,
            6.868304627171734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Perform edge crossover between two random nodes\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply crossover if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel combination of node insertion and segment rotation to generate a neighbor solution, ensuring feasibility through careful validation of node sequences.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to insert elsewhere\n    node_pos = random.randint(1, n-1)\n    node = new_solution[node_pos]\n\n    # Step 2: Remove the node and its immediate neighbors\n    segment = new_solution[node_pos-1:node_pos+2]\n    new_solution = np.concatenate([new_solution[:node_pos-1], new_solution[node_pos+2:]])\n\n    # Step 3: Randomly rotate the removed segment\n    rotated_segment = np.roll(segment, random.randint(1, 2))\n\n    # Step 4: Insert the rotated segment at a new position\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], rotated_segment, new_solution[insert_pos:]])\n\n    # Step 5: Validate the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            9.554270384679263,
            9.782937855743171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to insert elsewhere\n    node_pos = random.randint(1, n-1)\n    node = new_solution[node_pos]\n\n    # Step 2: Remove the node and its immediate neighbors\n    segment = new_solution[node_pos-1:node_pos+2]\n    new_solution = np.concatenate([new_solution[:node_pos-1], new_solution[node_pos+2:]])\n\n    # Step 3: Randomly rotate the removed segment\n    rotated_segment = np.roll(segment, random.randint(1, 2))\n\n    # Step 4: Insert the rotated segment at a new position\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.concatenate([new_solution[:insert_pos], rotated_segment, new_solution[insert_pos:]])\n\n    # Step 5: Validate the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This novel hybrid local search algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a combination of segment rotation and adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Adaptive edge swapping based on objective improvement\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > 0 or improvement2 > 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.644026913062964,
            6.991013699821085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Adaptive edge swapping based on objective improvement\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > 0 or improvement2 > 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on both objective diversity and dominance, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n        selected_solution = archive_sorted[random.randint(0, min(2, len(archive_sorted)-1))][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    segment = new_solution[i:j]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:j] = segment\n\n    # Apply edge insertion if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n    c = random.randint(0, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[b]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[b]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:a], [new_solution[c]], new_solution[a:b], [new_solution[c]], new_solution[b:]])\n\n    return new_solution\n\n",
        "score": [
            8.210078983960914,
            8.385983458030585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity\n        archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n        selected_solution = archive_sorted[random.randint(0, min(2, len(archive_sorted)-1))][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(j + 1, n - 1)\n\n    segment = new_solution[i:j]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:j] = segment\n\n    # Apply edge insertion if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n    c = random.randint(0, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[b]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[c], new_solution[b]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:a], [new_solution[c]], new_solution[a:b], [new_solution[c]], new_solution[b:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = archive[0][1][0] + archive[0][1][1]\n    for i, (_, obj) in enumerate(archive):\n        current_value = obj[0] + obj[1]\n        if current_value < best_value:\n            best_value = current_value\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two non-adjacent nodes if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    return new_solution\n\n",
        "score": [
            6.238273715844993,
            5.9473123728403525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = archive[0][1][0] + archive[0][1][1]\n    for i, (_, obj) in enumerate(archive):\n        current_value = obj[0] + obj[1]\n        if current_value < best_value:\n            best_value = current_value\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two non-adjacent nodes if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and crowding distance, then applies a segment insertion operation followed by a cross-exchange operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance if archive has more than one solution\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion operation\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n    segment = new_solution[i+1:j+1]\n\n    # Find best insertion point\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(0, n):\n        if pos >= i and pos <= j:\n            continue\n\n        # Calculate cost before insertion\n        if pos == 0:\n            before_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n            before_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n        else:\n            before_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            before_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        # Calculate cost after insertion\n        if pos == 0:\n            after_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n            after_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n        else:\n            after_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n            after_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n        improvement1 = before_cost1 - after_cost1\n        improvement2 = before_cost2 - after_cost2\n\n        if (improvement1 > 0 or improvement2 > 0) and (improvement1 + improvement2 > best_improvement):\n            best_pos = pos\n            best_improvement = improvement1 + improvement2\n\n    if best_pos != -1:\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:]])\n        # Insert the segment at best position\n        if best_pos == 0:\n            new_solution = np.concatenate([segment, new_solution])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Apply cross-exchange operation\n    a = random.randint(0, n-4)\n    b = random.randint(a+2, n-2)\n    c = random.randint(0, n-4)\n    d = random.randint(c+2, n-2)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[a], new_solution[a+1]] +\n                     distance_matrix_1[new_solution[b], new_solution[b+1]] +\n                     distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                     distance_matrix_1[new_solution[d], new_solution[d+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[a], new_solution[c+1]] +\n                distance_matrix_1[new_solution[b], new_solution[d+1]] +\n                distance_matrix_1[new_solution[c], new_solution[a+1]] +\n                distance_matrix_1[new_solution[d], new_solution[b+1]])\n\n    current_cost2 = (distance_matrix_2[new_solution[a], new_solution[a+1]] +\n                     distance_matrix_2[new_solution[b], new_solution[b+1]] +\n                     distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                     distance_matrix_2[new_solution[d], new_solution[d+1]])\n\n    new_cost2 = (distance_matrix_2[new_solution[a], new_solution[c+1]] +\n                distance_matrix_2[new_solution[b], new_solution[d+1]] +\n                distance_matrix_2[new_solution[c], new_solution[a+1]] +\n                distance_matrix_2[new_solution[d], new_solution[b+1]])\n\n    # Apply cross-exchange if beneficial\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Create new segments\n        seg1 = new_solution[a+1:b+1]\n        seg2 = new_solution[c+1:d+1]\n\n        # Create new solution\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            seg2,\n            new_solution[b+1:c+1],\n            seg1,\n            new_solution[d+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            7.595490394364238,
            7.724991875838854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance if archive has more than one solution\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Select solution with highest crowding distance\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion operation\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n    segment = new_solution[i+1:j+1]\n\n    # Find best insertion point\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(0, n):\n        if pos >= i and pos <= j:\n            continue\n\n        # Calculate cost before insertion\n        if pos == 0:\n            before_cost1 = distance_matrix_1[new_solution[-1], new_solution[0]]\n            before_cost2 = distance_matrix_2[new_solution[-1], new_solution[0]]\n        else:\n            before_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            before_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n\n        # Calculate cost after insertion\n        if pos == 0:\n            after_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[0]]\n            after_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[0]]\n        else:\n            after_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]]\n            after_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]]\n\n        improvement1 = before_cost1 - after_cost1\n        improvement2 = before_cost2 - after_cost2\n\n        if (improvement1 > 0 or improvement2 > 0) and (improvement1 + improvement2 > best_improvement):\n            best_pos = pos\n            best_improvement = improvement1 + improvement2\n\n    if best_pos != -1:\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[j+1:]])\n        # Insert the segment at best position\n        if best_pos == 0:\n            new_solution = np.concatenate([segment, new_solution])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Apply cross-exchange operation\n    a = random.randint(0, n-4)\n    b = random.randint(a+2, n-2)\n    c = random.randint(0, n-4)\n    d = random.randint(c+2, n-2)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[a], new_solution[a+1]] +\n                     distance_matrix_1[new_solution[b], new_solution[b+1]] +\n                     distance_matrix_1[new_solution[c], new_solution[c+1]] +\n                     distance_matrix_1[new_solution[d], new_solution[d+1]])\n\n    new_cost1 = (distance_matrix_1[new_solution[a], new_solution[c+1]] +\n                distance_matrix_1[new_solution[b], new_solution[d+1]] +\n                distance_matrix_1[new_solution[c], new_solution[a+1]] +\n                distance_matrix_1[new_solution[d], new_solution[b+1]])\n\n    current_cost2 = (distance_matrix_2[new_solution[a], new_solution[a+1]] +\n                     distance_matrix_2[new_solution[b], new_solution[b+1]] +\n                     distance_matrix_2[new_solution[c], new_solution[c+1]] +\n                     distance_matrix_2[new_solution[d], new_solution[d+1]])\n\n    new_cost2 = (distance_matrix_2[new_solution[a], new_solution[c+1]] +\n                distance_matrix_2[new_solution[b], new_solution[d+1]] +\n                distance_matrix_2[new_solution[c], new_solution[a+1]] +\n                distance_matrix_2[new_solution[d], new_solution[b+1]])\n\n    # Apply cross-exchange if beneficial\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Create new segments\n        seg1 = new_solution[a+1:b+1]\n        seg2 = new_solution[c+1:d+1]\n\n        # Create new solution\n        new_solution = np.concatenate([\n            new_solution[:a+1],\n            seg2,\n            new_solution[b+1:c+1],\n            seg1,\n            new_solution[d+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations, followed by a probabilistic swap of non-adjacent edges to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values to prioritize diverse solutions\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Probabilistically swap non-adjacent edges\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        if random.random() < 0.5:  # Probabilistic swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.096357652954098,
            6.4768422708312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values to prioritize diverse solutions\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Probabilistically swap non-adjacent edges\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        if random.random() < 0.5:  # Probabilistic swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{A novel hybrid local search algorithm that combines node insertion with adaptive segment rotation, prioritizing solutions with high objective diversity and selectively applying operations that improve either or both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n-1))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Rotate segment left or right\n    if random.random() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n\n    new_solution[start_pos:start_pos+segment_length] = segment\n\n    # Step 2: Selective node insertion\n    if n > 3:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-1)\n        if insert_pos > node_to_move:\n            insert_pos += 1\n\n        # Calculate cost change\n        old_cost1 = (distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n        new_cost1 = (distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.8762778288192585,
            8.417090279301966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Adaptive segment rotation\n    segment_length = random.randint(2, min(5, n-1))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Rotate segment left or right\n    if random.random() < 0.5:\n        segment = np.roll(segment, 1)\n    else:\n        segment = np.roll(segment, -1)\n\n    new_solution[start_pos:start_pos+segment_length] = segment\n\n    # Step 2: Selective node insertion\n    if n > 3:\n        node_to_move = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-1)\n        if insert_pos > node_to_move:\n            insert_pos += 1\n\n        # Calculate cost change\n        old_cost1 = (distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n        new_cost1 = (distance_matrix_1[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_1[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[node_to_move-1], new_solution[node_to_move]] +\n                     distance_matrix_2[new_solution[node_to_move], new_solution[(node_to_move+1)%n]])\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a combination of edge exchange, segment reversal, and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate dominance score (higher is better)\n        dominance = sum(1 for other_sol, other_obj in archive if (obj[0] < other_obj[0] and obj[1] <= other_obj[1]) or (obj[0] <= other_obj[0] and obj[1] < other_obj[1]))\n        # Calculate diversity score\n        diversity = np.mean([np.abs(obj[0] - other_obj[0]) + np.abs(obj[1] - other_obj[1]) for other_sol, other_obj in archive])\n        scores.append(0.7 * dominance + 0.3 * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Random segment reversal\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 2: Node insertion\n    k = random.randint(1, n - 2)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Edge exchange if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 + 0.05 * current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 + 0.05 * current_cost1):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            7.21935290761927,
            7.298095962603623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate dominance score (higher is better)\n        dominance = sum(1 for other_sol, other_obj in archive if (obj[0] < other_obj[0] and obj[1] <= other_obj[1]) or (obj[0] <= other_obj[0] and obj[1] < other_obj[1]))\n        # Calculate diversity score\n        diversity = np.mean([np.abs(obj[0] - other_obj[0]) + np.abs(obj[1] - other_obj[1]) for other_sol, other_obj in archive])\n        scores.append(0.7 * dominance + 0.3 * diversity)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Random segment reversal\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 2: Node insertion\n    k = random.randint(1, n - 2)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Edge exchange if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 + 0.05 * current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 + 0.05 * current_cost1):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive using a score function that combines crowding distance and dominance rank, then applies a combination of segment reversal and edge exchange operations with probabilistic acceptance criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Calculate dominance rank and crowding distance for selection\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        ranks[i] = sum(np.all(objectives <= objectives[i], axis=1) & ~np.all(objectives == objectives[i], axis=1))\n\n    # Select solution with highest rank (most dominated) or random if tied\n    selected_indices = np.where(ranks == np.min(ranks))[0]\n    selected_idx = np.random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Accept if better for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.117633653899399,
            7.242958703379967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Calculate dominance rank and crowding distance for selection\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.zeros(len(archive))\n    for i in range(len(archive)):\n        ranks[i] = sum(np.all(objectives <= objectives[i], axis=1) & ~np.all(objectives == objectives[i], axis=1))\n\n    # Select solution with highest rank (most dominated) or random if tied\n    selected_indices = np.where(ranks == np.min(ranks))[0]\n    selected_idx = np.random.choice(selected_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Accept if better for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment insertion and edge flipping operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    # Find the solution with the most diverse objectives\n    max_diversity = -1\n    selected_idx = 0\n    for i, (obj1, obj2) in enumerate(objectives):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to remove\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b]\n\n    # Step 2: Insert the segment in a different position\n    new_solution = np.delete(new_solution, slice(a, b))\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Flip an edge if beneficial for at least one objective\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[k], new_solution[k-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[k-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.840720731360367,
            7.332612717678166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    # Find the solution with the most diverse objectives\n    max_diversity = -1\n    selected_idx = 0\n    for i, (obj1, obj2) in enumerate(objectives):\n        diversity = abs(obj1 - obj2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to remove\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b]\n\n    # Step 2: Insert the segment in a different position\n    new_solution = np.delete(new_solution, slice(a, b))\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Flip an edge if beneficial for at least one objective\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[k], new_solution[k-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[k], new_solution[k-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{A novel hybrid local search algorithm that selects a solution from the archive based on a combination of crowding distance and Pareto dominance, then applies a segment rotation operation followed by a conditional edge reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n        # Combine with Pareto dominance (simplified)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Rotate a segment by a random number of positions\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Conditionally reinsert a node to improve both objectives\n    if n > 4:\n        node_to_reinsert = random.randint(0, n - 1)\n        node_value = new_solution[node_to_reinsert]\n        new_solution = np.delete(new_solution, node_to_reinsert)\n\n        best_pos = 0\n        best_improvement = 0\n\n        for i in range(len(new_solution)):\n            # Try inserting at position i\n            temp_solution = np.insert(new_solution, i, node_value)\n\n            # Calculate improvement for both objectives\n            prev_node = temp_solution[i-1] if i > 0 else temp_solution[-1]\n            next_node = temp_solution[(i+1)%len(temp_solution)]\n            current_cost1 = distance_matrix_1[prev_node, node_value] + distance_matrix_1[node_value, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node_value] + distance_matrix_2[node_value, next_node]\n\n            if i > 0:\n                prev_prev_node = temp_solution[i-2]\n                original_cost1 = distance_matrix_1[prev_prev_node, prev_node] + distance_matrix_1[prev_node, node_value] + distance_matrix_1[node_value, next_node]\n                new_cost1 = distance_matrix_1[prev_prev_node, node_value] + distance_matrix_1[node_value, prev_node] + distance_matrix_1[prev_node, next_node]\n                improvement1 = original_cost1 - new_cost1\n\n                original_cost2 = distance_matrix_2[prev_prev_node, prev_node] + distance_matrix_2[prev_node, node_value] + distance_matrix_2[node_value, next_node]\n                new_cost2 = distance_matrix_2[prev_prev_node, node_value] + distance_matrix_2[node_value, prev_node] + distance_matrix_2[prev_node, next_node]\n                improvement2 = original_cost2 - new_cost2\n\n                if (improvement1 > best_improvement and improvement2 > 0) or (improvement2 > best_improvement and improvement1 > 0):\n                    best_pos = i\n                    best_improvement = max(improvement1, improvement2)\n\n            new_solution = np.insert(new_solution, best_pos, node_value)\n\n    return new_solution\n\n",
        "score": [
            10.487285503187554,
            10.558815914785455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i])\n\n        # Combine with Pareto dominance (simplified)\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Rotate a segment by a random number of positions\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Step 2: Conditionally reinsert a node to improve both objectives\n    if n > 4:\n        node_to_reinsert = random.randint(0, n - 1)\n        node_value = new_solution[node_to_reinsert]\n        new_solution = np.delete(new_solution, node_to_reinsert)\n\n        best_pos = 0\n        best_improvement = 0\n\n        for i in range(len(new_solution)):\n            # Try inserting at position i\n            temp_solution = np.insert(new_solution, i, node_value)\n\n            # Calculate improvement for both objectives\n            prev_node = temp_solution[i-1] if i > 0 else temp_solution[-1]\n            next_node = temp_solution[(i+1)%len(temp_solution)]\n            current_cost1 = distance_matrix_1[prev_node, node_value] + distance_matrix_1[node_value, next_node]\n            current_cost2 = distance_matrix_2[prev_node, node_value] + distance_matrix_2[node_value, next_node]\n\n            if i > 0:\n                prev_prev_node = temp_solution[i-2]\n                original_cost1 = distance_matrix_1[prev_prev_node, prev_node] + distance_matrix_1[prev_node, node_value] + distance_matrix_1[node_value, next_node]\n                new_cost1 = distance_matrix_1[prev_prev_node, node_value] + distance_matrix_1[node_value, prev_node] + distance_matrix_1[prev_node, next_node]\n                improvement1 = original_cost1 - new_cost1\n\n                original_cost2 = distance_matrix_2[prev_prev_node, prev_node] + distance_matrix_2[prev_node, node_value] + distance_matrix_2[node_value, next_node]\n                new_cost2 = distance_matrix_2[prev_prev_node, node_value] + distance_matrix_2[node_value, prev_node] + distance_matrix_2[prev_node, next_node]\n                improvement2 = original_cost2 - new_cost2\n\n                if (improvement1 > best_improvement and improvement2 > 0) or (improvement2 > best_improvement and improvement1 > 0):\n                    best_pos = i\n                    best_improvement = max(improvement1, improvement2)\n\n            new_solution = np.insert(new_solution, best_pos, node_value)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive with high Pareto dominance, then applies a combination of node insertion and segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert a node at a different position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            6.470993325179961,
            5.964587414123148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Rotate the segment by one position\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[i:j] = rotated_segment\n\n    # Step 3: Randomly insert a node at a different position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[(k+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[(k+1)%n]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{A novel adaptive multi-segment relinking algorithm selects a solution from the archive based on its objective diversity and performs a dynamic combination of segment relinking, node insertion, and path swapping operations to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic segment selection\n    segment_length = random.randint(2, max(2, n // 4))\n    start_pos = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Step 2: Relink segment to different position\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos < start_pos:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start_pos], new_solution[start_pos+segment_length:]])\n    else:\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos+segment_length:new_pos], segment, new_solution[new_pos:]])\n\n    # Step 3: Adaptive node insertion\n    if random.random() < 0.3:\n        node_to_move = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_move]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Step 4: Path swapping if beneficial\n    if n >= 4:\n        k = random.randint(0, n - 4)\n        l = random.randint(k + 2, n - 2)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[l-1], new_solution[l]])\n        new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_1[new_solution[l-1], new_solution[k]])\n\n        current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[l-1], new_solution[l]])\n        new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_2[new_solution[l-1], new_solution[k]])\n\n        # Apply swap if beneficial for both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.538309518117492,
            7.623598289891821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    diversity_scores = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic segment selection\n    segment_length = random.randint(2, max(2, n // 4))\n    start_pos = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Step 2: Relink segment to different position\n    new_pos = random.randint(0, n - segment_length)\n    if new_pos < start_pos:\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:start_pos], new_solution[start_pos+segment_length:]])\n    else:\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos+segment_length:new_pos], segment, new_solution[new_pos:]])\n\n    # Step 3: Adaptive node insertion\n    if random.random() < 0.3:\n        node_to_move = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_move]\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Step 4: Path swapping if beneficial\n    if n >= 4:\n        k = random.randint(0, n - 4)\n        l = random.randint(k + 2, n - 2)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[l-1], new_solution[l]])\n        new_cost1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_1[new_solution[l-1], new_solution[k]])\n\n        current_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[l-1], new_solution[l]])\n        new_cost2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_2[new_solution[l-1], new_solution[k]])\n\n        # Apply swap if beneficial for both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort by Pareto dominance (simplified by sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Top 4 candidates\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        return np.array([])  # Handle empty archive\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Hybrid local search: Segment reversal with edge exchange\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and attempt a swap\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.783127783487385,
            6.088048186591086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Sort by Pareto dominance (simplified by sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Top 4 candidates\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        return np.array([])  # Handle empty archive\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Hybrid local search: Segment reversal with edge exchange\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and attempt a swap\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and crowding distance, then applies a segment inversion and edge swap operation with a probability proportional to the solution's potential for improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% of solutions\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 3 - 1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for better solutions\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge swap with probability based on potential improvement\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.529092183712869,
            7.140067042468242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% of solutions\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 3 - 1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment inversion with probability based on solution quality\n    if random.random() < 0.7:  # Higher probability for better solutions\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge swap with probability based on potential improvement\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{The new algorithm will select a solution from the archive based on its Pareto dominance and diversity, then apply a novel combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: lower cost in either objective)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive)-1))  # Top 3 solutions\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Insert a randomly selected node elsewhere in the tour\n    k = random.randint(0, n - 1)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Step 3: Check if the new solution is better in at least one objective\n    original_cost1 = archive[selected_idx][1][0]\n    original_cost2 = archive[selected_idx][1][1]\n\n    new_cost1 = 0.0\n    new_cost2 = 0.0\n\n    for idx in range(n):\n        next_idx = (idx + 1) % n\n        new_cost1 += distance_matrix_1[new_solution[idx], new_solution[next_idx]]\n        new_cost2 += distance_matrix_2[new_solution[idx], new_solution[next_idx]]\n\n    # Only keep the new solution if it's better in at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            6.938056696371908,
            7.58674051934424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: lower cost in either objective)\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive)-1))  # Top 3 solutions\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Insert a randomly selected node elsewhere in the tour\n    k = random.randint(0, n - 1)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Step 3: Check if the new solution is better in at least one objective\n    original_cost1 = archive[selected_idx][1][0]\n    original_cost2 = archive[selected_idx][1][1]\n\n    new_cost1 = 0.0\n    new_cost2 = 0.0\n\n    for idx in range(n):\n        next_idx = (idx + 1) % n\n        new_cost1 += distance_matrix_1[new_solution[idx], new_solution[next_idx]]\n        new_cost2 += distance_matrix_2[new_solution[idx], new_solution[next_idx]]\n\n    # Only keep the new solution if it's better in at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize diverse solutions\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.choice([0, len(archive_sorted) - 1])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with probability 0.7\n    if random.random() < 0.7:\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Apply a double-bridge move with probability 0.5\n    if random.random() < 0.5 and n >= 6:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[b], new_solution[a], new_solution[d], new_solution[c]\n\n    # Step 4: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.594239465430768,
            7.105789930090603
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to prioritize diverse solutions\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        selected_idx = random.choice([0, len(archive_sorted) - 1])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with probability 0.7\n    if random.random() < 0.7:\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Apply a double-bridge move with probability 0.5\n    if random.random() < 0.5 and n >= 6:\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[b], new_solution[a], new_solution[d], new_solution[c]\n\n    # Step 4: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 * 0.95) or (new_cost2 < current_cost2 * 0.95):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on objective diversity, then applies a combination of segment insertion and edge reversal operations, ensuring feasibility while improving both objectives through a multi-criteria evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with maximum diversity in objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        selected_idx = max(range(len(objectives)), key=lambda i: (objectives[i][0] - objectives[i][1])**2)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment insertion and edge reversal\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a:\n        b = random.randint(0, n-1)\n\n    # Insert segment between a and b\n    segment_start = min(a, b)\n    segment_end = max(a, b)\n    segment = new_solution[segment_start:segment_end+1]\n\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_end+1:],\n        segment\n    ])\n\n    # Reverse a random edge if beneficial\n    c = random.randint(0, n-2)\n    d = c + 1\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d-1], new_solution[c]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            6.521535497363162,
            8.960800979363908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with maximum diversity in objectives\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        selected_idx = max(range(len(objectives)), key=lambda i: (objectives[i][0] - objectives[i][1])**2)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment insertion and edge reversal\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a:\n        b = random.randint(0, n-1)\n\n    # Insert segment between a and b\n    segment_start = min(a, b)\n    segment_end = max(a, b)\n    segment = new_solution[segment_start:segment_end+1]\n\n    new_solution = np.concatenate([\n        new_solution[:segment_start],\n        new_solution[segment_end+1:],\n        segment\n    ])\n\n    # Reverse a random edge if beneficial\n    c = random.randint(0, n-2)\n    d = c + 1\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d-1], new_solution[c]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel local search algorithm selects a diverse solution from the archive and applies a combination of segment rotation and node insertion operations to generate a neighbor solution while ensuring feasibility, prioritizing solutions with high Pareto dominance or objective diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(np.abs(objectives[:, None] - objectives), axis=2)\n        diversity = np.sum(diversity, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            7.687849680897029,
            7.198013577354146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(np.abs(objectives[:, None] - objectives), axis=2)\n        diversity = np.sum(diversity, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{An enhanced hybrid local search algorithm selects a solution from the archive based on its non-dominated status and applies a combination of segment rotation and edge insertion operations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, obj in archive if all(obj[0] <= obj2[0] and obj[1] <= obj2[1] or obj[0] >= obj2[0] and obj[1] >= obj2[1] for _, obj2 in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotate_pos = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Randomly insert a node from the segment into another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Check if the new solution is better in at least one objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution) - 1):\n            cost += distance_matrix[solution[i], solution[i+1]]\n        cost += distance_matrix[solution[-1], solution[0]]\n        return cost\n\n    old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            6.773944354592419,
            6.806869951004947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [sol for sol, obj in archive if all(obj[0] <= obj2[0] and obj[1] <= obj2[1] or obj[0] >= obj2[0] and obj[1] >= obj2[1] for _, obj2 in archive)]\n    if non_dominated:\n        base_solution = random.choice(non_dominated).copy()\n    else:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotate_pos = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Randomly insert a node from the segment into another position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Check if the new solution is better in at least one objective\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution) - 1):\n            cost += distance_matrix[solution[i], solution[i+1]]\n        cost += distance_matrix[solution[-1], solution[0]]\n        return cost\n\n    old_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    old_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if (new_cost1 <= old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= old_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive by prioritizing those with high crowding distance or extreme objective values, then applies a combination of edge reversal and segment insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and reversal\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment[::-1], new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            7.965408338915946,
            7.241058954486227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and reversal\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment[::-1], new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a combination of segment rotation and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of dominance and diversity\n    weights = np.array([1.0, 1.0])  # Equal weights for simplicity\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives\n        obj1, obj2 = obj\n        norm_obj1 = (obj1 - np.min([o[0] for _, o in archive])) / (np.max([o[0] for _, o in archive]) - np.min([o[0] for _, o in archive]))\n        norm_obj2 = (obj2 - np.min([o[1] for _, o in archive])) / (np.max([o[1] for _, o in archive]) - np.min([o[1] for _, o in archive]))\n        # Score combines dominance and diversity\n        score = weights[0] * (1 - norm_obj1) + weights[1] * (1 - norm_obj2) + 0.5 * (norm_obj1 + norm_obj2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i + 1, j - 1)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k - i)\n    new_solution[i:j] = rotated_segment\n\n    # Apply node insertion\n    pos = random.randint(0, n - 1)\n    node = new_solution[pos]\n    new_solution = np.delete(new_solution, pos)\n    new_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.54787351804132,
            6.3045875081871205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of dominance and diversity\n    weights = np.array([1.0, 1.0])  # Equal weights for simplicity\n    scores = []\n    for sol, obj in archive:\n        # Normalize objectives\n        obj1, obj2 = obj\n        norm_obj1 = (obj1 - np.min([o[0] for _, o in archive])) / (np.max([o[0] for _, o in archive]) - np.min([o[0] for _, o in archive]))\n        norm_obj2 = (obj2 - np.min([o[1] for _, o in archive])) / (np.max([o[1] for _, o in archive]) - np.min([o[1] for _, o in archive]))\n        # Score combines dominance and diversity\n        score = weights[0] * (1 - norm_obj1) + weights[1] * (1 - norm_obj2) + 0.5 * (norm_obj1 + norm_obj2)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(i + 1, j - 1)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, k - i)\n    new_solution[i:j] = rotated_segment\n\n    # Apply node insertion\n    pos = random.randint(0, n - 1)\n    node = new_solution[pos]\n    new_solution = np.delete(new_solution, pos)\n    new_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, len(archive_sorted) // 2, len(archive_sorted) - 1])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.019647468774837,
            6.819402212072468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, len(archive_sorted) // 2, len(archive_sorted) - 1])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and crowding distance, then applies a multi-segment shuffle and edge inversion operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most crowded solution in the archive\n    max_crowding = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        if i == 0 or i == len(archive)-1:\n            crowding = float('inf')\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n            crowding = (right[0] - left[0]) + (right[1] - left[1])\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Apply multi-segment shuffle\n    num_segments = random.randint(2, min(4, n//3))\n    segment_points = sorted(random.sample(range(1, n-1), num_segments-1))\n\n    segments = []\n    start = 0\n    for end in segment_points:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Apply edge inversion with probability\n    if random.random() < 0.3:\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            9.127576729174327,
            9.224273776309058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most crowded solution in the archive\n    max_crowding = -1\n    selected_idx = 0\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate crowding distance (simplified)\n        if i == 0 or i == len(archive)-1:\n            crowding = float('inf')\n        else:\n            left = archive[i-1][1]\n            right = archive[i+1][1]\n            crowding = (right[0] - left[0]) + (right[1] - left[1])\n        if crowding > max_crowding:\n            max_crowding = crowding\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Apply multi-segment shuffle\n    num_segments = random.randint(2, min(4, n//3))\n    segment_points = sorted(random.sample(range(1, n-1), num_segments-1))\n\n    segments = []\n    start = 0\n    for end in segment_points:\n        segments.append(new_solution[start:end])\n        start = end\n    segments.append(new_solution[start:])\n\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Apply edge inversion with probability\n    if random.random() < 0.3:\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange, segment reversal, and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to insert elsewhere\n    insert_node = random.randint(0, n - 1)\n    removed_node = new_solution[insert_node]\n\n    # Step 2: Remove the node from its current position\n    new_solution = np.delete(new_solution, insert_node)\n\n    # Step 3: Insert the node at a new position\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 4: Apply a segment reversal between two random positions\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 5: Apply an edge exchange between two random edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.000733327075465,
            7.236067436564228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to insert elsewhere\n    insert_node = random.randint(0, n - 1)\n    removed_node = new_solution[insert_node]\n\n    # Step 2: Remove the node from its current position\n    new_solution = np.delete(new_solution, insert_node)\n\n    # Step 3: Insert the node at a new position\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n    # Step 4: Apply a segment reversal between two random positions\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 5: Apply an edge exchange between two random edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores (simplified for this example)\n        dominance_scores = []\n        for sol, obj in archive:\n            score = obj[0] + obj[1]  # Sum of objectives (can be replaced with more sophisticated scoring)\n            dominance_scores.append(score)\n        selected_idx = np.argmin(dominance_scores)  # Select the least dominated solution\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.934202846113408,
            6.157767761392778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance scores (simplified for this example)\n        dominance_scores = []\n        for sol, obj in archive:\n            score = obj[0] + obj[1]  # Sum of objectives (can be replaced with more sophisticated scoring)\n            dominance_scores.append(score)\n        selected_idx = np.argmin(dominance_scores)  # Select the least dominated solution\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its diversity and applies a hybrid of segment rotation and edge reconnection operations, ensuring feasibility while prioritizing improvements in both objectives through a balanced exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        distances = np.linalg.norm(objectives - mean_obj, axis=1)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Step 2: Reconnect edges with improved diversity\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply reconnection if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.692976341937593,
            7.272873269913635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        distances = np.linalg.norm(objectives - mean_obj, axis=1)\n        selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Step 2: Reconnect edges with improved diversity\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply reconnection if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a hybrid of edge insertion and segment rotation operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of Pareto dominance and diversity\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search with edge insertion and segment rotation\n    # Step 1: Randomly select a segment to rotate\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[segment_start:segment_start + segment_length] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere in the tour\n    node_to_insert = random.randint(0, n - 1)\n    insert_pos = random.randint(0, n - 1)\n    if insert_pos != node_to_insert:\n        node_value = new_solution[node_to_insert]\n        new_solution = np.delete(new_solution, node_to_insert)\n        new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    return new_solution\n\n",
        "score": [
            7.251975674891341,
            7.186565917133077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted combination of Pareto dominance and diversity\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search with edge insertion and segment rotation\n    # Step 1: Randomly select a segment to rotate\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[segment_start:segment_start + segment_length] = rotated_segment\n\n    # Step 3: Randomly insert a node elsewhere in the tour\n    node_to_insert = random.randint(0, n - 1)\n    insert_pos = random.randint(0, n - 1)\n    if insert_pos != node_to_insert:\n        node_value = new_solution[node_to_insert]\n        new_solution = np.delete(new_solution, node_to_insert)\n        new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of cross-exchange and adaptive segment insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: prioritize solutions with better objective values)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Cross-exchange operation\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n    new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                 distance_matrix_1[new_solution[c-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n    current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n    new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                 distance_matrix_2[new_solution[c-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n    # Apply cross-exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the cross-exchange\n        temp = new_solution[a]\n        new_solution[a] = new_solution[c]\n        new_solution[c] = new_solution[b]\n        new_solution[b] = temp\n\n    # Step 2: Adaptive segment insertion\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate insertion cost\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the insertion\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    return new_solution\n\n",
        "score": [
            6.355379856052785,
            6.61937073873537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified: prioritize solutions with better objective values)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Cross-exchange operation\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n    new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[c]] +\n                 distance_matrix_1[new_solution[c-1], new_solution[b]] +\n                 distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n    current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                     distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                     distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n    new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[c]] +\n                 distance_matrix_2[new_solution[c-1], new_solution[b]] +\n                 distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n    # Apply cross-exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the cross-exchange\n        temp = new_solution[a]\n        new_solution[a] = new_solution[c]\n        new_solution[c] = new_solution[b]\n        new_solution[b] = temp\n\n    # Step 2: Adaptive segment insertion\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Calculate insertion cost\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the insertion\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{A new algorithm selects a solution from the archive by prioritizing those with high objective diversity, then applies a segment relocation and edge insertion strategy to generate neighbors while ensuring feasibility through careful position tracking and validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Extract and remove the segment\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Find insertion position that minimizes total cost for both objectives\n    min_cost = float('inf')\n    best_pos = 0\n\n    for pos in range(0, len(new_solution)):\n        # Try inserting before pos\n        candidate = np.insert(new_solution, pos, segment)\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            6.712044556129882,
            6.570258152968748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Extract and remove the segment\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Find insertion position that minimizes total cost for both objectives\n    min_cost = float('inf')\n    best_pos = 0\n\n    for pos in range(0, len(new_solution)):\n        # Try inserting before pos\n        candidate = np.insert(new_solution, pos, segment)\n        cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n        cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, len(candidate)))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] + obj[1]) for obj in objectives], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probabilistic selection\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    if random.random() < 0.7:  # 70% chance to reverse\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with cost improvement check\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 and random.random() < 0.6) or (new_cost2 < current_cost2 and random.random() < 0.6):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.155007123302982,
            6.378971368493707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] + obj[1]) for obj in objectives], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probabilistic selection\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    if random.random() < 0.7:  # 70% chance to reverse\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with cost improvement check\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 and random.random() < 0.6) or (new_cost2 < current_cost2 and random.random() < 0.6):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment shifting and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to shift\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Extract and remove the segment\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 4: Randomly select an edge to potentially insert\n    u = random.randint(0, n - 1)\n    v = random.randint(0, n - 1)\n\n    if u != v and (u, v) not in zip(new_solution[:-1], new_solution[1:]) and (v, u) not in zip(new_solution[:-1], new_solution[1:]):\n        # Find positions to insert the edge\n        pos1 = random.randint(0, len(new_solution) - 1)\n        pos2 = random.randint(0, len(new_solution) - 1)\n\n        # Calculate cost differences\n        current_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n        new_cost1 = distance_matrix_1[new_solution[pos1-1], u] + distance_matrix_1[u, v] + distance_matrix_1[v, new_solution[pos2]]\n\n        current_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n        new_cost2 = distance_matrix_2[new_solution[pos1-1], u] + distance_matrix_2[u, v] + distance_matrix_2[v, new_solution[pos2]]\n\n        # Apply insertion if beneficial\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = np.concatenate([new_solution[:pos1], [u], [v], new_solution[pos2:]])\n\n    return new_solution\n\n",
        "score": [
            7.034053581051189,
            6.747731998035543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to shift\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Extract and remove the segment\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 3: Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 4: Randomly select an edge to potentially insert\n    u = random.randint(0, n - 1)\n    v = random.randint(0, n - 1)\n\n    if u != v and (u, v) not in zip(new_solution[:-1], new_solution[1:]) and (v, u) not in zip(new_solution[:-1], new_solution[1:]):\n        # Find positions to insert the edge\n        pos1 = random.randint(0, len(new_solution) - 1)\n        pos2 = random.randint(0, len(new_solution) - 1)\n\n        # Calculate cost differences\n        current_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n        new_cost1 = distance_matrix_1[new_solution[pos1-1], u] + distance_matrix_1[u, v] + distance_matrix_1[v, new_solution[pos2]]\n\n        current_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n        new_cost2 = distance_matrix_2[new_solution[pos1-1], u] + distance_matrix_2[u, v] + distance_matrix_2[v, new_solution[pos2]]\n\n        # Apply insertion if beneficial\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = np.concatenate([new_solution[:pos1], [u], [v], new_solution[pos2:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its non-dominated status and applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1].copy()\n\n    # Step 2: Insert the segment at a different position\n    k = random.randint(0, n - (j - i + 1))\n    if k > i:\n        k += (j - i + 1)\n\n    # Remove the segment from current position and insert at new position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 3: Randomly reverse a segment if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.63935568907253,
            7.275964071834021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1].copy()\n\n    # Step 2: Insert the segment at a different position\n    k = random.randint(0, n - (j - i + 1))\n    if k > i:\n        k += (j - i + 1)\n\n    # Remove the segment from current position and insert at new position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n    # Step 3: Randomly reverse a segment if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{A novel hybrid local search algorithm that selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel segment rotation and partial edge exchange operation to generate a neighbor solution while ensuring feasibility by maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity and quality scores\n        diversity_scores = []\n        quality_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] - obj[1])**2  # Simple diversity measure\n            quality = obj[0] + obj[1]  # Simple quality measure\n            diversity_scores.append(diversity)\n            quality_scores.append(quality)\n\n        # Normalize scores\n        max_div = max(diversity_scores) if max(diversity_scores) != 0 else 1\n        min_qual = min(quality_scores) if min(quality_scores) != 0 else 1\n        combined_scores = [(div/max_div) + (1 - qual/min_qual) for div, qual in zip(diversity_scores, quality_scores)]\n\n        # Select based on combined score\n        selected_idx = combined_scores.index(max(combined_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Novel segment rotation and partial exchange\n    a = random.randint(0, n-3)\n    b = random.randint(a+1, n-2)\n    c = random.randint(b+1, n-1)\n\n    # Rotate segment [b, c] to position after a\n    segment = new_solution[b:c+1]\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        segment,\n        new_solution[a+1:b],\n        new_solution[c+1:]\n    ])\n\n    # Partial edge exchange\n    if random.random() < 0.5:\n        x = random.randint(0, len(segment)-1)\n        y = random.randint(0, len(new_solution)-1)\n\n        # Ensure we're not swapping with the same node\n        if new_solution[y] != segment[x]:\n            # Calculate cost changes\n            old_cost1 = distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]\n            new_cost1 = distance_matrix_1[segment[x-1], new_solution[y]] + distance_matrix_1[new_solution[y], segment[(x+1)%len(segment)]]\n\n            old_cost2 = distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]\n            new_cost2 = distance_matrix_2[segment[x-1], new_solution[y]] + distance_matrix_2[new_solution[y], segment[(x+1)%len(segment)]]\n\n            # Apply if beneficial for at least one objective\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                segment[x], new_solution[y] = new_solution[y], segment[x]\n\n    return new_solution\n\n",
        "score": [
            6.600629067693211,
            8.80415739259322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity and quality scores\n        diversity_scores = []\n        quality_scores = []\n        for sol, obj in archive:\n            diversity = (obj[0] - obj[1])**2  # Simple diversity measure\n            quality = obj[0] + obj[1]  # Simple quality measure\n            diversity_scores.append(diversity)\n            quality_scores.append(quality)\n\n        # Normalize scores\n        max_div = max(diversity_scores) if max(diversity_scores) != 0 else 1\n        min_qual = min(quality_scores) if min(quality_scores) != 0 else 1\n        combined_scores = [(div/max_div) + (1 - qual/min_qual) for div, qual in zip(diversity_scores, quality_scores)]\n\n        # Select based on combined score\n        selected_idx = combined_scores.index(max(combined_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Novel segment rotation and partial exchange\n    a = random.randint(0, n-3)\n    b = random.randint(a+1, n-2)\n    c = random.randint(b+1, n-1)\n\n    # Rotate segment [b, c] to position after a\n    segment = new_solution[b:c+1]\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        segment,\n        new_solution[a+1:b],\n        new_solution[c+1:]\n    ])\n\n    # Partial edge exchange\n    if random.random() < 0.5:\n        x = random.randint(0, len(segment)-1)\n        y = random.randint(0, len(new_solution)-1)\n\n        # Ensure we're not swapping with the same node\n        if new_solution[y] != segment[x]:\n            # Calculate cost changes\n            old_cost1 = distance_matrix_1[segment[x-1], segment[x]] + distance_matrix_1[segment[x], segment[(x+1)%len(segment)]]\n            new_cost1 = distance_matrix_1[segment[x-1], new_solution[y]] + distance_matrix_1[new_solution[y], segment[(x+1)%len(segment)]]\n\n            old_cost2 = distance_matrix_2[segment[x-1], segment[x]] + distance_matrix_2[segment[x], segment[(x+1)%len(segment)]]\n            new_cost2 = distance_matrix_2[segment[x-1], new_solution[y]] + distance_matrix_2[new_solution[y], segment[(x+1)%len(segment)]]\n\n            # Apply if beneficial for at least one objective\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                segment[x], new_solution[y] = new_solution[y], segment[x]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This novel algorithm selects a high-quality solution from the archive based on combined objective diversity and dominance, then applies a hybrid of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high combined objective diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) > 1:\n        diversity = np.sum(np.abs(objectives[:, np.newaxis] - objectives), axis=2)\n        selected_idx = np.argmax(np.sum(diversity, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Rotate segment by k positions\n    k = random.randint(1, j - i - 1)\n    segment = new_solution[i+1:j]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i+1:j] = rotated_segment\n\n    # Insert a randomly selected edge at a new position\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        # Remove edge a-b if it exists\n        for idx in range(n):\n            if new_solution[idx] == a and new_solution[(idx + 1) % n] == b:\n                new_solution[idx], new_solution[(idx + 1) % n] = new_solution[(idx + 1) % n], new_solution[idx]\n                break\n        # Insert edge a-b at random position\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, a)\n        new_solution = np.insert(new_solution, (pos + 1) % len(new_solution), b)\n\n    return new_solution\n\n",
        "score": [
            9.561554390922563,
            9.740780070292992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high combined objective diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) > 1:\n        diversity = np.sum(np.abs(objectives[:, np.newaxis] - objectives), axis=2)\n        selected_idx = np.argmax(np.sum(diversity, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Rotate segment by k positions\n    k = random.randint(1, j - i - 1)\n    segment = new_solution[i+1:j]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i+1:j] = rotated_segment\n\n    # Insert a randomly selected edge at a new position\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        # Remove edge a-b if it exists\n        for idx in range(n):\n            if new_solution[idx] == a and new_solution[(idx + 1) % n] == b:\n                new_solution[idx], new_solution[(idx + 1) % n] = new_solution[(idx + 1) % n], new_solution[idx]\n                break\n        # Insert edge a-b at random position\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, a)\n        new_solution = np.insert(new_solution, (pos + 1) % len(new_solution), b)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a sequence of edge swaps and segment rotations to generate a neighbor solution while ensuring feasibility through constrained random segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i+1:j+1]\n    rotated = np.roll(segment, 1)\n    new_solution[i+1:j+1] = rotated\n\n    # Apply edge swaps with probability based on cost improvement\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and random.random() < 0.7) or (new_cost2 < current_cost2 and random.random() < 0.7):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.53590189293966,
            8.416068248082022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i+1:j+1]\n    rotated = np.roll(segment, 1)\n    new_solution[i+1:j+1] = rotated\n\n    # Apply edge swaps with probability based on cost improvement\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and random.random() < 0.7) or (new_cost2 < current_cost2 and random.random() < 0.7):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This new algorithm selects a promising solution from the archive based on its diversity in objective space, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    # Calculate diversity scores (Euclidean distance from average objective)\n    avg_obj = np.mean(objectives, axis=0)\n    diversity = [np.linalg.norm(np.array(obj) - avg_obj) for obj in objectives]\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Check if the new solution is better in at least one objective\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # If worse, revert to base solution\n    if (current_cost1 > archive[selected_idx][1][0] and current_cost2 > archive[selected_idx][1][1]):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.395511701115742,
            7.476981168276405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    # Calculate diversity scores (Euclidean distance from average objective)\n    avg_obj = np.mean(objectives, axis=0)\n    diversity = [np.linalg.norm(np.array(obj) - avg_obj) for obj in objectives]\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j+1] = np.roll(segment, rotation)\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Check if the new solution is better in at least one objective\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # If worse, revert to base solution\n    if (current_cost1 > archive[selected_idx][1][0] and current_cost2 > archive[selected_idx][1][1]):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations, while dynamically adjusting the selection probability based on solution quality and diversity, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate Pareto dominance count\n        dominance = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] < obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        # Calculate diversity score (negative Euclidean distance to origin)\n        diversity = -(obj[0]**2 + obj[1]**2)**0.5\n        scores.append((dominance + diversity, sol))\n\n    # Select solution with highest score (higher priority for Pareto dominance and diversity)\n    scores.sort(reverse=True)\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Probabilistic segment reversal\n    if random.random() < 0.7:  # Higher probability for this operation\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 2: Edge exchange with probabilistic acceptance\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Accept if beneficial for at least one objective or with probability based on improvement\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (random.random() < 0.3 * (current_cost1 - new_cost1 + current_cost2 - new_cost2) / (current_cost1 + current_cost2)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.565340197258406,
            10.621602874982974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate Pareto dominance count\n        dominance = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] < obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        # Calculate diversity score (negative Euclidean distance to origin)\n        diversity = -(obj[0]**2 + obj[1]**2)**0.5\n        scores.append((dominance + diversity, sol))\n\n    # Select solution with highest score (higher priority for Pareto dominance and diversity)\n    scores.sort(reverse=True)\n    base_solution = scores[0][1].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Probabilistic segment reversal\n    if random.random() < 0.7:  # Higher probability for this operation\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Step 2: Edge exchange with probabilistic acceptance\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Accept if beneficial for at least one objective or with probability based on improvement\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2) or (random.random() < 0.3 * (current_cost1 - new_cost1 + current_cost2 - new_cost2) / (current_cost1 + current_cost2)):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted score combining Pareto dominance, objective diversity, and a random component, then applies a combination of segment reversal and edge exchange operations with adaptive segment sizes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Pareto dominance score (simplified)\n        dominance = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        # Objective diversity score\n        diversity = (obj[0] - obj[1]) ** 2\n        # Random component\n        randomness = random.random()\n        # Combined score\n        score = 0.5 * dominance + 0.3 * diversity + 0.2 * randomness\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(5, n // 4))\n    i = random.randint(0, n - segment_size - 2)\n    j = random.randint(i + segment_size, n - 1)\n\n    # Reverse the segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange with adaptive selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, min(k + segment_size, n - 1))\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.45140004024955,
            10.656809009125805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Pareto dominance score (simplified)\n        dominance = sum(1 for s, o in archive if (o[0] < obj[0] and o[1] <= obj[1]) or (o[0] <= obj[0] and o[1] < obj[1]))\n        # Objective diversity score\n        diversity = (obj[0] - obj[1]) ** 2\n        # Random component\n        randomness = random.random()\n        # Combined score\n        score = 0.5 * dominance + 0.3 * diversity + 0.2 * randomness\n        scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(5, n // 4))\n    i = random.randint(0, n - segment_size - 2)\n    j = random.randint(i + segment_size, n - 1)\n\n    # Reverse the segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Edge exchange with adaptive selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, min(k + segment_size, n - 1))\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on crowding distance and applies a combination of segment insertion and edge swapping operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply adaptive local search\n    operation = random.choice(['insert', 'swap'])\n\n    if operation == 'insert':\n        # Segment insertion\n        a, b = sorted(random.sample(range(n), 2))\n        c = random.randint(0, n-1)\n        if a < c <= b:\n            c = (c + 2) % n\n        if c < a:\n            segment = new_solution[c:a]\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[a:b], new_solution[c:]])\n        else:\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n    else:\n        # Edge swapping\n        k = random.randint(0, n-2)\n        l = random.randint(k+1, n-1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            9.325803103257186,
            8.514471499224028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m])\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Apply adaptive local search\n    operation = random.choice(['insert', 'swap'])\n\n    if operation == 'insert':\n        # Segment insertion\n        a, b = sorted(random.sample(range(n), 2))\n        c = random.randint(0, n-1)\n        if a < c <= b:\n            c = (c + 2) % n\n        if c < a:\n            segment = new_solution[c:a]\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[a:b], new_solution[c:]])\n        else:\n            segment = new_solution[a:b]\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n    else:\n        # Edge swapping\n        k = random.randint(0, n-2)\n        l = random.randint(k+1, n-1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{A novel adaptive local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation, crossover-like edge insertion, and adaptive edge removal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        archive.sort(key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution from the top 20% or with diverse objectives\n        selected_idx = random.randint(0, max(1, len(archive) // 5 - 1))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate((new_solution[:i], new_solution[j:k], segment, new_solution[k:]))\n\n    # Step 2: Crossover-like edge insertion\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n    # Step 3: Adaptive edge removal and insertion\n    c = random.randint(0, n - 2)\n    d = random.randint(c + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d-1], new_solution[c]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]]\n\n    # Apply edge removal and insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            6.532283735827622,
            8.51155477173177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        archive.sort(key=lambda x: (x[1][0], x[1][1]))\n        # Select a solution from the top 20% or with diverse objectives\n        selected_idx = random.randint(0, max(1, len(archive) // 5 - 1))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Segment rotation\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(0, n - 1)\n    segment = new_solution[i:j]\n    new_solution = np.concatenate((new_solution[:i], new_solution[j:k], segment, new_solution[k:]))\n\n    # Step 2: Crossover-like edge insertion\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n    # Step 3: Adaptive edge removal and insertion\n    c = random.randint(0, n - 2)\n    d = random.randint(c + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[d-1], new_solution[c]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]]\n\n    # Apply edge removal and insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Rotate the segment by a random amount\n    rotate_amount = random.randint(1, j - i - 1)\n    segment = new_solution[i+1:j+1]\n    rotated_segment = np.roll(segment, rotate_amount)\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Step 3: Randomly insert a node at a new position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            6.9065685282171065,
            7.300457125125211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Rotate the segment by a random amount\n    rotate_amount = random.randint(1, j - i - 1)\n    segment = new_solution[i+1:j+1]\n    rotated_segment = np.roll(segment, rotate_amount)\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Step 3: Randomly insert a node at a new position if beneficial\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of edge exchange and segment reversal operations with adaptive segment lengths to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (Euclidean distance between objectives)\n        objectives = np.array([obj for _, obj in archive])\n        diversity_scores = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n        diversity_scores = np.sum(diversity_scores, axis=1)\n        diversity_scores = diversity_scores / np.sum(diversity_scores)\n\n        # Combine with dominance (simplified: higher diversity preferred)\n        selection_probs = diversity_scores\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_length = max(2, n // 5)\n    i = random.randint(0, n - segment_length - 2)\n    j = i + segment_length\n\n    # Reverse the selected segment\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Edge exchange with adaptive selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.17227055442705,
            6.727947967222148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores (Euclidean distance between objectives)\n        objectives = np.array([obj for _, obj in archive])\n        diversity_scores = np.linalg.norm(objectives[:, None] - objectives, axis=2)\n        diversity_scores = np.sum(diversity_scores, axis=1)\n        diversity_scores = diversity_scores / np.sum(diversity_scores)\n\n        # Combine with dominance (simplified: higher diversity preferred)\n        selection_probs = diversity_scores\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_length = max(2, n // 5)\n    i = random.randint(0, n - segment_length - 2)\n    j = i + segment_length\n\n    # Reverse the selected segment\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    # Edge exchange with adaptive selection\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This new algorithm selects a solution from the archive based on its objective diversity, then applies a novel combination of partial tour rotation and strategic node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n        selected_idx = np.argmax(np.sum(diversity, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Insert a random node at a new position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Evaluate and potentially revert if not beneficial\n    original_obj1 = archive[selected_idx][1][0]\n    original_obj2 = archive[selected_idx][1][1]\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if (new_cost1 > original_obj1 and new_cost2 > original_obj2):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            8.512167234194644,
            9.368671024879738
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n        selected_idx = np.argmax(np.sum(diversity, axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Insert a random node at a new position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Evaluate and potentially revert if not beneficial\n    original_obj1 = archive[selected_idx][1][0]\n    original_obj2 = archive[selected_idx][1][1]\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    if (new_cost1 > original_obj1 and new_cost2 > original_obj2):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This new algorithm selects a solution from the archive with high potential for improvement by analyzing objective diversity and applies a novel combination of segment rotation and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Insert a randomly selected node somewhere else in the tour\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Evaluate the new solution and accept if beneficial\n    original_cost1 = archive[selected_idx][1][0]\n    original_cost2 = archive[selected_idx][1][1]\n\n    new_cost1 = 0\n    new_cost2 = 0\n    for idx in range(n):\n        next_idx = (idx + 1) % n\n        new_cost1 += distance_matrix_1[new_solution[idx], new_solution[next_idx]]\n        new_cost2 += distance_matrix_2[new_solution[idx], new_solution[next_idx]]\n\n    # Accept if both objectives are improved or at least one is improved\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            6.693489627527972,
            7.326536408520596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Insert a randomly selected node somewhere else in the tour\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Evaluate the new solution and accept if beneficial\n    original_cost1 = archive[selected_idx][1][0]\n    original_cost2 = archive[selected_idx][1][1]\n\n    new_cost1 = 0\n    new_cost2 = 0\n    for idx in range(n):\n        next_idx = (idx + 1) % n\n        new_cost1 += distance_matrix_1[new_solution[idx], new_solution[next_idx]]\n        new_cost2 += distance_matrix_2[new_solution[idx], new_solution[next_idx]]\n\n    # Accept if both objectives are improved or at least one is improved\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n       (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on objective diversity and applies a combination of edge insertion and segment rotation to generate a neighbor solution while ensuring feasibility through careful node repositioning and cost evaluation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(abs(o1 - o2) for o1, o2 in objectives)\n        candidates = [i for i, (o1, o2) in enumerate(objectives) if abs(o1 - o2) == max_diff]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Check if rotation improves at least one objective\n    current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n))\n    current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n))\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = rotated_segment\n    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    # Apply edge insertion if beneficial\n    if n >= 4:\n        k = random.randint(1, n - 3)\n        l = random.randint(k + 1, n - 2)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[l+1]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l+1]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[l+1]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l+1]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            7.635487213286064,
            7.065857154038133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(abs(o1 - o2) for o1, o2 in objectives)\n        candidates = [i for i, (o1, o2) in enumerate(objectives) if abs(o1 - o2) == max_diff]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Check if rotation improves at least one objective\n    current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n))\n    current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n))\n\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = rotated_segment\n    new_cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = temp_solution\n\n    # Apply edge insertion if beneficial\n    if n >= 4:\n        k = random.randint(1, n - 3)\n        l = random.randint(k + 1, n - 2)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[l+1]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[l+1]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[l+1]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[l+1]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            temp_solution = new_solution.copy()\n            temp_solution[k], temp_solution[l] = temp_solution[l], temp_solution[k]\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined score of Pareto dominance and objective diversity, then applies a novel hybrid local search combining segment rotation and edge insertion to generate a neighbor solution while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best combined Pareto and diversity score\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance count and objective diversity\n        pareto_count = sum(1 for _, other_obj in archive if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]))\n        diversity = obj[0] * obj[1]  # Simple diversity measure\n        scores.append(pareto_count + diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Rotate a random segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, j - i - 1)\n    new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a random edge if beneficial\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a == b:\n        return new_solution\n\n    # Calculate potential improvement\n    current_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    if new_cost < current_cost:\n        # Perform edge insertion\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n    return new_solution\n\n",
        "score": [
            10.392365672323038,
            10.672699666643858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with best combined Pareto and diversity score\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance count and objective diversity\n        pareto_count = sum(1 for _, other_obj in archive if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]))\n        diversity = obj[0] * obj[1]  # Simple diversity measure\n        scores.append(pareto_count + diversity)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Rotate a random segment\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, j - i - 1)\n    new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Insert a random edge if beneficial\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a == b:\n        return new_solution\n\n    # Calculate potential improvement\n    current_cost = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    if new_cost < current_cost:\n        # Perform edge insertion\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{A novel hybrid local search algorithm that selects a promising solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of segment insertion and edge insertion operations while ensuring feasibility by maintaining node uniqueness and tour completeness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Remove the segment and insert it at a new position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Insert a new edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    while l == k or l == (k + 1) % n:\n        l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply edge insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:k], [new_solution[l]], new_solution[k:l], [new_solution[k]], new_solution[l+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.927763650312599,
            7.850634151331054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to move\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Remove the segment and insert it at a new position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Insert a new edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    while l == k or l == (k + 1) % n:\n        l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply edge insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.concatenate([new_solution[:k], [new_solution[l]], new_solution[k:l], [new_solution[k]], new_solution[l+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        if random.random() < 0.3:  # 30% chance to swap regardless of cost\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.732049101298025,
            7.973896842814597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n        if random.random() < 0.3:  # 30% chance to swap regardless of cost\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n        else:\n            current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n            new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n            new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective 1 and pick a middle solution\n        archive_sorted = sorted(archive, key=lambda x: x[1][0])\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal and edge exchange\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.647276801558606,
            7.665170518488365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective 1 and pick a middle solution\n        archive_sorted = sorted(archive, key=lambda x: x[1][0])\n        selected_idx = len(archive_sorted) // 2\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal and edge exchange\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This new algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment reversal, edge insertion, and node reinsertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Identify a segment to reverse and a node to reinsert\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Step 2: Reverse the segment and reinsert the node\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < i or k > j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Check for beneficial edge insertions\n    for _ in range(2):\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.006315832995771,
            6.665351540830325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Identify a segment to reverse and a node to reinsert\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Step 2: Reverse the segment and reinsert the node\n    segment = new_solution[i:j]\n    new_solution[i:j] = segment[::-1]\n\n    if k < i or k > j:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Check for beneficial edge insertions\n    for _ in range(2):\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n\n    # Create a new solution by rotating segments and performing edge exchanges\n    new_solution = selected_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    seg_length = random.randint(2, n // 2)\n    start = random.randint(0, n - seg_length)\n    segment = new_solution[start:start + seg_length]\n\n    # Rotate the segment left by one position\n    rotated_segment = np.roll(segment, -1)\n    new_solution[start:start + seg_length] = rotated_segment\n\n    # Perform edge exchange between two random non-adjacent edges\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs for both objectives\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply edge exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            10.464249552757785,
            10.59802471325407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n\n    # Create a new solution by rotating segments and performing edge exchanges\n    new_solution = selected_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to rotate\n    seg_length = random.randint(2, n // 2)\n    start = random.randint(0, n - seg_length)\n    segment = new_solution[start:start + seg_length]\n\n    # Rotate the segment left by one position\n    rotated_segment = np.roll(segment, -1)\n    new_solution[start:start + seg_length] = rotated_segment\n\n    # Perform edge exchange between two random non-adjacent edges\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate current and potential costs for both objectives\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply edge exchange if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive by considering both Pareto dominance and objective diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    # Calculate diversity-based selection probability\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    diversity_scores = [(max_obj[0] - obj[0] + max_obj[1] - obj[1]) / (max_obj[0] - min_obj[0] + max_obj[1] - min_obj[1] + 1e-8) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation and edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Rotate the segment by one position\n    segment = new_solution[i:j+1]\n    rotated = np.roll(segment, 1)\n    new_solution[i:j+1] = rotated\n\n    # Randomly insert an edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Insert edge by swapping positions\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    return new_solution\n\n",
        "score": [
            6.5541321188333885,
            6.1686162274643594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if not objectives:\n        return archive[0][0].copy()\n\n    # Calculate diversity-based selection probability\n    max_obj = np.max(objectives, axis=0)\n    min_obj = np.min(objectives, axis=0)\n    diversity_scores = [(max_obj[0] - obj[0] + max_obj[1] - obj[1]) / (max_obj[0] - min_obj[0] + max_obj[1] - min_obj[1] + 1e-8) for obj in objectives]\n    selected_idx = np.argmax(diversity_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation and edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Rotate the segment by one position\n    segment = new_solution[i:j+1]\n    rotated = np.roll(segment, 1)\n    new_solution[i:j+1] = rotated\n\n    # Randomly insert an edge if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Insert edge by swapping positions\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its position in the objective space, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n        # Select solution with highest diversity (max distance to its nearest neighbor)\n        distances = np.linalg.norm(normalized[:, None] - normalized, axis=2)\n        np.fill_diagonal(distances, np.inf)\n        selected_idx = np.argmin(distances.min(axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated\n\n    # Step 2: Insert a randomly selected node in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Evaluate and potentially accept the move\n    original_cost1 = archive[selected_idx][1][0]\n    original_cost2 = archive[selected_idx][1][1]\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    # Accept if at least one objective improves or if both don't worsen too much\n    if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or \\\n       (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.05) or \\\n       (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.05):\n        return new_solution\n\n    return base_solution\n\n",
        "score": [
            6.612149313302139,
            7.053777379235033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high diversity in objective space\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Normalize objectives\n        min_obj = objectives.min(axis=0)\n        max_obj = objectives.max(axis=0)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n        # Select solution with highest diversity (max distance to its nearest neighbor)\n        distances = np.linalg.norm(normalized[:, None] - normalized, axis=2)\n        np.fill_diagonal(distances, np.inf)\n        selected_idx = np.argmin(distances.min(axis=1))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment by a random amount\n    rotation = random.randint(1, len(segment)-1)\n    rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated\n\n    # Step 2: Insert a randomly selected node in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Step 3: Evaluate and potentially accept the move\n    original_cost1 = archive[selected_idx][1][0]\n    original_cost2 = archive[selected_idx][1][1]\n\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1, cost2\n\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    # Accept if at least one objective improves or if both don't worsen too much\n    if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or \\\n       (new_cost1 < original_cost1 and new_cost2 <= original_cost2 * 1.05) or \\\n       (new_cost2 < original_cost2 and new_cost1 <= original_cost1 * 1.05):\n        return new_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{An adaptive hybrid local search algorithm that intelligently combines segment insertion with multi-objective edge selection, prioritizing solutions with high Pareto diversity while ensuring feasibility through constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest Pareto diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment insertion\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find best insertion point for multi-objective improvement\n    best_pos = start\n    best_improvement = 0\n\n    for i in range(n):\n        if i == start:\n            continue\n\n        # Calculate potential insertion costs\n        prev_node = new_solution[(i-1)%n]\n        next_node = new_solution[i%n]\n\n        # Remove original segment\n        removed_cost1 = distance_matrix_1[new_solution[(start-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(start+segment_length)%n]]\n        added_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n\n        removed_cost2 = distance_matrix_2[new_solution[(start-1)%n], segment[0]] + distance_matrix_2[segment[-1], new_solution[(start+segment_length)%n]]\n        added_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Calculate improvement\n        improvement = (removed_cost1 - added_cost1) + (removed_cost2 - added_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = i\n\n    # Perform the insertion if beneficial\n    if best_improvement > 0:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        # Remove duplicates (keep first occurrence)\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    # Multi-objective edge selection\n    for _ in range(2):  # Perform 2 edge swaps\n        i = random.randint(0, n-3)\n        j = random.randint(i+1, n-2)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1]])\n        new_cost1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]])\n\n        current_cost2 = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            6.223503421982903,
            7.143326890067934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest Pareto diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(np.sum(diversity))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment insertion\n    segment_length = max(2, min(5, n // 4))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find best insertion point for multi-objective improvement\n    best_pos = start\n    best_improvement = 0\n\n    for i in range(n):\n        if i == start:\n            continue\n\n        # Calculate potential insertion costs\n        prev_node = new_solution[(i-1)%n]\n        next_node = new_solution[i%n]\n\n        # Remove original segment\n        removed_cost1 = distance_matrix_1[new_solution[(start-1)%n], segment[0]] + distance_matrix_1[segment[-1], new_solution[(start+segment_length)%n]]\n        added_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n\n        removed_cost2 = distance_matrix_2[new_solution[(start-1)%n], segment[0]] + distance_matrix_2[segment[-1], new_solution[(start+segment_length)%n]]\n        added_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Calculate improvement\n        improvement = (removed_cost1 - added_cost1) + (removed_cost2 - added_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = i\n\n    # Perform the insertion if beneficial\n    if best_improvement > 0:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        # Remove duplicates (keep first occurrence)\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    # Multi-objective edge selection\n    for _ in range(2):  # Perform 2 edge swaps\n        i = random.randint(0, n-3)\n        j = random.randint(i+1, n-2)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1]])\n        new_cost1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[j+1]])\n\n        current_cost2 = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[j+1]])\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.concatenate((segment[rotation:], segment[:rotation]))\n\n    # Apply edge insertion\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n    if random.random() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.410607617857382,
            7.166676617602354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]\n    scores = [obj[0] * weights[0] + obj[1] * weights[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.concatenate((segment[rotation:], segment[:rotation]))\n\n    # Apply edge insertion\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n    if random.random() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on crowding distance in objective space, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for (sol, obj) in archive]\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n        crowding = []\n        for i, obj in enumerate(objectives):\n            left1 = sorted_obj1[max(0, i-1)][0] if i > 0 else float('inf')\n            right1 = sorted_obj1[min(i+1, len(sorted_obj1)-1)][0] if i < len(sorted_obj1)-1 else float('inf')\n            dist1 = right1 - left1 if left1 != float('inf') and right1 != float('inf') else 0\n\n            left2 = sorted_obj2[max(0, i-1)][1] if i > 0 else float('inf')\n            right2 = sorted_obj2[min(i+1, len(sorted_obj2)-1)][1] if i < len(sorted_obj2)-1 else float('inf')\n            dist2 = right2 - left2 if left2 != float('inf') and right2 != float('inf') else 0\n\n            crowding.append(dist1 + dist2)\n\n        selected_idx = crowding.index(max(crowding))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n    k = random.randint(0, n-1)\n\n    # Rotate segment\n    segment = new_solution[i:j]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated\n\n    # Insert edge if beneficial\n    if k != i and k != j:\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j+1]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j+1]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            8.161854942772198,
            7.4753481955380785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for (sol, obj) in archive]\n        sorted_obj1 = sorted(objectives, key=lambda x: x[0])\n        sorted_obj2 = sorted(objectives, key=lambda x: x[1])\n\n        crowding = []\n        for i, obj in enumerate(objectives):\n            left1 = sorted_obj1[max(0, i-1)][0] if i > 0 else float('inf')\n            right1 = sorted_obj1[min(i+1, len(sorted_obj1)-1)][0] if i < len(sorted_obj1)-1 else float('inf')\n            dist1 = right1 - left1 if left1 != float('inf') and right1 != float('inf') else 0\n\n            left2 = sorted_obj2[max(0, i-1)][1] if i > 0 else float('inf')\n            right2 = sorted_obj2[min(i+1, len(sorted_obj2)-1)][1] if i < len(sorted_obj2)-1 else float('inf')\n            dist2 = right2 - left2 if left2 != float('inf') and right2 != float('inf') else 0\n\n            crowding.append(dist1 + dist2)\n\n        selected_idx = crowding.index(max(crowding))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n    k = random.randint(0, n-1)\n\n    # Rotate segment\n    segment = new_solution[i:j]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated\n\n    # Insert edge if beneficial\n    if k != i and k != j:\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[j+1]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j+1]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[j+1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j+1]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment relocation with objective-aware edge swapping to generate high-quality neighbors by intelligently selecting and modifying diverse segments while ensuring Pareto improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    best_ratio = float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        ratio = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)\n        if ratio < best_ratio:\n            best_ratio = ratio\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find the best insertion point that improves at least one objective\n    best_improvement = 0\n    best_pos = start\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n\n        # Temporarily insert segment at new position\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:start], new_solution[start+segment_length:]])\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n\n        # Calculate improvement (negative means better)\n        improvement = min(cost1 - archive[selected_idx][1][0], cost2 - archive[selected_idx][1][1])\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != start:\n        # Apply the best segment relocation\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:start], new_solution[start+segment_length:]])\n\n    # Step 2: Objective-aware edge swapping\n    for _ in range(2):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.9280394424261775,
            8.593621759097921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    best_ratio = float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        ratio = abs(cost1 - cost2) / (cost1 + cost2 + 1e-10)\n        if ratio < best_ratio:\n            best_ratio = ratio\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n\n    # Find the best insertion point that improves at least one objective\n    best_improvement = 0\n    best_pos = start\n    for pos in range(n - segment_length + 1):\n        if pos == start:\n            continue\n\n        # Temporarily insert segment at new position\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:start], new_solution[start+segment_length:]])\n\n        # Calculate costs\n        cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n\n        # Calculate improvement (negative means better)\n        improvement = min(cost1 - archive[selected_idx][1][0], cost2 - archive[selected_idx][1][1])\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != start:\n        # Apply the best segment relocation\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:start], new_solution[start+segment_length:]])\n\n    # Step 2: Objective-aware edge swapping\n    for _ in range(2):\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a diverse solution from the archive based on objective value spread and applies a novel segment relocation and edge flipping strategy to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(abs(obj1 - obj2) for obj1, obj2 in objectives)\n        candidates = [i for i, (obj1, obj2) in enumerate(objectives) if abs(obj1 - obj2) == max_diff]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Relocate a random segment to a new position\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Flip a random edge if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.263503490161461,
            6.865549864883242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(abs(obj1 - obj2) for obj1, obj2 in objectives)\n        candidates = [i for i, (obj1, obj2) in enumerate(objectives) if abs(obj1 - obj2) == max_diff]\n        selected_idx = random.choice(candidates)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Relocate a random segment to a new position\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Flip a random edge if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive based on objective value spread, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    start = random.randint(0, n - 5)\n    end = random.randint(start + 3, n - 2)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n\n    # Remove the node and insert it at a random position\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            7.131598388522911,
            7.2738075288032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    start = random.randint(0, n - 5)\n    end = random.randint(start + 3, n - 2)\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    node_pos = random.randint(0, n - 1)\n    node = new_solution[node_pos]\n\n    # Remove the node and insert it at a random position\n    new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of squared differences)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Extract and relocate the segment to a new position\n    segment = new_solution[i:j+1]\n    remaining = np.delete(new_solution, np.arange(i, j+1))\n    new_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:new_pos], segment, remaining[new_pos:]])\n\n    # Step 3: Apply a conditional edge swap\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            8.76348826503537,
            9.03718730214249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective diversity (sum of squared differences)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum((objectives - np.mean(objectives, axis=0))**2, axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relocate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Extract and relocate the segment to a new position\n    segment = new_solution[i:j+1]\n    remaining = np.delete(new_solution, np.arange(i, j+1))\n    new_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:new_pos], segment, remaining[new_pos:]])\n\n    # Step 3: Apply a conditional edge swap\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of crowding distance and Pareto dominance, then applies a segment insertion and edge inversion operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance and good Pareto dominance\n    crowding_distances = []\n    for sol, _ in archive:\n        # Calculate crowding distance (simplified)\n        total_distance = 0\n        for i in range(len(sol)-1):\n            total_distance += distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]]\n        crowding_distances.append(total_distance)\n\n    # Normalize crowding distances\n    max_dist = max(crowding_distances) if max(crowding_distances) != 0 else 1\n    normalized_distances = [d/max_dist for d in crowding_distances]\n\n    # Select solution with highest normalized crowding distance\n    selected_idx = normalized_distances.index(max(normalized_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and edge inversion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Remove segment and insert it in a different position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Invert a random edge if beneficial\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.214813211547714,
            9.459354679299251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance and good Pareto dominance\n    crowding_distances = []\n    for sol, _ in archive:\n        # Calculate crowding distance (simplified)\n        total_distance = 0\n        for i in range(len(sol)-1):\n            total_distance += distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]]\n        crowding_distances.append(total_distance)\n\n    # Normalize crowding distances\n    max_dist = max(crowding_distances) if max(crowding_distances) != 0 else 1\n    normalized_distances = [d/max_dist for d in crowding_distances]\n\n    # Select solution with highest normalized crowding distance\n    selected_idx = normalized_distances.index(max(normalized_distances))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion and edge inversion\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Remove segment and insert it in a different position\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n    insert_pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Invert a random edge if beneficial\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This novel hybrid local search algorithm selects a solution from the archive based on both objective values and structural diversity, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum(np.std(objectives, axis=0))\n        if diversity > np.mean(np.std(objectives, axis=0)) * 1.5:\n            selected_idx = np.argmax(np.std(objectives, axis=0))\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Step 2: Perform a node insertion operation\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Check for improvement in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # If no improvement, revert to base solution\n    if (original_cost1 <= sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)) and\n        original_cost2 <= sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            9.154296745751587,
            9.733611060977994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.sum(np.std(objectives, axis=0))\n        if diversity > np.mean(np.std(objectives, axis=0)) * 1.5:\n            selected_idx = np.argmax(np.std(objectives, axis=0))\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Step 2: Perform a node insertion operation\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Check for improvement in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # If no improvement, revert to base solution\n    if (original_cost1 <= sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)) and\n        original_cost2 <= sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Rotate the selected segment\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while abs(k - l) <= 1:\n        l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.233881077762134,
            6.0290886758712805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    # Step 2: Rotate the selected segment\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    while abs(k - l) <= 1:\n        l = random.randint(0, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This new algorithm selects a solution from the archive by prioritizing those with high Pareto dominance, then applies a combination of node insertion and segment rotation operations to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance (simplified: prioritize those with better combined objective values)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        base_solution = archive_sorted[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Step 2: Rotate the segment (a, b, c) to (b, c, a)\n    segment = new_solution[a:c+1]\n    rotated = np.concatenate([segment[1:], segment[:1]])\n    new_solution[a:c+1] = rotated\n\n    # Step 3: Randomly insert a node from the segment elsewhere\n    if n > 3:\n        insert_pos = random.randint(0, n - 1)\n        node_to_insert = new_solution[a]\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        new_solution = np.delete(new_solution, a if a < insert_pos else a + 1)\n\n    return new_solution\n\n",
        "score": [
            6.407842125089877,
            6.530528661982407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance (simplified: prioritize those with better combined objective values)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        base_solution = archive_sorted[0][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Step 2: Rotate the segment (a, b, c) to (b, c, a)\n    segment = new_solution[a:c+1]\n    rotated = np.concatenate([segment[1:], segment[:1]])\n    new_solution[a:c+1] = rotated\n\n    # Step 3: Randomly insert a node from the segment elsewhere\n    if n > 3:\n        insert_pos = random.randint(0, n - 1)\n        node_to_insert = new_solution[a]\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        new_solution = np.delete(new_solution, a if a < insert_pos else a + 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and dominance, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for objective 1 and 2\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two segments and reverse one\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node and insert it at a better position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    # Find the best insertion position\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        if pos == k or pos == k - 1:\n            continue\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[pos+1]]\n        cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[pos+1]]\n        total_cost = weights[0] * cost1 + weights[1] * cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.319003356661469,
            6.535960789224223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for objective 1 and 2\n    scores = [(weights[0] * obj[0] + weights[1] * obj[1]) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two segments and reverse one\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 2: Randomly select a node and insert it at a better position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n\n    # Find the best insertion position\n    best_pos = 0\n    min_cost = float('inf')\n    for pos in range(n - 1):\n        if pos == k or pos == k - 1:\n            continue\n        temp_solution = np.insert(new_solution, pos, node)\n        cost1 = distance_matrix_1[temp_solution[pos-1], node] + distance_matrix_1[node, temp_solution[pos+1]]\n        cost2 = distance_matrix_2[temp_solution[pos-1], node] + distance_matrix_2[node, temp_solution[pos+1]]\n        total_cost = weights[0] * cost1 + weights[1] * cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted combination of Pareto dominance and diversity\n    weights = np.array([(obj[0] + obj[1]) / 2 for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Rotate segment\n    segment = new_solution[i:j+1]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated\n\n    # Insert edge\n    if k != i and k != j+1:\n        new_solution = np.insert(new_solution, k, new_solution[i])\n        new_solution = np.delete(new_solution, i)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            6.65129000381238,
            8.056098783376981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted combination of Pareto dominance and diversity\n    weights = np.array([(obj[0] + obj[1]) / 2 for _, obj in archive])\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search: segment rotation and edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Rotate segment\n    segment = new_solution[i:j+1]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j+1] = rotated\n\n    # Insert edge\n    if k != i and k != j+1:\n        new_solution = np.insert(new_solution, k, new_solution[i])\n        new_solution = np.delete(new_solution, i)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by diversity (sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments with a higher probability of longer segments\n    segment_length = max(2, int(n / 3))\n    i = random.randint(0, n - segment_length - 2)\n    j = random.randint(i + segment_length, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.573606065984825,
            10.475113843891501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by diversity (sum of objectives)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments with a higher probability of longer segments\n    segment_length = max(2, int(n / 3))\n    i = random.randint(0, n - segment_length - 2)\n    j = random.randint(i + segment_length, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{The new algorithm selects a solution from the archive by prioritizing those with high Pareto dominance, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(5, len(sorted_archive) - 1))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, j - i)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly select two edges and attempt insertion\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if k == l:\n        l = (l + 1) % n\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.435148607962995,
            6.088076109350113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = random.randint(0, min(5, len(sorted_archive) - 1))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Rotate the segment by a random amount\n    rotation = random.randint(1, j - i)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly select two edges and attempt insertion\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if k == l:\n        l = (l + 1) % n\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments with higher probability for longer segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment if it improves at least one objective\n    middle_segment = new_solution[i+1:j]\n    temp_solution = new_solution.copy()\n    temp_solution[i+1:j] = middle_segment[::-1]\n\n    # Calculate costs before and after reversal\n    cost_before1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n    cost_before2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n\n    cost_after1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n))\n    cost_after2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n))\n\n    if (cost_before1 < cost_after1) or (cost_before2 < cost_after2):\n        new_solution = temp_solution\n\n    # Step 3: Randomly swap two edges if beneficial for both objectives\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.5669181695487655,
            6.789947926152948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments with higher probability for longer segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment if it improves at least one objective\n    middle_segment = new_solution[i+1:j]\n    temp_solution = new_solution.copy()\n    temp_solution[i+1:j] = middle_segment[::-1]\n\n    # Calculate costs before and after reversal\n    cost_before1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n    cost_before2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(1, n))\n\n    cost_after1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(1, n))\n    cost_after2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(1, n))\n\n    if (cost_before1 < cost_after1) or (cost_before2 < cost_after2):\n        new_solution = temp_solution\n\n    # Step 3: Randomly swap two edges if beneficial for both objectives\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This novel algorithm prioritizes diverse solutions from the archive, then applies a combination of multi-segment reversal and adaptive edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective differences\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_diff = 0\n            for j in range(len(archive)):\n                if i != j:\n                    diff1 = abs(archive[i][1][0] - archive[j][1][0])\n                    diff2 = abs(archive[i][1][1] - archive[j][1][1])\n                    total_diff += diff1 + diff2\n            diversity_scores.append(total_diff)\n        selected_idx = diversity_scores.index(max(diversity_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select multiple non-adjacent segments and reverse them\n    num_segments = random.randint(1, min(3, n//4))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    for i in range(0, len(segment_indices), 2):\n        start = segment_indices[i]\n        end = segment_indices[i+1]\n        if start < end:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive edge insertion based on objective improvements\n    for _ in range(min(3, n//2)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            7.499370433536063,
            7.299837529264422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on objective differences\n        diversity_scores = []\n        for i in range(len(archive)):\n            total_diff = 0\n            for j in range(len(archive)):\n                if i != j:\n                    diff1 = abs(archive[i][1][0] - archive[j][1][0])\n                    diff2 = abs(archive[i][1][1] - archive[j][1][1])\n                    total_diff += diff1 + diff2\n            diversity_scores.append(total_diff)\n        selected_idx = diversity_scores.index(max(diversity_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select multiple non-adjacent segments and reverse them\n    num_segments = random.randint(1, min(3, n//4))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    for i in range(0, len(segment_indices), 2):\n        start = segment_indices[i]\n        end = segment_indices[i+1]\n        if start < end:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Adaptive edge insertion based on objective improvements\n    for _ in range(min(3, n//2)):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a hybrid of segment reversal and edge insertion operations to generate a neighbor solution while balancing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Weighted score combining Pareto dominance and diversity\n        dominance_score = obj[0] * obj[1]  # Product of objectives\n        diversity_score = (obj[0] - obj[1])**2  # Diversity measure\n        scores.append(dominance_score + diversity_score)\n\n    selected_idx = np.argmax(scores) if scores else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Segment reversal with objective-aware selection\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate potential improvement\n    original_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n\n    reversed_segment = new_solution[i+1:j+1].copy()\n    new_solution[i+1:j+1] = reversed_segment[::-1]\n\n    new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # Step 2: Edge insertion if beneficial for both objectives\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:\n        pass  # Keep reversal\n    else:\n        new_solution[i+1:j+1] = reversed_segment  # Revert\n\n    # Step 3: Edge insertion with objective balancing\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate potential improvement for both objectives\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective with probability\n    if (new_cost1 < current_cost1 and random.random() < 0.7) or (new_cost2 < current_cost2 and random.random() < 0.7):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.475885253656738,
            10.521048137711446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Weighted score combining Pareto dominance and diversity\n        dominance_score = obj[0] * obj[1]  # Product of objectives\n        diversity_score = (obj[0] - obj[1])**2  # Diversity measure\n        scores.append(dominance_score + diversity_score)\n\n    selected_idx = np.argmax(scores) if scores else 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search operator\n    # Step 1: Segment reversal with objective-aware selection\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Calculate potential improvement\n    original_cost1 = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n))\n\n    reversed_segment = new_solution[i+1:j+1].copy()\n    new_solution[i+1:j+1] = reversed_segment[::-1]\n\n    new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n    # Step 2: Edge insertion if beneficial for both objectives\n    if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:\n        pass  # Keep reversal\n    else:\n        new_solution[i+1:j+1] = reversed_segment  # Revert\n\n    # Step 3: Edge insertion with objective balancing\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate potential improvement for both objectives\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective with probability\n    if (new_cost1 < current_cost1 and random.random() < 0.7) or (new_cost2 < current_cost2 and random.random() < 0.7):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{The new algorithm prioritizes solutions with high objective diversity by selecting a base solution from the archive, then applies a combination of segment insertion and edge flipping operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 2, n - 2)\n    c = random.randint(0, n - 1)\n\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Apply edge flipping if beneficial\n    i = random.randint(1, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.94747748784323,
            9.135706123465795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    a = random.randint(0, n - 4)\n    b = random.randint(a + 2, n - 2)\n    c = random.randint(0, n - 1)\n\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Apply edge flipping if beneficial\n    i = random.randint(1, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its objective diversity and applies a combination of edge insertion and segment rotation operations to generate a neighbor solution, while ensuring feasibility through a greedy validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution based on objective diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) == 1:\n        selected_idx = 0\n    else:\n        # Select the solution with the most diverse objectives\n        diversity = np.sum(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n        selected_idx = np.argmax(diversity)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - i - 1))\n    segment = new_solution[i:i+segment_length]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:i+segment_length] = rotated_segment\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_to_move = random.randint(0, n - 1)\n    node_value = new_solution[node_to_move]\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    # Step 3: Greedy validation to ensure feasibility\n    for i in range(n):\n        if new_solution[i] not in base_solution:\n            # Find a valid position to reinsert the missing node\n            missing_node = [node for node in base_solution if node not in new_solution][0]\n            insert_pos = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, insert_pos, missing_node)\n            break\n\n    return new_solution\n\n",
        "score": [
            7.744572050359011,
            8.69151178893523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution based on objective diversity\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) == 1:\n        selected_idx = 0\n    else:\n        # Select the solution with the most diverse objectives\n        diversity = np.sum(np.abs(objectives - np.mean(objectives, axis=0)), axis=1)\n        selected_idx = np.argmax(diversity)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - i - 1))\n    segment = new_solution[i:i+segment_length]\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:i+segment_length] = rotated_segment\n\n    # Step 2: Insert a randomly selected node at a new position\n    node_to_move = random.randint(0, n - 1)\n    node_value = new_solution[node_to_move]\n    new_solution = np.delete(new_solution, node_to_move)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_value)\n\n    # Step 3: Greedy validation to ensure feasibility\n    for i in range(n):\n        if new_solution[i] not in base_solution:\n            # Find a valid position to reinsert the missing node\n            missing_node = [node for node in base_solution if node not in new_solution][0]\n            insert_pos = random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, insert_pos, missing_node)\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining segment insertion and edge rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 2: Find a position to insert the segment\n    k = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Step 3: Rotate a random edge if beneficial\n    m = random.randint(0, n - 1)\n    p = (m + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p], new_solution[(p+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[m], new_solution[(p+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p], new_solution[(p+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[m], new_solution[(p+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            6.236999062896412,
            6.933100785467166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n\n    segment = new_solution[i:j+1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n    # Step 2: Find a position to insert the segment\n    k = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n    # Step 3: Rotate a random edge if beneficial\n    m = random.randint(0, n - 1)\n    p = (m + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p], new_solution[(p+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[m], new_solution[(p+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p], new_solution[(p+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[m], new_solution[(p+1)%n]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{The new algorithm selects a solution from the archive based on its objective diversity, then applies a novel combination of segment rotation and path inversion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(np.linalg.norm(diversity))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 5)\n    j = random.randint(i + 3, n - 1)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Invert a random path segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 2, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.541511695324868,
            8.04383462606785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(np.linalg.norm(diversity))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 5)\n    j = random.randint(i + 3, n - 1)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j] = rotated_segment\n\n    # Step 2: Invert a random path segment if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 2, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on both objective diversity and solution quality, then applies a combination of segment insertion, node relocation, and dynamic edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity and quality scores\n        objectives = [obj for _, obj in archive]\n        diversity_scores = [np.std([obj[0] for obj in objectives]) + np.std([obj[1] for obj in objectives]) for _ in archive]\n        quality_scores = [np.mean(obj) for _, obj in archive]\n        combined_scores = [diversity_scores[i] + quality_scores[i] for i in range(len(archive))]\n        selected_idx = np.argmax(combined_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Step 2: Node relocation with objective-aware selection\n    node_idx = random.randint(0, n - 1)\n    pos = random.randint(0, n - 2)\n\n    # Calculate potential cost change\n    old_pos = np.where(new_solution == new_solution[node_idx])[0][0]\n    old_neighbors = [new_solution[old_pos-1], new_solution[(old_pos+1)%n]]\n    new_neighbors = [new_solution[pos-1], new_solution[(pos+1)%n]]\n\n    old_cost1 = distance_matrix_1[old_neighbors[0], new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], old_neighbors[1]]\n    new_cost1 = distance_matrix_1[new_neighbors[0], new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], new_neighbors[1]]\n\n    old_cost2 = distance_matrix_2[old_neighbors[0], new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], old_neighbors[1]]\n    new_cost2 = distance_matrix_2[new_neighbors[0], new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], new_neighbors[1]]\n\n    # Apply relocation if beneficial for both objectives\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Dynamic edge swapping with adaptive probability\n    swap_prob = 0.7 if (archive[selected_idx][1][0] > np.median([obj[0] for _, obj in archive]) or\n                        archive[selected_idx][1][1] > np.median([obj[1] for _, obj in archive])) else 0.3\n\n    if random.random() < swap_prob:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.350753346113956,
            10.370709828957864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity and quality scores\n        objectives = [obj for _, obj in archive]\n        diversity_scores = [np.std([obj[0] for obj in objectives]) + np.std([obj[1] for obj in objectives]) for _ in archive]\n        quality_scores = [np.mean(obj) for _, obj in archive]\n        combined_scores = [diversity_scores[i] + quality_scores[i] for i in range(len(archive))]\n        selected_idx = np.argmax(combined_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Step 2: Node relocation with objective-aware selection\n    node_idx = random.randint(0, n - 1)\n    pos = random.randint(0, n - 2)\n\n    # Calculate potential cost change\n    old_pos = np.where(new_solution == new_solution[node_idx])[0][0]\n    old_neighbors = [new_solution[old_pos-1], new_solution[(old_pos+1)%n]]\n    new_neighbors = [new_solution[pos-1], new_solution[(pos+1)%n]]\n\n    old_cost1 = distance_matrix_1[old_neighbors[0], new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], old_neighbors[1]]\n    new_cost1 = distance_matrix_1[new_neighbors[0], new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], new_neighbors[1]]\n\n    old_cost2 = distance_matrix_2[old_neighbors[0], new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], old_neighbors[1]]\n    new_cost2 = distance_matrix_2[new_neighbors[0], new_solution[node_idx]] + distance_matrix_2[new_solution[node_idx], new_neighbors[1]]\n\n    # Apply relocation if beneficial for both objectives\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:old_pos], new_solution[old_pos+1:]])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Dynamic edge swapping with adaptive probability\n    swap_prob = 0.7 if (archive[selected_idx][1][0] > np.median([obj[0] for _, obj in archive]) or\n                        archive[selected_idx][1][1] > np.median([obj[1] for _, obj in archive])) else 0.3\n\n    if random.random() < swap_prob:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Prioritize top 3 solutions\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a random position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly reverse a segment if beneficial\n    k = random.randint(0, n - 4)\n    l = random.randint(k + 2, n - 2)\n\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    reversed_segment = new_solution[k:l+1][::-1]\n    new_solution[k:l+1] = reversed_segment\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    if (new_cost1 > current_cost1) and (new_cost2 > current_cost2):\n        new_solution[k:l+1] = reversed_segment[::-1]  # Revert if not beneficial\n\n    return new_solution\n\n",
        "score": [
            7.1862392543758435,
            6.829854891612288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average objective\n        selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Prioritize top 3 solutions\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j+1]\n\n    # Step 2: Remove the segment and insert it at a random position\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly reverse a segment if beneficial\n    k = random.randint(0, n - 4)\n    l = random.randint(k + 2, n - 2)\n\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    reversed_segment = new_solution[k:l+1][::-1]\n    new_solution[k:l+1] = reversed_segment\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    if (new_cost1 > current_cost1) and (new_cost2 > current_cost2):\n        new_solution[k:l+1] = reversed_segment[::-1]  # Revert if not beneficial\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on crowding distance and applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 5)\n    j = random.randint(i + 3, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Apply edge insertion\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[l:], new_solution[k+1:l]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            8.966964337210815,
            8.753536896968225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 5)\n    j = random.randint(i + 3, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.roll(segment, rotation)\n\n    # Apply edge insertion\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n    if random.random() < 0.5:\n        new_solution = np.concatenate([new_solution[:k+1], new_solution[l:], new_solution[k+1:l]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            9.91024487188334,
            10.020185275016965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0))\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n    segment = new_solution[start:end]\n\n    # Step 2: Insert the segment at a different position\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:start],\n        new_solution[end:]\n    ])\n\n    # Step 3: Apply a conditional edge swap\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate cost differences\n    delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n              distance_matrix_1[new_solution[b-1], new_solution[a]] -\n              distance_matrix_1[new_solution[a-1], new_solution[a]] -\n              distance_matrix_1[new_solution[b-1], new_solution[b]])\n\n    delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n              distance_matrix_2[new_solution[b-1], new_solution[a]] -\n              distance_matrix_2[new_solution[a-1], new_solution[a]] -\n              distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n    # Apply swap if beneficial for at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            10.201927124242085,
            10.496273518314432
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: sum(archive[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n    segment = new_solution[start:end]\n\n    # Step 2: Insert the segment at a different position\n    insert_pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([\n        new_solution[:insert_pos],\n        segment,\n        new_solution[insert_pos:start],\n        new_solution[end:]\n    ])\n\n    # Step 3: Apply a conditional edge swap\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    # Calculate cost differences\n    delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n              distance_matrix_1[new_solution[b-1], new_solution[a]] -\n              distance_matrix_1[new_solution[a-1], new_solution[a]] -\n              distance_matrix_1[new_solution[b-1], new_solution[b]])\n\n    delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n              distance_matrix_2[new_solution[b-1], new_solution[a]] -\n              distance_matrix_2[new_solution[a-1], new_solution[a]] -\n              distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n    # Apply swap if beneficial for at least one objective\n    if delta1 < 0 or delta2 < 0:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive with the highest combined objective value, then applies a segment insertion and edge reversal hybrid operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment insertion and edge reversal\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Insert segment [a:b] between c and d\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:d], new_solution[d:]])\n\n    # Reverse a random segment\n    i, j = sorted(random.sample(range(len(new_solution)), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure no duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) < n:\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.532339235688022,
            10.641870438752807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment insertion and edge reversal\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Insert segment [a:b] between c and d\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:d], new_solution[d:]])\n\n    # Reverse a random segment\n    i, j = sorted(random.sample(range(len(new_solution)), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure no duplicates\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) < n:\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n        selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 4 candidates\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = (l + 2) % n\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the insertion\n        if k < l:\n            new_solution = np.concatenate([new_solution[:k+1], new_solution[l:l+1], new_solution[k+1:l], new_solution[l+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:l+1], new_solution[k:k+1], new_solution[l+1:k], new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.88378353134089,
            6.485515853551223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n        selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 4 candidates\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Rotate the segment\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert an edge from another part of the tour\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if l == k or l == (k + 1) % n or l == (k - 1) % n:\n        l = (l + 2) % n\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k], new_solution[l]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k], new_solution[l]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[(l+1)%n]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        # Perform the insertion\n        if k < l:\n            new_solution = np.concatenate([new_solution[:k+1], new_solution[l:l+1], new_solution[k+1:l], new_solution[l+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:l+1], new_solution[k:k+1], new_solution[l+1:k], new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of segment reversal and edge exchange operations, while also incorporating a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values to find diverse solutions\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, len(archive)//2, len(archive)-1])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Probabilistic acceptance based on cost improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.848198148785548,
            7.921667907319833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by objective values to find diverse solutions\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        selected_idx = random.choice([0, len(archive)//2, len(archive)-1])\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Apply edge exchange with probability\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Probabilistic acceptance based on cost improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (new_cost1 < current_cost1 or new_cost2 < current_cost2)):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{A novel hybrid local search algorithm selects a high-quality solution from the archive by prioritizing those with lower total cost in both objectives, then applies a combination of segment reversal and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 1)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select an edge to insert elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.288256220924937,
            6.440009859406991
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 1)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select an edge to insert elsewhere\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{A new hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        # Calculate crowding distances for diversity\n        for i in range(2):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n        # Combine dominance and diversity\n        scores = crowding_distances + np.random.rand(len(archive)) * 0.1  # Small random perturbation\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.282159105095172,
            7.281701040394687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        # Calculate crowding distances for diversity\n        for i in range(2):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_indices[j]] += (objectives[sorted_indices[j+1], i] - objectives[sorted_indices[j-1], i])\n\n        # Combine dominance and diversity\n        scores = crowding_distances + np.random.rand(len(archive)) * 0.1  # Small random perturbation\n        selected_idx = np.argmax(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a combined Pareto dominance and crowding distance metric, then applies a novel segment insertion and edge rotation operator to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol):\n        obj1, obj2 = sol[1]\n        dominated = sum(1 for (_, (o1, o2)) in archive if (o1 <= obj1 and o2 <= obj2) and (o1 < obj1 or o2 < obj2))\n        return -dominated  # Higher score is better\n\n    def crowding_distance(sol):\n        objs = [s[1] for s in archive]\n        obj1, obj2 = sol[1]\n        sorted1 = sorted(objs, key=lambda x: x[0])\n        sorted2 = sorted(objs, key=lambda x: x[1])\n        idx1 = sorted1.index((obj1, obj2))\n        idx2 = sorted2.index((obj1, obj2))\n        return (sorted1[idx1+1][0] - sorted1[idx1-1][0] if 0 < idx1 < len(objs)-1 else 0) + \\\n               (sorted2[idx2+1][1] - sorted2[idx2-1][1] if 0 < idx2 < len(objs)-1 else 0)\n\n    scores = [(i, dominance_score(s) + 0.1 * crowding_distance(s)) for i, s in enumerate(archive)]\n    selected_idx = max(scores, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Novel local search operator: segment insertion with edge rotation\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a or abs(b - a) < 2:\n        b = random.randint(0, n-1)\n\n    # Extract segment and rotate it\n    segment = new_solution[min(a,b):max(a,b)]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Insert rotated segment at a new position\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated, new_solution[pos:]])\n\n    # Remove duplicates (ensuring TSP validity)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            7.331771991529755,
            7.384020477835017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol):\n        obj1, obj2 = sol[1]\n        dominated = sum(1 for (_, (o1, o2)) in archive if (o1 <= obj1 and o2 <= obj2) and (o1 < obj1 or o2 < obj2))\n        return -dominated  # Higher score is better\n\n    def crowding_distance(sol):\n        objs = [s[1] for s in archive]\n        obj1, obj2 = sol[1]\n        sorted1 = sorted(objs, key=lambda x: x[0])\n        sorted2 = sorted(objs, key=lambda x: x[1])\n        idx1 = sorted1.index((obj1, obj2))\n        idx2 = sorted2.index((obj1, obj2))\n        return (sorted1[idx1+1][0] - sorted1[idx1-1][0] if 0 < idx1 < len(objs)-1 else 0) + \\\n               (sorted2[idx2+1][1] - sorted2[idx2-1][1] if 0 < idx2 < len(objs)-1 else 0)\n\n    scores = [(i, dominance_score(s) + 0.1 * crowding_distance(s)) for i, s in enumerate(archive)]\n    selected_idx = max(scores, key=lambda x: x[1])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Novel local search operator: segment insertion with edge rotation\n    a = random.randint(0, n-1)\n    b = random.randint(0, n-1)\n    while b == a or abs(b - a) < 2:\n        b = random.randint(0, n-1)\n\n    # Extract segment and rotate it\n    segment = new_solution[min(a,b):max(a,b)]\n    rotated = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Insert rotated segment at a new position\n    pos = random.randint(0, n-1)\n    new_solution = np.concatenate([new_solution[:pos], rotated, new_solution[pos:]])\n\n    # Remove duplicates (ensuring TSP validity)\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment insertion and edge exchange\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Insert segment at a different position\n    pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates while maintaining tour validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Edge exchange based on both objectives\n    a, b = random.sample(range(n), 2)\n    c, d = random.sample(range(n), 2)\n\n    cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    cost2_before = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    cost2_after = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]]\n\n    if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            10.455729685289334,
            10.641231646185492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search: segment insertion and edge exchange\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Insert segment at a different position\n    pos = random.randint(0, n - len(segment))\n    new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n    # Remove duplicates while maintaining tour validity\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        new_solution = np.concatenate([unique_nodes, missing_nodes])\n\n    # Edge exchange based on both objectives\n    a, b = random.sample(range(n), 2)\n    c, d = random.sample(range(n), 2)\n\n    cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    cost2_before = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    cost2_after = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[d-1], new_solution[c]]\n\n    if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with probability 0.7\n    if random.random() < 0.7:\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.037812079962528,
            6.406569024271761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment with probability 0.7\n    if random.random() < 0.7:\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{A novel hybrid local search algorithm that selects a diverse solution from the archive and applies a combination of edge inversion and segment rotation to generate a neighbor solution while ensuring feasibility by maintaining node uniqueness and tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values to find diverse ones\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a middle solution to encourage diversity\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Rotate the selected segment\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly invert a sub-segment if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply inversion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.613562747058561,
            6.260761936473037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values to find diverse ones\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        # Select a middle solution to encourage diversity\n        selected_idx = len(sorted_archive) // 2\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n\n    # Step 2: Rotate the selected segment\n    segment = new_solution[i:j+1]\n    rotation = random.randint(1, len(segment)-1)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Randomly invert a sub-segment if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n\n    # Apply inversion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of node insertion, segment rotation, and edge inversion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], abs(x[1][0] - x[1][1])), reverse=True)\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_segment = np.roll(segment, rotation)\n    new_solution[i:j] = new_segment\n\n    # Step 2: Randomly select a node and insert it in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Randomly invert a pair of edges if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            9.602723510471622,
            9.848938538350408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], abs(x[1][0] - x[1][1])), reverse=True)\n    selected_idx = random.randint(0, min(3, len(archive_sorted) - 1))  # Select from top 3 candidates\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment) - 1)\n    new_segment = np.roll(segment, rotation)\n    new_solution[i:j] = new_segment\n\n    # Step 2: Randomly select a node and insert it in a different position\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Randomly invert a pair of edges if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a weighted combination of objective values and dominance count, then applies a combination of edge exchange and segment reversal operations with adaptive segment sizes to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate weighted score (0.6 for first objective, 0.4 for second)\n        score = 0.6 * obj[0] + 0.4 * obj[1]\n        # Add dominance count (approximate by comparing to other solutions)\n        dominance = sum(1 for s, o in archive if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        scores.append(score + dominance * 0.1)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n // 3, 5))\n    i = random.randint(0, n - segment_size - 2)\n    j = i + segment_size\n\n    # Reverse segment with higher probability if it improves at least one objective\n    if random.random() < 0.7:\n        segment = new_solution[i:j]\n        new_segment = segment[::-1]\n        new_solution[i:j] = new_segment\n\n        # Check if improvement in at least one objective\n        old_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        new_cost1 = sum(distance_matrix_1[new_segment[k-1], new_segment[k]] for k in range(1, len(new_segment)))\n        old_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        new_cost2 = sum(distance_matrix_2[new_segment[k-1], new_segment[k]] for k in range(1, len(new_segment)))\n\n        if not ((new_cost1 < old_cost1) or (new_cost2 < old_cost2)):\n            new_solution[i:j] = segment\n\n    # Edge exchange with probability based on solution quality\n    if random.random() < 0.4:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.461298762437917,
            10.628176811846004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Calculate weighted score (0.6 for first objective, 0.4 for second)\n        score = 0.6 * obj[0] + 0.4 * obj[1]\n        # Add dominance count (approximate by comparing to other solutions)\n        dominance = sum(1 for s, o in archive if (o[0] <= obj[0] and o[1] < obj[1]) or (o[0] < obj[0] and o[1] <= obj[1]))\n        scores.append(score + dominance * 0.1)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment selection\n    segment_size = max(2, min(n // 3, 5))\n    i = random.randint(0, n - segment_size - 2)\n    j = i + segment_size\n\n    # Reverse segment with higher probability if it improves at least one objective\n    if random.random() < 0.7:\n        segment = new_solution[i:j]\n        new_segment = segment[::-1]\n        new_solution[i:j] = new_segment\n\n        # Check if improvement in at least one objective\n        old_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        new_cost1 = sum(distance_matrix_1[new_segment[k-1], new_segment[k]] for k in range(1, len(new_segment)))\n        old_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n        new_cost2 = sum(distance_matrix_2[new_segment[k-1], new_segment[k]] for k in range(1, len(new_segment)))\n\n        if not ((new_cost1 < old_cost1) or (new_cost2 < old_cost2)):\n            new_solution[i:j] = segment\n\n    # Edge exchange with probability based on solution quality\n    if random.random() < 0.4:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This novel algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of adaptive segment insertion and multi-objective edge swapping to generate improved neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate dominance scores (simplified for this example)\n    dominance_scores = []\n    for sol, obj in archive:\n        score = obj[0] * 0.3 + obj[1] * 0.7  # Weighted sum for diversity\n        dominance_scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment insertion\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    segment = new_solution[a:b]\n\n    # Insert the segment at a different position\n    c = random.randint(0, n-1)\n    if c < a:\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:a], new_solution[b:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform multiple swaps\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]])\n\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Apply swap if beneficial for both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            7.924551269609163,
            10.113964376781007
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate dominance scores (simplified for this example)\n    dominance_scores = []\n    for sol, obj in archive:\n        score = obj[0] * 0.3 + obj[1] * 0.7  # Weighted sum for diversity\n        dominance_scores.append(score)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(dominance_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment insertion\n    a = random.randint(0, n-2)\n    b = random.randint(a+1, n-1)\n    segment = new_solution[a:b]\n\n    # Insert the segment at a different position\n    c = random.randint(0, n-1)\n    if c < a:\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:a], new_solution[b:]])\n    else:\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:c], segment, new_solution[c:]])\n\n    # Multi-objective edge swapping\n    for _ in range(3):  # Perform multiple swaps\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j-1], new_solution[i]])\n\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Apply swap if beneficial for both objectives\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a novel hybrid local search combining segment insertion and edge re-routing operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(objectives, axis=0) - np.mean(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Select a random segment to extract\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n    segment = new_solution[start:end]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Apply edge re-routing for both objectives\n    for _ in range(2):\n        if len(new_solution) < 3:\n            break\n        a = random.randint(0, len(new_solution) - 2)\n        b = random.randint(a + 1, len(new_solution) - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.8213176859239315,
            6.176419619250037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high Pareto dominance or diverse objectives\n    objectives = np.array([obj for _, obj in archive])\n    selected_idx = np.argmax(np.min(objectives, axis=0) - np.mean(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Step 1: Select a random segment to extract\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, min(start + 3, n - 1))\n    segment = new_solution[start:end]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Apply edge re-routing for both objectives\n    for _ in range(2):\n        if len(new_solution) < 3:\n            break\n        a = random.randint(0, len(new_solution) - 2)\n        b = random.randint(a + 1, len(new_solution) - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange, segment reversal, and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol_obj):\n        count = 0\n        for _, obj in archive:\n            if obj[0] <= sol_obj[0] and obj[1] <= sol_obj[1] and (obj[0] < sol_obj[0] or obj[1] < sol_obj[1]):\n                count += 1\n        return count\n\n    archive_with_scores = [(sol, obj, dominance_score(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2], reverse=True)\n    selected_sol, _, _ = archive_with_scores[0]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Randomly swap two edges if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n",
        "score": [
            8.697999249697194,
            8.765784404526336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(sol_obj):\n        count = 0\n        for _, obj in archive:\n            if obj[0] <= sol_obj[0] and obj[1] <= sol_obj[1] and (obj[0] < sol_obj[0] or obj[1] < sol_obj[1]):\n                count += 1\n        return count\n\n    archive_with_scores = [(sol, obj, dominance_score(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: x[2], reverse=True)\n    selected_sol, _, _ = archive_with_scores[0]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select a node to insert elsewhere\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Randomly swap two edges if beneficial\n    m = random.randint(0, n - 2)\n    p = random.randint(m + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[m-1], new_solution[m]] + distance_matrix_1[new_solution[p-1], new_solution[p]]\n    new_cost1 = distance_matrix_1[new_solution[m-1], new_solution[p]] + distance_matrix_1[new_solution[p-1], new_solution[m]]\n\n    current_cost2 = distance_matrix_2[new_solution[m-1], new_solution[m]] + distance_matrix_2[new_solution[p-1], new_solution[p]]\n    new_cost2 = distance_matrix_2[new_solution[m-1], new_solution[p]] + distance_matrix_2[new_solution[p-1], new_solution[m]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[m], new_solution[p] = new_solution[p], new_solution[m]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on both objective values and diversity, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find solution with highest sum of objectives (diverse)\n        selected_idx = np.argmax([sum(obj) for obj in objectives])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Step 2: Rotate the segment (a,b,c) to (b,c,a)\n    segment = new_solution[a:c+1]\n    rotated = np.concatenate([segment[1:], segment[:1]])\n    new_solution[a:c+1] = rotated\n\n    # Step 3: Randomly insert a node from another position\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            10.537102216522314,
            10.652980130321575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) > 1:\n        # Find solution with highest sum of objectives (diverse)\n        selected_idx = np.argmax([sum(obj) for obj in objectives])\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    c = random.randint(b + 1, n - 1)\n\n    # Step 2: Rotate the segment (a,b,c) to (b,c,a)\n    segment = new_solution[a:c+1]\n    rotated = np.concatenate([segment[1:], segment[:1]])\n    new_solution[a:c+1] = rotated\n\n    # Step 3: Randomly insert a node from another position\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i != j:\n        node = new_solution[j]\n        new_solution = np.delete(new_solution, j)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel local search algorithm selects a solution from the archive with high objective diversity, then applies a combination of node insertion and segment rotation operations to generate a neighbor while ensuring feasibility, prioritizing improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated_segment\n\n    # Apply node insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.384802218186774,
            8.459725903246214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment rotation\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[i:j] = rotated_segment\n\n    # Apply node insertion\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l:\n        node = new_solution[l]\n        new_solution = np.concatenate([new_solution[:l], new_solution[l+1:]])\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This new algorithm prioritizes solutions with high crowding distance in the objective space, then applies a combination of node relocation and segment insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += objectives[sorted_idx[j+1]][i] - objectives[sorted_idx[j-1]][i]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Step 2: Find best insertion position\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n            continue\n\n        # Calculate cost difference\n        prev_node = new_solution[(pos - 1) % n]\n        next_node = new_solution[pos % n]\n\n        current_cost = distance_matrix_1[prev_node, new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], next_node]\n        new_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n\n        improvement = current_cost - new_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove node from current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Randomly reverse a segment if beneficial\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i], new_solution[j-1]] + distance_matrix_1[new_solution[i+1], new_solution[j]]\n\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i], new_solution[j-1]] + distance_matrix_2[new_solution[i+1], new_solution[j]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            8.862018487647202,
            9.308311393639123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Calculate crowding distance for each solution\n    objectives = [obj for _, obj in archive]\n    crowding = np.zeros(len(archive))\n\n    for i in range(2):  # For each objective\n        sorted_idx = np.argsort([obj[i] for obj in objectives])\n        for j in range(1, len(archive)-1):\n            crowding[sorted_idx[j]] += objectives[sorted_idx[j+1]][i] - objectives[sorted_idx[j-1]][i]\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a node to relocate\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Step 2: Find best insertion position\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n            continue\n\n        # Calculate cost difference\n        prev_node = new_solution[(pos - 1) % n]\n        next_node = new_solution[pos % n]\n\n        current_cost = distance_matrix_1[prev_node, new_solution[node_idx]] + distance_matrix_1[new_solution[node_idx], next_node]\n        new_cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n\n        improvement = current_cost - new_cost\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove node from current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Step 3: Randomly reverse a segment if beneficial\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n    new_cost1 = distance_matrix_1[new_solution[i], new_solution[j-1]] + distance_matrix_1[new_solution[i+1], new_solution[j]]\n\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n    new_cost2 = distance_matrix_2[new_solution[i], new_solution[j-1]] + distance_matrix_2[new_solution[i+1], new_solution[j]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        middle_segment = new_solution[i+1:j]\n        new_solution[i+1:j] = middle_segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two segments and swap them\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1])\n\n    # Step 2: Randomly reverse a segment if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.55271442886621,
            8.289328369110398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_diversity = -1\n    selected_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two segments and swap them\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:]\n\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1])\n\n    # Step 2: Randomly reverse a segment if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of random segment insertion and edge inversion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply random segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Find insertion point that minimizes the maximum objective increase\n    best_pos = -1\n    best_diff = float('inf')\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        # Create temporary insertion\n        temp = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n        if len(temp) > n:\n            temp = temp[:n]\n\n        # Calculate cost difference\n        cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n        cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n        original_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[k+1]] for k in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n        original_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[k+1]] for k in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n\n        diff = max(cost1 - original_cost1, cost2 - original_cost2)\n\n        if diff < best_diff:\n            best_diff = diff\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n    # Apply edge inversion if beneficial\n    if n >= 4:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.307042288892264,
            10.716148849961296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply random segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    segment = new_solution[i:j+1]\n\n    # Find insertion point that minimizes the maximum objective increase\n    best_pos = -1\n    best_diff = float('inf')\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        # Create temporary insertion\n        temp = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:]\n        ])\n        if len(temp) > n:\n            temp = temp[:n]\n\n        # Calculate cost difference\n        cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n        cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n        original_cost1 = sum(distance_matrix_1[base_solution[k], base_solution[k+1]] for k in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n        original_cost2 = sum(distance_matrix_2[base_solution[k], base_solution[k+1]] for k in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n\n        diff = max(cost1 - original_cost1, cost2 - original_cost2)\n\n        if diff < best_diff:\n            best_diff = diff\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n        if len(new_solution) > n:\n            new_solution = new_solution[:n]\n\n    # Apply edge inversion if beneficial\n    if n >= 4:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange, segment reversal, and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (diversity)\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select top 30% of diverse solutions\n        top_solutions = sorted_solutions[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator: segment reversal, edge exchange, and node insertion\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select a node and insert it in a different position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    insert_pos = random.randint(0, n - 1)\n    if insert_pos > node_idx:\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:insert_pos], [node], new_solution[insert_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:node_idx], new_solution[node_idx+1:]])\n\n    # Step 4: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.23985277207847,
            6.330222315261521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (diversity)\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select top 30% of diverse solutions\n        top_solutions = sorted_solutions[:max(1, len(archive) // 3)]\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator: segment reversal, edge exchange, and node insertion\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select a node and insert it in a different position\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n    insert_pos = random.randint(0, n - 1)\n    if insert_pos > node_idx:\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:insert_pos], [node], new_solution[insert_pos:]])\n    else:\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:node_idx], new_solution[node_idx+1:]])\n\n    # Step 4: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This algorithm selects a solution from the archive based on its objective diversity and applies a novel segment rotation operation combined with a conditional edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for i in range(len(objectives)):\n        obj1 = objectives[i]\n        diversity = 0\n        for j in range(len(objectives)):\n            if i != j:\n                obj2 = objectives[j]\n                diversity += abs(obj1[0] - obj2[0]) + abs(obj1[1] - obj2[1])\n        diversity_scores.append(diversity)\n\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(1, j - i)\n\n    # Step 2: Rotate the segment\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Conditionally insert a node based on cost improvement\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            7.4402105469275455,
            7.320437837069899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Calculate diversity scores\n    diversity_scores = []\n    for i in range(len(objectives)):\n        obj1 = objectives[i]\n        diversity = 0\n        for j in range(len(objectives)):\n            if i != j:\n                obj2 = objectives[j]\n                diversity += abs(obj1[0] - obj2[0]) + abs(obj1[1] - obj2[1])\n        diversity_scores.append(diversity)\n\n    selected_idx = diversity_scores.index(max(diversity_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    k = random.randint(1, j - i)\n\n    # Step 2: Rotate the segment\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k:], segment[:k]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 3: Conditionally insert a node based on cost improvement\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a != b:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Apply insertion if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of objective diversity and dominance, then applies a sequence of edge relinking and segment insertion operations to generate a neighbor solution while ensuring feasibility through careful validation of tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest combined objective diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relink\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n\n    # Step 2: Extract and reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Step 3: Insert the reversed segment at a different position\n    insert_pos = random.randint(0, n - len(segment))\n    if insert_pos < a:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:a],\n            new_solution[b+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[b+1:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Step 4: Validate and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.613669241059686,
            7.899576806204905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.array([])\n\n    # Select solution with highest combined objective diversity\n    selected_idx = 0\n    max_diversity = -1\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diversity = abs(cost1 - cost2)\n        if diversity > max_diversity:\n            max_diversity = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to relink\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n\n    # Step 2: Extract and reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Step 3: Insert the reversed segment at a different position\n    insert_pos = random.randint(0, n - len(segment))\n    if insert_pos < a:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:a],\n            new_solution[b+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[b+1:insert_pos],\n            reversed_segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Step 4: Validate and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This novel algorithm selects a solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of segment rotation and node insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions that are non-dominated or have diverse objectives\n        dominated_counts = [sum(1 for _, obj in archive if obj[0] <= obj2[0] and obj[1] <= obj2[1] and (obj[0] < obj2[0] or obj[1] < obj2[1])) for _, obj2 in archive]\n        selected_idx = np.argmin(dominated_counts)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotate_amount = random.randint(1, len(segment) - 1)\n    segment = np.roll(segment, rotate_amount)\n    new_solution[i:j] = segment\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n - 1)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Step 3: Check if the move improves at least one objective\n    old_cost1 = archive[selected_idx][1][0]\n    old_cost2 = archive[selected_idx][1][1]\n\n    new_cost1 = 0\n    new_cost2 = 0\n    for idx in range(n):\n        new_cost1 += distance_matrix_1[new_solution[idx-1], new_solution[idx]]\n        new_cost2 += distance_matrix_2[new_solution[idx-1], new_solution[idx]]\n\n    # Only keep the new solution if it improves at least one objective\n    if (new_cost1 <= old_cost1) or (new_cost2 <= old_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            6.151899520178915,
            8.122546864984125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions that are non-dominated or have diverse objectives\n        dominated_counts = [sum(1 for _, obj in archive if obj[0] <= obj2[0] and obj[1] <= obj2[1] and (obj[0] < obj2[0] or obj[1] < obj2[1])) for _, obj2 in archive]\n        selected_idx = np.argmin(dominated_counts)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotate_amount = random.randint(1, len(segment) - 1)\n    segment = np.roll(segment, rotate_amount)\n    new_solution[i:j] = segment\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n - 1)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Step 3: Check if the move improves at least one objective\n    old_cost1 = archive[selected_idx][1][0]\n    old_cost2 = archive[selected_idx][1][1]\n\n    new_cost1 = 0\n    new_cost2 = 0\n    for idx in range(n):\n        new_cost1 += distance_matrix_1[new_solution[idx-1], new_solution[idx]]\n        new_cost2 += distance_matrix_2[new_solution[idx-1], new_solution[idx]]\n\n    # Only keep the new solution if it improves at least one objective\n    if (new_cost1 <= old_cost1) or (new_cost2 <= old_cost2):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{A novel adaptive local search algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective value diversity, then applies a combination of multi-segment reversal and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective diversity\n        dominance = sum(1 for s, o in archive if o[0] < obj[0] and o[1] < obj[1])\n        diversity = (obj[0] - obj[1]) ** 2\n        score = dominance + diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply multi-segment reversal\n    num_segments = random.randint(2, min(4, n//2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n\n    start = 0\n    for end in segment_indices + [n]:\n        if end - start > 1:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        start = end\n\n    # Apply adaptive edge insertion\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Check if insertion improves at least one objective\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            8.939374792025687,
            7.7519099395080655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for each solution in the archive\n    scores = []\n    for sol, obj in archive:\n        # Score based on Pareto dominance and objective diversity\n        dominance = sum(1 for s, o in archive if o[0] < obj[0] and o[1] < obj[1])\n        diversity = (obj[0] - obj[1]) ** 2\n        score = dominance + diversity\n        scores.append(score)\n\n    # Select solution with highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply multi-segment reversal\n    num_segments = random.randint(2, min(4, n//2))\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments-1))\n\n    start = 0\n    for end in segment_indices + [n]:\n        if end - start > 1:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        start = end\n\n    # Apply adaptive edge insertion\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Check if insertion improves at least one objective\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{A novel hybrid local search algorithm selects a diverse solution from the archive by prioritizing those with high crowding distance or extreme objective values, then applies a combination of node insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = [obj for _, obj in archive]\n        objectives_sorted = sorted(objectives, key=lambda x: x[0])\n        crowding = np.zeros(len(archive))\n        for m in range(2):  # For both objectives\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives_sorted[sorted_idx[i+1]][m] - objectives_sorted[sorted_idx[i-1]][m]) / (objectives_sorted[-1][m] - objectives_sorted[0][m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l and not (i <= k < j or i <= l < j):\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            8.69786592091343,
            9.188362040563383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances\n        objectives = [obj for _, obj in archive]\n        objectives_sorted = sorted(objectives, key=lambda x: x[0])\n        crowding = np.zeros(len(archive))\n        for m in range(2):  # For both objectives\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives_sorted[sorted_idx[i+1]][m] - objectives_sorted[sorted_idx[i-1]][m]) / (objectives_sorted[-1][m] - objectives_sorted[0][m])\n\n        selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n    rotation = random.randint(1, len(segment)-1)\n    new_solution[i:j] = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Step 2: Randomly insert a node from elsewhere in the tour\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 1)\n    if k != l and not (i <= k < j or i <= l < j):\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a multi-segment crossover and edge insertion operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three non-adjacent segments\n    points = sorted(random.sample(range(n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Step 2: Create a new segment by combining parts of the selected segments\n    new_segment = np.concatenate([\n        new_solution[a:b],\n        new_solution[b:c][::-1],\n        new_solution[c:] if c != n else np.array([])\n    ])\n\n    # Step 3: Insert the new segment back into the solution\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_segment,\n        new_solution[b:c] if a == 0 else np.array([])\n    ])\n\n    # Ensure all nodes are unique\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for i, node in enumerate(missing_nodes):\n            new_solution[np.where(new_solution == new_solution[i])[0][0]] = node\n\n    return new_solution\n\n",
        "score": [
            9.359968299565574,
            7.986427034405703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: abs(archive[i][1][0] - archive[i][1][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select three non-adjacent segments\n    points = sorted(random.sample(range(n), 3))\n    a, b, c = points[0], points[1], points[2]\n\n    # Step 2: Create a new segment by combining parts of the selected segments\n    new_segment = np.concatenate([\n        new_solution[a:b],\n        new_solution[b:c][::-1],\n        new_solution[c:] if c != n else np.array([])\n    ])\n\n    # Step 3: Insert the new segment back into the solution\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_segment,\n        new_solution[b:c] if a == 0 else np.array([])\n    ])\n\n    # Ensure all nodes are unique\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for i, node in enumerate(missing_nodes):\n            new_solution[np.where(new_solution == new_solution[i])[0][0]] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two segments and reverse them\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent nodes if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n    if l - k > 1:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.437054998105195,
            6.445647671580666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two segments and reverse them\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent nodes if beneficial\n    k = random.randint(0, n - 3)\n    l = random.randint(k + 1, n - 1)\n    if l - k > 1:\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        # Apply swap if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This new algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i+1:j+1]\n\n    # Step 2: Rotate the segment by a random amount\n    shift = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Step 3: Randomly select an edge to insert elsewhere\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if l == k or l == k + 1 or l == k - 1:\n        return new_solution\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        edge = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = l if l < len(new_solution) else len(new_solution) - 1\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n    return new_solution\n\n",
        "score": [
            7.1780689237807485,
            6.3464823542021245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to rotate\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i+1:j+1]\n\n    # Step 2: Rotate the segment by a random amount\n    shift = random.randint(1, len(segment) - 1)\n    rotated_segment = np.concatenate([segment[shift:], segment[:shift]])\n    new_solution[i+1:j+1] = rotated_segment\n\n    # Step 3: Randomly select an edge to insert elsewhere\n    k = random.randint(0, n - 2)\n    l = random.randint(0, n - 1)\n    if l == k or l == k + 1 or l == k - 1:\n        return new_solution\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply insertion if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        edge = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = l if l < len(new_solution) else len(new_solution) - 1\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of adaptive segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility by maintaining the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution from the top 30% or with diverse objectives\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Extract and insert segment\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Step 2: Edge reversal with objective-aware selection\n    for _ in range(2):\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Apply reversal if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.481082972216653,
            6.663599265456981
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select a solution from the top 30% or with diverse objectives\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Step 1: Adaptive segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    # Extract and insert segment\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Step 2: Edge reversal with objective-aware selection\n    for _ in range(2):\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n\n        # Calculate current and potential costs\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        new_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n        new_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                    distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Apply reversal if beneficial for at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge crossover and segment insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Insert the middle segment at a different position\n    segment = new_solution[i+1:j]\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.415435842859623,
            10.624585931128983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Insert the middle segment at a different position\n    segment = new_solution[i+1:j]\n    new_solution = np.concatenate([new_solution[:i+1], new_solution[j:], segment])\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity score based on objective values\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = abs(obj[0] - obj[1])\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.559148640510887,
            7.307512473356469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity score based on objective values\n        diversity_scores = []\n        for sol, obj in archive:\n            diversity = abs(obj[0] - obj[1])\n            diversity_scores.append(diversity)\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Apply segment reversal with probability 0.7\n    if random.random() < 0.7:\n        i = random.randint(0, n - 4)\n        j = random.randint(i + 2, n - 2)\n        new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Apply edge exchange with probability 0.5\n    if random.random() < 0.5:\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # Step 2: Find the best insertion point for the segment\n    best_pos = start\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= start and pos <= end:\n            continue\n\n        # Remove segment and insert at new position\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[(end)%n]]\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_1[temp_solution[(pos+len(segment))%n], temp_solution[(pos+len(segment)+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[(end)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[(pos+len(segment))%n], temp_solution[(pos+len(segment)+1)%n]]\n\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best found insertion\n    if best_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.5:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.522828957677136,
            5.497725174163544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], -max(x[1][0], x[1][1])))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    start = random.randint(0, n - 3)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # Step 2: Find the best insertion point for the segment\n    best_pos = start\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= start and pos <= end:\n            continue\n\n        # Remove segment and insert at new position\n        temp_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:pos],\n            segment,\n            new_solution[pos:]\n        ])\n\n        # Calculate improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end-1], new_solution[(end)%n]]\n        new_cost1 = distance_matrix_1[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_1[temp_solution[(pos+len(segment))%n], temp_solution[(pos+len(segment)+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end-1], new_solution[(end)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[pos-1], temp_solution[pos]] + distance_matrix_2[temp_solution[(pos+len(segment))%n], temp_solution[(pos+len(segment)+1)%n]]\n\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    # Apply the best found insertion\n    if best_pos != start:\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n    # Step 3: Apply a probabilistic edge swap for further improvement\n    if random.random() < 0.5:\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This novel algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange, segment reversal, and a novel 'cross-segment relocation' operation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select three non-adjacent segments\n    i = random.randint(0, n - 6)\n    j = random.randint(i + 2, n - 4)\n    k = random.randint(j + 2, n - 2)\n\n    # Step 2: Relocate the middle segment between the first and third segments\n    segment = new_solution[j+1:k]\n    new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:j+1], new_solution[k:]])\n\n    # Step 3: Randomly swap two edges if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 4: Reverse a random segment if beneficial\n    x = random.randint(0, n - 2)\n    y = random.randint(x + 1, n - 1)\n\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(x, y+1))\n    new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in [x-1] + list(range(y, x-1, -1)))\n\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(x, y+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in [x-1] + list(range(y, x-1, -1)))\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[x:y+1] = new_solution[y:x-1:-1]\n\n    return new_solution\n\n",
        "score": [
            6.842021741365835,
            7.043259294233936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select three non-adjacent segments\n    i = random.randint(0, n - 6)\n    j = random.randint(i + 2, n - 4)\n    k = random.randint(j + 2, n - 2)\n\n    # Step 2: Relocate the middle segment between the first and third segments\n    segment = new_solution[j+1:k]\n    new_solution = np.concatenate([new_solution[:i+1], segment, new_solution[i+1:j+1], new_solution[k:]])\n\n    # Step 3: Randomly swap two edges if beneficial\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Step 4: Reverse a random segment if beneficial\n    x = random.randint(0, n - 2)\n    y = random.randint(x + 1, n - 1)\n\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(x, y+1))\n    new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in [x-1] + list(range(y, x-1, -1)))\n\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(x, y+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in [x-1] + list(range(y, x-1, -1)))\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[x:y+1] = new_solution[y:x-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and swap them if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.477813859999273,
            10.69659509360754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly select two edges and swap them if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of Pareto dominance and objective diversity, then applies a hybrid local search combining segment reversal and edge exchange with probabilistic acceptance to generate diverse and high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominance = sum(1 for s, o in archive if o[0] < obj[0] and o[1] < obj[1])\n        diversity = (obj[0] - obj[1])**2\n        score = 0.7 * dominance + 0.3 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Segment reversal with probabilistic acceptance\n    i = random.randint(0, n-3)\n    j = random.randint(i+2, n-1)\n    temp_sol = new_solution.copy()\n    temp_sol[i:j] = temp_sol[i:j][::-1]\n\n    # Edge exchange with probabilistic improvement\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n    if random.random() < 0.7:  # Higher probability for exchange\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Accept segment reversal if it improves at least one objective\n    cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n    cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    if (cost1 < current_cost1) or (cost2 < current_cost2):\n        new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            10.416204685000707,
            10.556066614891172
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        dominance = sum(1 for s, o in archive if o[0] < obj[0] and o[1] < obj[1])\n        diversity = (obj[0] - obj[1])**2\n        score = 0.7 * dominance + 0.3 * diversity\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Segment reversal with probabilistic acceptance\n    i = random.randint(0, n-3)\n    j = random.randint(i+2, n-1)\n    temp_sol = new_solution.copy()\n    temp_sol[i:j] = temp_sol[i:j][::-1]\n\n    # Edge exchange with probabilistic improvement\n    k = random.randint(0, n-2)\n    l = random.randint(k+1, n-1)\n    if random.random() < 0.7:  # Higher probability for exchange\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Accept segment reversal if it improves at least one objective\n    cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n    cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    if (cost1 < current_cost1) or (cost2 < current_cost2):\n        new_solution = temp_sol\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and dominance, then applies a novel multi-segment crossover operation to generate a neighbor solution by recombining non-overlapping segments from different parts of the tour while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two distinct solutions from archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n\n    # Create a mask for segments to keep from each solution\n    n = len(sol1)\n    mask = np.zeros(n, dtype=bool)\n    segment_length = max(2, n // 4)\n\n    # Randomly select segments from both solutions\n    for _ in range(2):\n        start = random.randint(0, n - segment_length)\n        mask[start:start+segment_length] = True\n\n    # Create new solution by combining segments\n    new_solution = np.empty_like(sol1)\n    used_nodes = set()\n    pos = 0\n\n    # First add segments from sol1 where mask is True\n    for i in range(n):\n        if mask[i] and sol1[i] not in used_nodes:\n            new_solution[pos] = sol1[i]\n            used_nodes.add(sol1[i])\n            pos += 1\n\n    # Then fill remaining positions with nodes from sol2 not already used\n    remaining_nodes = [node for node in sol2 if node not in used_nodes]\n    for node in remaining_nodes:\n        new_solution[pos] = node\n        pos += 1\n\n    # Ensure all nodes are included (shouldn't happen due to mask design)\n    if len(used_nodes) != n:\n        remaining_nodes = [node for node in sol1 if node not in used_nodes]\n        for node in remaining_nodes:\n            if pos < n:\n                new_solution[pos] = node\n                pos += 1\n\n    return new_solution\n\n",
        "score": [
            6.198865723181804,
            6.578475315031158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) < 2:\n        return archive[0][0].copy()\n\n    # Select two distinct solutions from archive\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n\n    # Create a mask for segments to keep from each solution\n    n = len(sol1)\n    mask = np.zeros(n, dtype=bool)\n    segment_length = max(2, n // 4)\n\n    # Randomly select segments from both solutions\n    for _ in range(2):\n        start = random.randint(0, n - segment_length)\n        mask[start:start+segment_length] = True\n\n    # Create new solution by combining segments\n    new_solution = np.empty_like(sol1)\n    used_nodes = set()\n    pos = 0\n\n    # First add segments from sol1 where mask is True\n    for i in range(n):\n        if mask[i] and sol1[i] not in used_nodes:\n            new_solution[pos] = sol1[i]\n            used_nodes.add(sol1[i])\n            pos += 1\n\n    # Then fill remaining positions with nodes from sol2 not already used\n    remaining_nodes = [node for node in sol2 if node not in used_nodes]\n    for node in remaining_nodes:\n        new_solution[pos] = node\n        pos += 1\n\n    # Ensure all nodes are included (shouldn't happen due to mask design)\n    if len(used_nodes) != n:\n        remaining_nodes = [node for node in sol1 if node not in used_nodes]\n        for node in remaining_nodes:\n            if pos < n:\n                new_solution[pos] = node\n                pos += 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{The new algorithm selects a solution from the archive based on its objective diversity, then applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) < 2:\n        return archive[0][0].copy()\n\n    # Calculate diversity scores based on objective values\n    diversity_scores = []\n    for i in range(len(objectives)):\n        distances = [np.linalg.norm(np.array(objectives[i]) - np.array(objectives[j])) for j in range(len(objectives)) if j != i]\n        diversity_scores.append(np.mean(distances))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Insert the segment at a random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Randomly reverse an edge if beneficial\n    k = random.randint(0, n - 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            7.26422566147032,
            7.352328452573683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    if len(objectives) < 2:\n        return archive[0][0].copy()\n\n    # Calculate diversity scores based on objective values\n    diversity_scores = []\n    for i in range(len(objectives)):\n        distances = [np.linalg.norm(np.array(objectives[i]) - np.array(objectives[j])) for j in range(len(objectives)) if j != i]\n        diversity_scores.append(np.mean(distances))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to insert elsewhere\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n    segment = new_solution[i:j]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n\n    # Insert the segment at a random position\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 2: Randomly reverse an edge if beneficial\n    k = random.randint(0, n - 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[k]]\n\n    # Apply reversal if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on a combination of crowding distance and Pareto dominance, then applies a multi-segment reversal and edge insertion strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance and Pareto dominance\n    def calculate_crowding_distance(solutions):\n        n = len(solutions)\n        if n <= 2:\n            return [1.0] * n\n\n        objectives = [obj for _, obj in solutions]\n        crowding = [0.0] * n\n\n        for m in range(2):\n            sorted_idx = sorted(range(n), key=lambda i: objectives[i][m])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n\n            f_min = objectives[sorted_idx[0]][m]\n            f_max = objectives[sorted_idx[-1]][m]\n\n            if f_max == f_min:\n                continue\n\n            for i in range(1, n-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (f_max - f_min)\n\n        return crowding\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distances[i])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-segment reversal and edge insertion\n    points = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = points\n\n    # Reverse segments between a-b and b-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Insert edge from a to c if beneficial\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[c-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[c-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            9.823317306425363,
            9.547342964624482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on crowding distance and Pareto dominance\n    def calculate_crowding_distance(solutions):\n        n = len(solutions)\n        if n <= 2:\n            return [1.0] * n\n\n        objectives = [obj for _, obj in solutions]\n        crowding = [0.0] * n\n\n        for m in range(2):\n            sorted_idx = sorted(range(n), key=lambda i: objectives[i][m])\n            crowding[sorted_idx[0]] = float('inf')\n            crowding[sorted_idx[-1]] = float('inf')\n\n            f_min = objectives[sorted_idx[0]][m]\n            f_max = objectives[sorted_idx[-1]][m]\n\n            if f_max == f_min:\n                continue\n\n            for i in range(1, n-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (f_max - f_min)\n\n        return crowding\n\n    crowding_distances = calculate_crowding_distance(archive)\n    selected_idx = max(range(len(archive)), key=lambda i: crowding_distances[i])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution\n\n    # Multi-segment reversal and edge insertion\n    points = sorted(random.sample(range(1, n-1), 3))\n    a, b, c = points\n\n    # Reverse segments between a-b and b-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Insert edge from a to c if beneficial\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[c-1], new_solution[c]]\n    new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[c-1], new_solution[a]]\n\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[c-1], new_solution[c]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[c-1], new_solution[a]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n\n    return new_solution\n\n"
    }
]