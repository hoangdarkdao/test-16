[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": "{The new algorithm employs a novel multi-objective path decomposition and reconstruction strategy that first dynamically partitions the solution into non-overlapping segments based on their contribution to both objectives, then intelligently reorders these segments using a hybrid similarity metric that combines both objective improvements and spatial proximity, followed by a constrained segment merging process that preserves high-quality sub-tours while introducing controlled randomness through a probabilistic segment inversion mechanism that adaptively adjusts its application probability based on the current trade-off between objectives, ensuring feasibility through a guided node reinsertion strategy that maintains proper tour connectivity and closure.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.metrics import pairwise_distances\n    import random\n\n    # Select solution with best combined objective\n    objectives = np.array([obj for _, obj in archive])\n    combined_obj = objectives[:, 0] * 0.5 + objectives[:, 1] * 0.5\n    selected_idx = np.argmin(combined_obj)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Dynamic segment partitioning based on objective contribution\n    segment_sizes = []\n    current_segment = [base_solution[0]]\n    for i in range(1, n):\n        current_node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        # Check if adding to current segment improves both objectives\n        if cost1 < distance_matrix_1[base_solution[i-1], base_solution[i]] and \\\n           cost2 < distance_matrix_2[base_solution[i-1], base_solution[i]]:\n            current_segment.append(current_node)\n        else:\n            segment_sizes.append(len(current_segment))\n            current_segment = [current_node]\n    segment_sizes.append(len(current_segment))\n\n    # Create segments based on calculated sizes\n    segments = []\n    start = 0\n    for size in segment_sizes:\n        segments.append(base_solution[start:start+size])\n        start += size\n\n    # Hybrid segment reordering\n    segment_coords = []\n    for seg in segments:\n        seg_coords = instance[seg, :2].mean(axis=0)\n        segment_coords.append(seg_coords)\n    segment_coords = np.array(segment_coords)\n\n    # Calculate similarity based on both objectives and spatial proximity\n    similarity_matrix = np.zeros((len(segments), len(segments)))\n    for i in range(len(segments)):\n        for j in range(len(segments)):\n            if i == j:\n                similarity_matrix[i,j] = 0\n            else:\n                # Objective similarity\n                seg1_cost1 = sum(distance_matrix_1[segments[i][k], segments[i][(k+1)%len(segments[i])]] for k in range(len(segments[i])))\n                seg1_cost2 = sum(distance_matrix_2[segments[i][k], segments[i][(k+1)%len(segments[i])]] for k in range(len(segments[i])))\n                seg2_cost1 = sum(distance_matrix_1[segments[j][k], segments[j][(k+1)%len(segments[j])]] for k in range(len(segments[j])))\n                seg2_cost2 = sum(distance_matrix_2[segments[j][k], segments[j][(k+1)%len(segments[j])]] for k in range(len(segments[j])))\n\n                obj_similarity = 1 / (1 + abs(seg1_cost1 - seg2_cost1) + abs(seg1_cost2 - seg2_cost2))\n\n                # Spatial similarity\n                spatial_similarity = 1 / (1 + np.linalg.norm(segment_coords[i] - segment_coords[j]))\n\n                similarity_matrix[i,j] = 0.7 * obj_similarity + 0.3 * spatial_similarity\n\n    # Greedy segment reordering\n    ordered_segments = []\n    remaining_indices = list(range(len(segments)))\n    current_index = random.choice(remaining_indices)\n    ordered_segments.append(segments[current_index])\n    remaining_indices.remove(current_index)\n\n    while remaining_indices:\n        best_index = max(remaining_indices, key=lambda x: similarity_matrix[current_index, x])\n        ordered_segments.append(segments[best_index])\n        current_index = best_index\n        remaining_indices.remove(best_index)\n\n    # Reconstruct solution\n    new_solution = np.concatenate(ordered_segments)\n\n    # Probabilistic segment inversion\n    for i in range(len(segments)):\n        if random.random() < 0.3:  # 30% chance to invert\n            new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])] = \\\n                new_solution[sum(segment_sizes[:i]):sum(segment_sizes[:i+1])][::-1]\n\n    # Guided node reinsertion for feasibility\n    for _ in range(3):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in range(n-1):\n            candidate = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            score = 0.6 * cost1 + 0.4 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               4.3980138411430225,
               8.956155718227361
          ]
     },
     {
          "algorithm": "{The new algorithm combines the selection strategy of focusing on diverse solutions from the first provided algorithm with a novel local search operator that integrates both path inversion and node relocation, guided by a hybrid objective improvement criterion that considers both individual objective improvements and their combined trade-offs. It first partitions the archive into clusters based on both objective values and spatial diversity, then selects a representative solution from the least explored cluster. The local search operator dynamically selects multiple non-overlapping segments from the solution, applies inversion with probability based on local objective improvements, and then performs targeted node relocations to further optimize the tour, with the search guided by a hybrid acceptance criterion that balances individual objective improvements with their combined trade-offs to ensure feasible and high-quality solutions are generated.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Cluster-based selection\n    objectives = np.array([obj for _, obj in archive])\n    coords = instance[archive[0][0], :2]\n    diversity = np.array([np.std(coords[:, 0]), np.std(coords[:, 1])])\n\n    cluster_data = np.hstack([objectives, diversity.reshape(1, -1).repeat(len(archive), axis=0)])\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters)\n    labels = kmeans.fit_predict(cluster_data)\n\n    cluster_sizes = np.bincount(labels)\n    least_cluster = np.argmin(cluster_sizes)\n    candidates = [i for i, label in enumerate(labels) if label == least_cluster]\n\n    if not candidates:\n        selected_idx = random.randint(0, len(archive)-1)\n    else:\n        selected_idx = random.choice(candidates)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hybrid local search: Segment inversion with node relocation\n    num_segments = min(3, n // 4)\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments*2))\n    segments = [(segment_indices[i], segment_indices[i+1]) for i in range(0, len(segment_indices), 2)]\n    segments.sort(key=lambda x: x[1]-x[0], reverse=True)\n\n    for start, end in segments:\n        segment = new_solution[start:end+1]\n        if random.random() < 0.6:\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start-1, end+1))\n\n            inverted_segment = segment[::-1]\n            temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start-1, end+1))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= 1.1 * current_cost2) or \\\n               (new_cost1 <= 1.1 * current_cost1 and new_cost2 < current_cost2):\n                new_solution = temp_solution\n\n    # Node relocation with trade-off consideration\n    for _ in range(5):\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        candidate_positions = list(range(n))\n        candidate_positions.remove(node_pos)\n\n        best_pos = None\n        best_score = float('inf')\n        for pos in candidate_positions:\n            temp_sol = np.delete(new_solution, node_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n))\n\n            combined_score = 0.7 * cost1 + 0.3 * cost2\n            if combined_score < best_score:\n                best_pos = pos\n                best_score = combined_score\n\n        if best_pos is not None:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.041981799207054,
               7.326106261285743
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto-based solution selection with a novel multi-objective tour fragmentation and reassembly strategy that intelligently splits the tour into contiguous segments, evaluates their objective contributions, and reassembles them in a way that maximizes improvements in both objectives while maintaining solution feasibility through a constrained segment merging mechanism. The reassembly process dynamically adjusts segment boundaries based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided segment rotation mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour fragmentation and reassembly\n    for _ in range(5):\n        # Randomly select two cut points to split the tour into three segments\n        cut1, cut2 = sorted(random.sample(range(1, n), 2))\n        segment1 = base_solution[:cut1]\n        segment2 = base_solution[cut1:cut2]\n        segment3 = base_solution[cut2:]\n\n        # Try different reassembly orders\n        candidates = [\n            np.concatenate([segment1, segment3, segment2]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment3, segment2, segment1]),\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment2[::-1], segment1, segment3])\n        ]\n\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_candidate = candidate\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Guided segment rotation\n    for _ in range(5):\n        # Select a segment to rotate\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Try different rotation amounts\n        for rotation in range(1, segment_length):\n            candidate = new_solution.copy()\n            segment = candidate[start:end]\n            rotated_segment = np.roll(segment, rotation)\n            candidate[start:end] = rotated_segment\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.520469626016764,
               5.163588701139817
          ]
     },
     {
          "algorithm": "{The new algorithm combines an adaptive multi-objective clustering approach with a novel hierarchical segment reassembly strategy that dynamically identifies and preserves high-quality sub-tours from the Pareto front solutions, while intelligently breaking and reconnecting them through a constrained node permutation mechanism that prioritizes non-dominated segments based on their contribution to both objectives, using a weighted multi-criteria evaluation to guide the reassembly process while maintaining solution feasibility by ensuring proper node connectivity and tour closure through a guided segment inversion and merging mechanism that adaptively adjusts the segment size and merge position based on the current trade-off between objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Adaptive multi-objective clustering with weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) + 1e-6)\n    cluster_centers = np.array([[0.25, 0.75], [0.5, 0.5], [0.75, 0.25]])\n    distances = np.linalg.norm(normalized_obj[:, None] - cluster_centers, axis=2)\n    cluster_assignments = np.argmin(distances, axis=1)\n\n    # Select from the most promising cluster (middle cluster)\n    cluster_indices = np.where(cluster_assignments == 1)[0]\n    if len(cluster_indices) > 0:\n        selected_idx = np.random.choice(cluster_indices)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Hierarchical segment reassembly with dynamic segment size\n    for _ in range(4):\n        segment_size = np.random.randint(2, min(5, n // 4))\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        segment = base_solution[start:end]\n\n        # Evaluate segment contribution using weighted criteria\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        total_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        # Weighted importance based on current trade-off\n        weight1 = segment_cost1 / (total_cost1 + 1e-6)\n        weight2 = segment_cost2 / (total_cost2 + 1e-6)\n        weights = [weight1, weight2] if weight1 > weight2 else [weight2, weight1]\n\n        # Remove segment and find best merge position\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Try inserting segment at position i and its reverse\n            candidates = [\n                np.insert(temp_solution, i, segment),\n                np.insert(temp_solution, i, segment[::-1])\n            ]\n\n            for candidate in candidates:\n                candidate_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                candidate_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                score = weights[0] * candidate_cost1 + weights[1] * candidate_cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n                    best_candidate = candidate\n\n        if best_pos != -1:\n            new_solution = best_candidate\n\n    # Guided segment inversion with adaptive acceptance\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[j+1:]])\n\n        # Check feasibility\n        if len(np.unique(candidate)) == n:\n            # Calculate weighted score\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Adaptive weights based on current trade-off\n            weight1 = new_cost1 / (current_cost1 + 1e-6)\n            weight2 = new_cost2 / (current_cost2 + 1e-6)\n            weights = [weight1, weight2] if weight1 > weight2 else [weight2, weight1]\n\n            current_score = weights[0] * current_cost1 + weights[1] * current_cost2\n            new_score = weights[0] * new_cost1 + weights[1] * new_cost2\n\n            if new_score < current_score:\n                new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.382759568727223,
               6.525019920193785
          ]
     },
     {
          "algorithm": "{This new algorithm employs a multi-phase evolutionary selection process that first evaluates solutions based on their Pareto efficiency and spatial distribution, then applies a novel adaptive crossover operator that combines genetic material from multiple elite solutions while preserving tour structure, followed by a probabilistic mutation scheme that selectively alters node sequences based on local objective gradients, all within a dynamic neighborhood framework that balances exploration and exploitation through adaptive parameter tuning.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    import random\n    import numpy as np\n    from scipy.spatial import distance\n\n    # Phase 1: Pareto-efficient solution selection with spatial consideration\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated[i] = True\n                break\n\n    pareto_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if not pareto_indices:\n        pareto_indices = range(len(archive))\n\n    # Select solution with best spatial diversity\n    coords = instance[archive[0][0], :2]\n    diversity_scores = []\n    for idx in pareto_indices:\n        sol_coords = instance[archive[idx][0], :2]\n        diversity = np.mean([distance.cdist(sol_coords, sol_coords, 'euclidean').mean() for _ in range(5)])\n        diversity_scores.append(diversity)\n\n    selected_idx = pareto_indices[np.argmax(diversity_scores)]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Phase 2: Adaptive crossover with multiple parents\n    n = len(base_solution)\n    num_parents = min(3, len(archive))\n    parent_indices = random.sample(range(len(archive)), num_parents)\n    parents = [archive[i][0] for i in parent_indices]\n\n    # Create crossover points\n    points = sorted(random.sample(range(1, n-1), 2))\n    child = np.zeros(n, dtype=int)\n\n    # Alternate segments from parents\n    parent_idx = 0\n    pos = 0\n    for i in range(points[0], points[1]):\n        child[pos] = parents[parent_idx][i]\n        pos += 1\n        parent_idx = (parent_idx + 1) % num_parents\n\n    # Fill remaining positions\n    remaining_nodes = [node for node in base_solution if node not in child[:pos]]\n    for i in range(pos, n):\n        child[i] = remaining_nodes.pop(0)\n\n    # Phase 3: Probabilistic mutation based on local gradients\n    new_solution = child.copy()\n    mutation_rate = 0.3\n\n    for i in range(n):\n        if random.random() < mutation_rate:\n            # Calculate local improvement potential\n            current_node = new_solution[i]\n            neighbors = [j for j in range(n) if j != i]\n\n            best_neighbor = None\n            best_improvement = 0\n\n            for j in neighbors:\n                # Try swapping with neighbor\n                temp_sol = new_solution.copy()\n                temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                # Calculate improvement in both objectives\n                cost1 = (sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n)) -\n                        sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n                cost2 = (sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%n]] for k in range(n)) -\n                        sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)))\n\n                # Weighted improvement\n                improvement = 0.6 * cost1 + 0.4 * cost2\n\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_neighbor = j\n\n            if best_neighbor is not None:\n                new_solution[i], new_solution[best_neighbor] = new_solution[best_neighbor], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               5.202440282968024,
               7.309019445379103
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a combination of objective values and diversity measures. It then applies a novel hybrid local search operator that combines a modified version of the Lin-Kernighan heuristic with a variable-length segment relocation strategy. The operator randomly selects a segment of nodes in the tour and relocates it to a new position while considering both objective spaces, ensuring feasibility by maintaining the TSP constraints. The selection of the segment length and insertion point is guided by a probabilistic approach that balances exploration and exploitation, favoring segments that show high potential for reducing both objectives. The function returns the new neighbor solution after validating its feasibility.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([(cost1 + cost2) / (np.max(distance_matrix_1) + np.max(distance_matrix_2)) for _, (cost1, cost2) in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment length (1 to n//2)\n    segment_length = random.randint(1, n // 2)\n\n    # Randomly select a starting position for the segment\n    start_pos = random.randint(0, n - segment_length)\n\n    # Extract the segment\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Find the best insertion position considering both objectives\n    best_insert_pos = 0\n    best_cost = float('inf')\n\n    for insert_pos in range(len(new_solution)):\n        # Insert the segment at the current position\n        candidate = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Combine the costs with a weighted sum\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = insert_pos\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
          "score": [
               6.11088345881558,
               5.468006696741405
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto-based solution selection with a novel multi-objective tour decomposition and recombination strategy that intelligently partitions the tour into non-overlapping segments based on their objective contributions, evaluates each segment's potential for improvement in both objective spaces using a dynamic segment scoring mechanism, and reassembles them in a way that maximizes improvements while maintaining feasibility through a constrained segment merging mechanism that preserves the tour's cyclic structure. The reassembly process dynamically adjusts segment boundaries based on local topology and objective trade-offs, incorporating a guided segment inversion mechanism to further refine the solution while respecting the bi-objective nature of the problem, and uses a probabilistic segment selection approach that balances exploration of high-potential segments with exploitation of proven improvements.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best Pareto trade-off\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective tour decomposition and recombination\n    for _ in range(5):\n        # Randomly select a segment length (1 to n//3)\n        segment_length = random.randint(1, n // 3)\n\n        # Randomly select a starting position for the segment\n        start_pos = random.randint(0, n - segment_length)\n\n        # Extract the segment\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Remove the segment from the solution\n        temp_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n        # Try different insertion points and orientations\n        best_candidate = new_solution.copy()\n        best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        for insert_pos in range(len(temp_solution)):\n            for orientation in [segment, segment[::-1]]:\n                candidate = np.concatenate([temp_solution[:insert_pos], orientation, temp_solution[insert_pos:]])\n\n                cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n                # Accept if both objectives improve or one improves with small deterioration in the other\n                if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                    best_candidate = candidate\n                    best_cost1 = cost1\n                    best_cost2 = cost2\n\n        new_solution = best_candidate\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        # Select a segment to potentially invert\n        segment_length = random.randint(2, min(5, n // 2))\n        start_pos = random.randint(0, n - segment_length)\n\n        candidate = new_solution.copy()\n        candidate[start_pos:start_pos + segment_length] = candidate[start_pos:start_pos + segment_length][::-1]\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.437290287028313,
               6.126219238817631
          ]
     },
     {
          "algorithm": "{The new algorithm combines the segment-based optimization approach from the first provided algorithm with the cluster-based selection strategy from the second, but replaces the inversion and relocation operators with a novel \"objective-aware segment merging\" process. It first partitions the base solution into segments based on both objective spaces' local topologies, then selects representative segments from diverse clusters in the objective space, and merges them in an adaptive fashion that considers the trade-off between objectives while maintaining feasibility through a dynamic segment reordering mechanism that ensures no nodes are skipped or revisited. The merging process uses a hybrid objective improvement criterion that prioritizes segments improving at least one objective while maintaining or improving the other, with the entire process guided by a spatial diversity measure to ensure comprehensive exploration of the solution space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    from sklearn.cluster import KMeans\n    import random\n\n    # Select base solution with best combined objective\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    # Calculate segment objectives\n    def segment_objectives(segment):\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        return (cost1, cost2)\n\n    # Decompose tour into segments\n    n = len(base_solution)\n    min_segment = max(3, n // 5)\n    max_segment = min(10, n // 2)\n    segments = []\n    current_start = 0\n\n    while current_start < n:\n        segment_length = random.randint(min_segment, max_segment)\n        segment_end = min(current_start + segment_length, n)\n        segments.append(base_solution[current_start:segment_end])\n        current_start = segment_end\n\n    # Cluster segments by objectives\n    segment_costs = np.array([segment_objectives(seg) for seg in segments])\n    if len(segments) > 1:\n        n_clusters = min(3, len(segments))\n        kmeans = KMeans(n_clusters=n_clusters)\n        labels = kmeans.fit_predict(segment_costs)\n\n        # Select representative segments from each cluster\n        selected_segments = []\n        for cluster in range(n_clusters):\n            cluster_indices = [i for i, label in enumerate(labels) if label == cluster]\n            if cluster_indices:\n                selected_segments.append(segments[random.choice(cluster_indices)])\n    else:\n        selected_segments = segments\n\n    # Objective-aware segment merging\n    new_solution = []\n    for seg in selected_segments:\n        if not new_solution:\n            new_solution = list(seg)\n        else:\n            # Find best merge position considering both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for pos in range(len(new_solution) + 1):\n                # Try inserting segment at position pos\n                temp_sol = new_solution[:pos] + list(seg) + new_solution[pos:]\n\n                # Calculate new total costs\n                cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n                cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n\n                # Hybrid objective score\n                score = 0.5 * cost1 + 0.5 * cost2\n\n                if score < best_score:\n                    best_pos = pos\n                    best_score = score\n\n            new_solution = new_solution[:best_pos] + list(seg) + new_solution[best_pos:]\n\n    # Dynamic segment reordering for feasibility\n    for _ in range(2):\n        if len(new_solution) < 3:\n            break\n\n        # Select random segment to reorder\n        seg_start = random.randint(0, len(new_solution) - 3)\n        seg_length = random.randint(2, min(5, len(new_solution) - seg_start - 1))\n        seg_end = seg_start + seg_length\n\n        segment = new_solution[seg_start:seg_end]\n\n        # Try different orderings\n        candidates = [\n            segment,  # original\n            segment[::-1],  # reversed\n            segment[-1:] + segment[:-1],  # rotated right\n            segment[1:] + segment[:1]  # rotated left\n        ]\n\n        best_order = segment\n        best_score = float('inf')\n\n        for candidate in candidates:\n            temp_sol = new_solution[:seg_start] + candidate + new_solution[seg_end:]\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%len(temp_sol)]] for i in range(len(temp_sol)))\n\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_order = candidate\n                best_score = score\n\n        new_solution = new_solution[:seg_start] + best_order + new_solution[seg_end:]\n\n    return np.array(new_solution)\n\n",
          "score": [
               5.898850561041737,
               5.561746469784979
          ]
     },
     {
          "algorithm": "{The new algorithm combines Pareto front analysis with a novel multi-objective segment relocation strategy that dynamically selects and repositions segments of the tour based on their contribution to both objectives, using a hybrid acceptance criterion that balances improvement in both objectives while maintaining solution feasibility through a constrained segment relocation mechanism. The segment relocation dynamically adjusts the segment length and position based on local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure, and incorporates a guided edge reversal mechanism to further refine the solution while respecting the bi-objective nature of the problem.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select solution with best trade-off using Pareto front analysis\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        base_solution = archive[np.random.randint(0, len(archive))][0].copy()\n    else:\n        # Select solution with best trade-off (minimize sum of normalized objectives)\n        normalized_front = []\n        min_obj1 = min(obj[0] for _, obj in pareto_front)\n        max_obj1 = max(obj[0] for _, obj in pareto_front)\n        min_obj2 = min(obj[1] for _, obj in pareto_front)\n        max_obj2 = max(obj[1] for _, obj in pareto_front)\n\n        for sol, obj in pareto_front:\n            norm_obj1 = (obj[0] - min_obj1) / (max_obj1 - min_obj1) if max_obj1 != min_obj1 else 0.5\n            norm_obj2 = (obj[1] - min_obj2) / (max_obj2 - min_obj2) if max_obj2 != min_obj2 else 0.5\n            normalized_front.append((sol, (norm_obj1, norm_obj2)))\n\n        best_idx = np.argmin([obj[0] + obj[1] for _, obj in normalized_front])\n        base_solution = normalized_front[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Multi-objective segment relocation\n    for _ in range(5):\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(n - segment_length)\n        end = start + segment_length\n\n        # Extract the segment\n        segment = base_solution[start:end]\n\n        # Remove the segment\n        temp_solution = np.concatenate([base_solution[:start], base_solution[end:]])\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(len(temp_solution)):\n            # Insert segment at position i\n            candidate = np.insert(temp_solution, i, segment)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Multi-objective comparison\n            if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n                best_pos = i\n                best_cost1 = cost1\n                best_cost2 = cost2\n\n        # Insert segment at best position\n        new_solution = np.insert(temp_solution, best_pos, segment)\n\n    # Guided edge reversal\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Create candidate solution\n        candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if at least one objective improves or both improve with controlled trade-off\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               5.733596318190619,
               5.825750634336084
          ]
     }
]