[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments to modify\n        segments = np.sort(np.random.choice(n, 3, replace=False))\n        a, b, c = segments\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments with novel perturbation\n        new_order = np.concatenate([\n            segment1,\n            segment3[::-1],  # Reverse middle segment\n            segment2,\n            segment4\n        ])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n    return new_solution\n\n",
          "score": [
               -0.79853724529653,
               0.20083975791931152
          ]
     },
     {
          "algorithm": "{The proposed algorithm selects a promising solution from the archive by prioritizing those with the highest combined normalized objective values, indicating potential for improvement. It then applies a hybrid local search operator that combines a novel 3-opt move with a dynamic edge selection strategy, where edges are chosen based on their contribution to both objectives, ensuring feasibility by maintaining a Hamiltonian cycle. The algorithm dynamically adjusts the balance between objectives during the search, using a weighted sum of normalized objective values to guide the selection of edges for perturbation. The 3-opt move is applied in a way that minimizes the increase in the total tour length for both objectives, leveraging the distance matrices to compute edge costs efficiently. The process repeats for a fixed number of iterations or until no further improvement is found, with the final solution being the best encountered during the search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid 3-opt with dynamic edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Extract the edges\n    a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[j]\n    d, e, f = new_solution[(j+1)%n], new_solution[k], new_solution[(k+1)%n]\n\n    # Compute the cost of the current and new configurations\n    # Current cost: a-b, b-c, c-d, d-e, e-f\n    current_cost = (distance_matrix_1[a, b] + distance_matrix_1[b, c] + distance_matrix_1[c, d] + distance_matrix_1[d, e] + distance_matrix_1[e, f] +\n                    distance_matrix_2[a, b] + distance_matrix_2[b, c] + distance_matrix_2[c, d] + distance_matrix_2[d, e] + distance_matrix_2[e, f])\n\n    # New cost: a-c, c-b, b-e, e-d, d-f\n    new_cost = (distance_matrix_1[a, c] + distance_matrix_1[c, b] + distance_matrix_1[b, e] + distance_matrix_1[e, d] + distance_matrix_1[d, f] +\n                distance_matrix_2[a, c] + distance_matrix_2[c, b] + distance_matrix_2[b, e] + distance_matrix_2[e, d] + distance_matrix_2[d, f])\n\n    # Apply the move if it improves the combined cost\n    if new_cost < current_cost:\n        # Reconstruct the tour\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n        new_solution[j+1:k+1] = np.flip(new_solution[j+1:k+1])\n        new_solution[k+1:] = np.roll(new_solution[k+1:], shift=1)\n\n    return new_solution\n\n",
          "score": [
               -0.8420272791118616,
               0.2737277150154114
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising base solution\n    def selection_criterion(sol_obj):\n        # Combine dominance and diversity metrics\n        sol, obj = sol_obj\n        # Simple criterion: prioritize lower objective values\n        return obj[0] + obj[1]\n\n    # Sort by selection criterion\n    archive_sorted = sorted(archive, key=selection_criterion)\n    base_solution, _ = archive_sorted[0]\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel hybrid operator: combination of restricted 3-opt and biased edge exchange\n    if n >= 4:\n        # Select three distinct positions with some randomness\n        i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n        # Apply restricted 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Apply biased edge exchange\n        # Prefer edges that improve both objectives when possible\n        for _ in range(2):  # Limit the number of exchanges\n            a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n            # Check if exchange improves both objectives\n            old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n            new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n            old_cost1 = sum(distance_matrix_1[u][v] for u, v in old_edges)\n            new_cost1 = sum(distance_matrix_1[u][v] for u, v in new_edges)\n            old_cost2 = sum(distance_matrix_2[u][v] for u, v in old_edges)\n            new_cost2 = sum(distance_matrix_2[u][v] for u, v in new_edges)\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not (len(new_solution) == len(np.unique(new_solution))):\n        raise ValueError(\"Generated solution is not a valid tour\")\n\n    return new_solution\n\n",
          "score": [
               -0.8446671578572267,
               0.2885757088661194
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first intelligently selects a solution from the archive by prioritizing those with lower combined objective values and higher variance in their objectives to identify Pareto-efficient solutions with potential for improvement. It then applies a hybrid local search operator that combines a modified 3-opt heuristic with a biased random walk to explore the solution space, ensuring feasibility by validating all candidate moves before execution. The operator selectively disrupts and repairs segments of the tour, using the distance matrices to guide moves that improve both objectives, while the biased random walk introduces controlled exploration to escape local optima. The function returns the new neighbor solution after validating its feasibility and ensuring it represents a valid TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value and high variance\n    archive_sorted = sorted(archive, key=lambda x: (sum(x[1]), -abs(x[1][0] - x[1][1])))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Generate candidate moves (3-opt variants)\n    candidates = [\n        # Standard 3-opt\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[k:]]),\n        # Biased random walk\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n    ]\n\n    # Evaluate candidates based on both objectives\n    best_candidate = None\n    min_cost = float('inf')\n\n    for candidate in candidates:\n        if len(set(candidate)) != n:  # Ensure validity\n            continue\n\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_candidate = candidate.copy()\n\n    # If no improvement found, perform a small perturbation\n    if best_candidate is None:\n        i, j = np.random.choice(n, size=2, replace=False)\n        best_candidate = new_solution.copy()\n        best_candidate[i], best_candidate[j] = best_candidate[j], best_candidate[i]\n\n    return best_candidate\n\n",
          "score": [
               -0.838563790971558,
               0.2600090503692627
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.002562955635491,
               0.30344176292419434
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = abs(obj[0] - obj[1])  # Measure the diversity of objectives\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n\n    # Hybrid local search: combine 3-opt with a biased random swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three segments to perform a 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Create all possible 3-opt variants and select the best one\n    variants = [\n        np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:k], new_solution[k:][::-1]]),\n        np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k][::-1], new_solution[i:j], new_solution[k:][::-1]])\n    ]\n\n    # Evaluate variants based on both objectives\n    best_variant = None\n    best_score = float('inf')\n    for variant in variants:\n        cost1 = sum(distance_matrix_1[variant[i], variant[i+1]] for i in range(-1, n-1))\n        cost2 = sum(distance_matrix_2[variant[i], variant[i+1]] for i in range(-1, n-1))\n        score = cost1 + cost2  # Simple weighted sum for selection\n        if score < best_score:\n            best_score = score\n            best_variant = variant\n\n    if best_variant is not None:\n        new_solution = best_variant.copy()\n\n    # Apply a biased random swap based on distance matrix\n    a, b = random.sample(range(n), 2)\n    if distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[a]] < \\\n       distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               -0.6417830066181451,
               0.25273948907852173
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is the selection of promising solutions from an archive based on their objective values and application of hybrid local search operators to generate improved neighbors while ensuring feasibility. The new algorithm will first identify solutions with high potential for improvement by analyzing their objective values and diversity, then apply a novel 'multi-segment inversion and edge reassignment' strategy that randomly selects multiple non-overlapping segments of the tour, reverses each segment, and then optimally reassigns edges between segments to improve both objectives, all while maintaining feasibility by ensuring no nodes are skipped or revisited.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score (combination of objective values and diversity)\n        improvement_score = (obj[0] + obj[1]) / (1 + np.var(obj))\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-segment inversion and edge reassignment\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Generate multiple non-overlapping segments\n    segments = []\n    remaining = list(range(n))\n    while len(remaining) > 1:\n        # Randomly select segment length\n        seg_length = random.randint(2, min(5, len(remaining)))\n        # Randomly select starting point\n        start_idx = random.choice(remaining)\n        start_pos = remaining.index(start_idx)\n        # Get segment indices\n        seg_indices = remaining[start_pos:start_pos+seg_length]\n        segments.append(seg_indices)\n        # Remove segment from remaining\n        remaining = [x for x in remaining if x not in seg_indices]\n\n    # Reverse each segment\n    for seg in segments:\n        if len(seg) > 1:\n            new_solution[seg] = new_solution[seg][::-1]\n\n    # Optimally reassign edges between segments\n    for i in range(len(segments)-1):\n        seg1 = segments[i]\n        seg2 = segments[i+1]\n\n        # Find best edge to connect segments\n        best_improvement = 0\n        best_edge = None\n\n        # Try all possible connections between segments\n        for a in seg1:\n            for b in seg2:\n                # Current edges\n                prev_a = new_solution[a-1] if a > 0 else new_solution[-1]\n                next_a = new_solution[(a+1)%n]\n                prev_b = new_solution[b-1] if b > 0 else new_solution[-1]\n                next_b = new_solution[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                                distance_matrix_1[new_solution[a], next_a] +\n                                distance_matrix_1[prev_b, new_solution[b]] +\n                                distance_matrix_1[new_solution[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                                distance_matrix_2[new_solution[a], next_a] +\n                                distance_matrix_2[prev_b, new_solution[b]] +\n                                distance_matrix_2[new_solution[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, new_solution[a]] +\n                            distance_matrix_1[new_solution[a], new_solution[b]] +\n                            distance_matrix_1[new_solution[b], next_a] +\n                            distance_matrix_1[prev_b, new_solution[b]] +\n                            distance_matrix_1[new_solution[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, new_solution[a]] +\n                            distance_matrix_2[new_solution[a], new_solution[b]] +\n                            distance_matrix_2[new_solution[b], next_a] +\n                            distance_matrix_2[prev_b, new_solution[b]] +\n                            distance_matrix_2[new_solution[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            # Reorder the solution to connect a to b\n            a_pos = np.where(new_solution == a)[0][0]\n            b_pos = np.where(new_solution == b)[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            # Reorder the segment between a and b\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               -0.955673343787872,
               1.648804247379303
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective score to explore less obvious improvements\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: combine path relinking with a geometric transformation\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a circular shift\n        shift = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, shift)\n    else:\n        # Select two random segments and perform a geometric transformation\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Apply a geometric transformation to the middle segment\n        transformed_segment = segment2.copy()\n        if len(transformed_segment) > 1:\n            # Create a spiral pattern within the segment\n            for i in range(1, len(transformed_segment)):\n                transformed_segment[i], transformed_segment[i-1] = transformed_segment[i-1], transformed_segment[i]\n                if i % 2 == 0:\n                    transformed_segment[i], transformed_segment[i-1] = transformed_segment[i-1], transformed_segment[i]\n\n        # Recombine segments with the transformed segment\n        new_order = np.concatenate([segment1, transformed_segment, segment3])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n        # Apply a path relinking step by swapping nodes based on their geometric properties\n        for i in range(n):\n            for j in range(i+1, n):\n                # Calculate the angle between nodes in both coordinate spaces\n                x1_i, y1_i, x2_i, y2_i = instance[new_solution[i]]\n                x1_j, y1_j, x2_j, y2_j = instance[new_solution[j]]\n                angle1 = np.arctan2(y1_j - y1_i, x1_j - x1_i)\n                angle2 = np.arctan2(y2_j - y2_i, x2_j - x2_i)\n\n                # If angles are similar in both spaces, swap nodes\n                if abs(angle1 - angle2) < np.pi/4:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.8471907388880529,
               0.9628580808639526
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting a promising solution from the archive and applying a hybrid local search, but introduces a novel approach that combines adaptive segment inversion with a multi-objective aware perturbation strategy. It first identifies solutions with high potential for improvement by evaluating their objective diversity and then applies a dynamic segment inversion technique that adaptively selects and reverses segments of the tour based on their contribution to both objectives, followed by a targeted perturbation that prioritizes nodes with high distance savings in either objective space, ensuring feasibility while balancing exploration and exploitation of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (highest objective diversity)\n    selected = max(archive, key=lambda x: abs(x[1][0] - x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        # For small instances, perform a random swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Adaptive segment inversion based on objective contributions\n    segment_length = max(2, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Calculate segment contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n\n    # Invert segment if it contributes more to the higher-cost objective\n    if segment_cost2 > segment_cost1:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective aware perturbation\n    # Find nodes with high distance savings in either objective\n    savings1 = []\n    savings2 = []\n    for i in range(1, n-1):\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        swap_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        savings1.append(current_cost1 - swap_cost1)\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n        swap_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n        savings2.append(current_cost2 - swap_cost2)\n\n    # Select nodes with top savings in either objective\n    top_savings = np.argsort(-np.array(savings1 + savings2))[:max(2, n//5)]\n    selected_nodes = np.unique(top_savings % n)\n\n    # Perform targeted swaps\n    for i in range(len(selected_nodes)):\n        j = np.random.choice(selected_nodes)\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8463523575607719,
               0.3088487982749939
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the current best)\n    selected = None\n    max_gap = -1\n    for sol, obj in archive:\n        gap = abs(obj[0] - obj[1])  # Measure the diversity of objectives\n        if gap > max_gap:\n            max_gap = gap\n            selected = sol\n\n    if selected is None:\n        selected = archive[0][0]\n\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine segment inversion with adaptive node insertion\n    if n < 4:\n        # If too small, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two random segments to modify\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Invert the middle segment\n        segment2_inv = segment2[::-1]\n\n        # Create a temporary solution with inverted segment\n        temp_solution = np.concatenate([segment1, segment2_inv, segment3])\n\n        # Perform adaptive node insertion based on both distance matrices\n        for i in range(1, n-1):\n            node = temp_solution[i]\n            # Calculate insertion cost for both objectives\n            cost1_before = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[i+1]]\n            cost2_before = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[i+1]]\n\n            # Try to insert node at a different position\n            for j in range(1, n-1):\n                if j != i:\n                    cost1_after = distance_matrix_1[temp_solution[j-1], node] + distance_matrix_1[node, temp_solution[j]]\n                    cost2_after = distance_matrix_2[temp_solution[j-1], node] + distance_matrix_2[node, temp_solution[j]]\n\n                    if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                        # Perform the insertion\n                        node = temp_solution[i]\n                        temp_solution = np.concatenate([\n                            temp_solution[:i],\n                            temp_solution[i+1:j],\n                            [node],\n                            temp_solution[j:]\n                        ])\n                        break\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(temp_solution)) == n:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7676660528637563,
               0.2650992274284363
          ]
     }
]