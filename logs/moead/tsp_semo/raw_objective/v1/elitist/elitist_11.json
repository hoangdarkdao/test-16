[
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.726633453615786,
            6.6230135648169055
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([(obj[0] - obj[1])**2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment to reverse\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Randomly select two edges to swap if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for both objectives\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.752277723487163,
            8.650471939575205
        ]
    },
    {
        "algorithm": "{This novel algorithm selects a high-quality solution from the archive based on both Pareto dominance and objective diversity, then applies a combination of adaptive segment relocation and conditional edge reinsertion to generate an improved neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate Pareto rank (simplified approximation)\n        pareto_rank = sum(1 for s, (c1, c2) in archive if (c1 < cost1 and c2 < cost2))\n        # Calculate objective diversity\n        diversity = abs(cost1 - cost2)\n        scores.append((pareto_rank, diversity))\n    selected_idx = min(range(len(scores)), key=lambda i: (scores[i][0], -scores[i][1]))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment relocation\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length - 1)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+segment_length:],\n        segment\n    ])\n\n    # Conditional edge reinsertion\n    for _ in range(2):\n        # Select a random edge\n        i = random.randint(0, n-2)\n        edge = (new_solution[i], new_solution[i+1])\n\n        # Calculate current cost\n        current_cost1 = distance_matrix_1[edge[0], edge[1]]\n        current_cost2 = distance_matrix_2[edge[0], edge[1]]\n\n        # Find best insertion point\n        best_pos = -1\n        best_improvement = 0\n        for j in range(n):\n            if j == i or j == i+1:\n                continue\n            # Calculate potential insertion cost\n            new_cost1 = (distance_matrix_1[new_solution[j-1], edge[0]] +\n                         distance_matrix_1[edge[1], new_solution[j]])\n            new_cost2 = (distance_matrix_2[new_solution[j-1], edge[0]] +\n                         distance_matrix_2[edge[1], new_solution[j]])\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = j\n\n        # Perform insertion if beneficial\n        if best_pos != -1 and best_improvement > 0:\n            # Remove edge\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+2:]\n            ])\n            # Insert at new position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                np.array([edge[0], edge[1]]),\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            5.571812828856179,
            9.33488329910366
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment rotation and edge insertion operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        max_diversity = -1\n        selected_idx = 0\n        for i in range(len(archive)):\n            diversity = abs(archive[i][1][0] - archive[i][1][1])\n            if diversity > max_diversity:\n                max_diversity = diversity\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Apply segment rotation\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[a:b+1] = rotated_segment\n\n    # Apply edge insertion if beneficial\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c == d:\n        d = (d + 1) % n\n\n    current_cost1 = distance_matrix_1[new_solution[c-1], new_solution[c]] + distance_matrix_1[new_solution[d-1], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[c-1], new_solution[d]] + distance_matrix_1[new_solution[c], new_solution[d-1]]\n\n    current_cost2 = distance_matrix_2[new_solution[c-1], new_solution[c]] + distance_matrix_2[new_solution[d-1], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[c-1], new_solution[d]] + distance_matrix_2[new_solution[c], new_solution[d-1]]\n\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution = np.insert(new_solution, c, new_solution[d])\n        new_solution = np.delete(new_solution, d + (1 if d > c else 0))\n\n    return new_solution\n\n",
        "score": [
            4.642535375401237,
            9.873569304166386
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of Pareto dominance and objective diversity, then applies a hybrid local search that combines segment insertion and node swapping with a probabilistic acceptance criterion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by first objective (ascending)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0])\n        # Select from top 20% of solutions\n        selected_idx = random.randint(0, max(1, len(sorted_archive) // 5 - 1))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply hybrid local search\n    # Step 1: Randomly select a segment to insert elsewhere\n    a = random.randint(0, n - 3)\n    b = random.randint(a + 1, n - 2)\n    segment = new_solution[a:b+1]\n\n    # Step 2: Remove the segment and insert it at a new position\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Step 3: Randomly swap two nodes with probability based on cost improvement\n    i, j = random.sample(range(n), 2)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Accept swap if at least one objective improves\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.808306659805302,
            9.712745174338405
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified: select the one with the best combined score)\n        scores = [sum(obj) for _, obj in archive]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly select two non-adjacent segments\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Step 2: Reverse the middle segment\n    middle_segment = new_solution[i+1:j]\n    new_solution[i+1:j] = middle_segment[::-1]\n\n    # Step 3: Randomly swap two edges if beneficial\n    k = random.randint(0, n - 2)\n    l = random.randint(k + 1, n - 1)\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n    new_cost1 = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l-1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n    new_cost2 = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l-1], new_solution[k]]\n\n    # Apply swap if beneficial for at least one objective\n    if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            6.105070278368307,
            5.931977199948847
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a promising solution from the archive by prioritizing those with high Pareto dominance or diverse objective values, then applies a combination of edge exchange and segment reversal operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_score = float('inf')\n    for idx, (sol, obj) in enumerate(archive):\n        score = obj[0] + obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = idx\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Select three random non-adjacent nodes\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Step 2: Perform a 3-opt move (a, b, c) -> (a, c, b)\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Step 3: Check if the move improves at least one objective\n    def calculate_cost(sol, matrix):\n        cost = 0\n        for i in range(n):\n            cost += matrix[sol[i-1], sol[i]]\n        return cost\n\n    current_cost1 = calculate_cost(base_solution, distance_matrix_1)\n    current_cost2 = calculate_cost(base_solution, distance_matrix_2)\n    new_cost1 = calculate_cost(new_solution, distance_matrix_1)\n    new_cost2 = calculate_cost(new_solution, distance_matrix_2)\n\n    if (new_cost1 > current_cost1 and new_cost2 > current_cost2):\n        # If the move worsens both objectives, try another approach\n        # Step 4: Perform a node insertion\n        node = random.randint(0, n-1)\n        pos = random.randint(0, n-1)\n        if node != pos:\n            new_solution = np.concatenate([new_solution[:pos], [new_solution[node]], new_solution[pos:node], new_solution[node+1:]])\n\n    return new_solution\n\n",
        "score": [
            6.3534887732394685,
            5.736407845752355
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a combination of Pareto dominance and crowding distance to identify promising candidates, then applies a novel hybrid operator that combines segment reversal with adaptive edge insertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by Pareto dominance (simplified)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        selected_idx = random.randint(0, len(selection_pool) - 1)\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Hybrid operator: Segment reversal with adaptive edge insertion\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Reverse segment\n    new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        k = random.randint(0, n - 2)\n        l = random.randint(k + 1, n - 1)\n\n        # Calculate potential improvement\n        delta1 = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta2 = (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[k]]) - \\\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        # Apply if beneficial for at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            5.869790419061286,
            6.143612667861421
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm prioritizes solutions with high Pareto dominance or diverse objective values, then applies a combination of edge insertion and segment rotation operations to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Randomly select a segment and rotate it\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(i, j)\n    segment = new_solution[i:j+1]\n    rotated_segment = np.concatenate([segment[k-j+i:], segment[:k-j+i]])\n    new_solution[i:j+1] = rotated_segment\n\n    # Step 2: Randomly insert a node into a different position\n    m = random.randint(0, n - 1)\n    node = new_solution[m]\n    new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n    pos = random.randint(0, n - 2)\n    new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.102176592890957,
            6.013121299168331
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm selects a solution from the archive based on its objective diversity and applies a combination of segment insertion and edge reversal operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = [obj for _, obj in archive]\n        max_diff = max(obj[0] - obj[1] for obj in objectives)\n        selected_idx = [i for i, obj in enumerate(objectives) if abs(obj[0] - obj[1]) == max_diff][0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Apply segment insertion\n    i = random.randint(0, n - 3)\n    j = random.randint(i + 1, n - 2)\n    k = random.randint(0, n - 1)\n\n    if k < i or k > j:\n        inserted_segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], inserted_segment, new_solution[k+1:]])\n\n    # Apply edge reversal if beneficial\n    k = random.randint(0, n - 2)\n    current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[k+1]]\n    reversed_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k+1]] + distance_matrix_1[new_solution[k+1], new_solution[k]]\n\n    current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[k+1]]\n    reversed_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k+1]] + distance_matrix_2[new_solution[k+1], new_solution[k]]\n\n    if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n        new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            10.372027483411268,
            5.052907828361045
        ]
    }
]