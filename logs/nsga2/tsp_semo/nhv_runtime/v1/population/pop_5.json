[
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation, probabilistic node swapping with objective-aware distance evaluation, and dynamic path reversal to intelligently explore the solution space while maintaining feasibility and improving both objectives through coordinated multi-objective operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_size = max(2, min(4, n // 4))\n    pos = random.randint(0, n - segment_size)\n    rotation = random.randint(1, segment_size - 1)\n    segment = new_solution[pos:pos+segment_size]\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[pos:pos+segment_size] = rotated_segment\n\n    # Step 2: Probabilistic node swapping with objective-aware evaluation\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.5 if random.random() < 0.6 else 0.3\n        if (obj1_weight * swapped_cost1 + (1-obj1_weight) * swapped_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Dynamic path reversal with multi-objective consideration\n    if random.random() < 0.4:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k-1)%n]] for k in range(j, i, -1))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k-1)%n]] for k in range(j, i, -1))\n\n        obj1_weight = 0.7 if random.random() < 0.5 else 0.3\n        if (obj1_weight * reversed_cost1 + (1-obj1_weight) * reversed_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9602842910874554,
            0.2636159658432007
        ]
    },
    {
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment swapping, probabilistic node reinsertion, and objective-balanced path inversion to dynamically explore the solution space while maintaining feasibility and improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        candidates = archive\n\n    selected = random.choice(candidates)[0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment swapping\n    segment_size = max(2, min(3, n // 5))\n    pos1 = random.randint(0, n - segment_size)\n    pos2 = random.randint(0, n - segment_size)\n    new_solution[pos1:pos1+segment_size], new_solution[pos2:pos2+segment_size] = new_solution[pos2:pos2+segment_size], new_solution[pos1:pos1+segment_size]\n\n    # Step 2: Probabilistic node reinsertion\n    if random.random() < 0.7:\n        node = random.choice(new_solution)\n        pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Step 3: Objective-balanced path inversion\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        inverted_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        obj1_weight = 0.6 if random.random() < 0.7 else 0.4\n        if (obj1_weight * inverted_cost1 + (1-obj1_weight) * inverted_cost2) < (obj1_weight * current_cost1 + (1-obj1_weight) * current_cost2):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7745000102125286,
            0.06662243604660034
        ]
    }
]