[
    {
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9923102465417057,
            0.230221688747406
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9389992377726866,
            0.18591547012329102
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0064181753853354,
            0.4140263795852661
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0350424674889869,
            0.49663078784942627
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8759493807575216,
            0.17495423555374146
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8345361605740647,
            0.14241671562194824
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9205087007677362,
            0.21705639362335205
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9091279867947812,
            0.1901167631149292
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9713735390620513,
            0.23788714408874512
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8055914123336299,
            0.16598361730575562
        ]
    }
]