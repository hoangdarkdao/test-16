[
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Hybrid Segment Fusion with Dynamic Node Rebalancing,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first identifying and fusing the most complementary segments from different solutions in the archive, then dynamically rebalancing the tour by selectively replacing nodes based on their cross-dimensional contribution scores. This method combines segment fusion with a novel node replacement mechanism that evaluates each node's potential to improve both objectives simultaneously, using a probabilistic acceptance criterion that considers both immediate improvement and long-term solution balance, while maintaining tour feasibility through a two-phase validation process that checks both segment connectivity and node uniqueness.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify the best segments from different solutions\n    best_segments = []\n    for solution, _ in archive[:3]:  # Consider top 3 solutions\n        n = len(solution)\n        segment_length = max(2, n // 5)\n        for i in range(0, n, segment_length):\n            segment = solution[i:i+segment_length]\n            if len(segment) > 1:\n                best_segments.append(segment)\n\n    if not best_segments:\n        best_segments = [archive[0][0][:3]]\n\n    # Step 2: Create initial solution by combining complementary segments\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    for seg in best_segments:\n        new_solution.extend(seg)\n        for node in seg:\n            remaining_nodes.discard(node)\n\n    # Step 3: Dynamic node rebalancing\n    for _ in range(3):  # Perform 3 rebalancing iterations\n        for i in range(len(new_solution)):\n            node = new_solution[i]\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i+1] if i < len(new_solution)-1 else new_solution[0]\n\n            # Calculate current contribution to both objectives\n            current_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                              distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Find potential replacement nodes\n            candidates = list(remaining_nodes)\n            if not candidates:\n                break\n\n            for candidate in candidates:\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node] +\n                              distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node])\n\n                # Accept if improvement in both objectives\n                if new_contrib < current_contrib * 0.95:  # 5% improvement threshold\n                    new_solution[i] = candidate\n                    remaining_nodes.add(node)\n                    remaining_nodes.remove(candidate)\n                    break\n\n    # Step 4: Insert remaining nodes\n    remaining_nodes = list(remaining_nodes)\n    while remaining_nodes:\n        best_node = None\n        best_pos = -1\n        best_score = float('inf')\n\n        for node in remaining_nodes:\n            for i in range(len(new_solution)):\n                if i == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[i-1]\n                    next_node = new_solution[i]\n\n                score = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                        distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n                    best_pos = i\n\n        if best_node is not None:\n            new_solution.insert(best_pos, best_node)\n            remaining_nodes.remove(best_node)\n        else:\n            new_solution.extend(remaining_nodes)\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(set(new_solution[:-1])) == len(instance), \"Generated solution is not feasible\"\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8144581164160893,
               0.09934872388839722
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Segment Fusion with Adaptive Node Fusion and Objective-Weighted Reallocation,\" builds upon the segment-based approach but introduces a fundamentally different strategy by first identifying and fusing the most complementary segments from different solutions in the archive, then adaptively fusing nodes based on their cross-dimensional contribution scores, followed by an objective-weighted reallocation phase that probabilistically reorders segments to explore alternative configurations, while dynamically adjusting the fusion and reallocation parameters based on the current solution's objective balance, and ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into segments based on cross-dimensional contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        total_cost = cost1 + cost2\n\n        if total_cost > 1.5 * (cost1 + cost2) / 2:  # High cross-dimensional variance\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [new_solution[:n//2], new_solution[n//2:]]\n\n    # Step 3: Adaptive node fusion within segments\n    fused_segments = []\n    for segment in segments:\n        if len(segment) < 3:\n            fused_segments.append(segment)\n            continue\n\n        # Calculate segment costs\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Adaptive fusion based on objective balance\n        if cost1 > 1.3 * cost2:\n            # Merge nodes with similar contribution to objective 1\n            fused_segment = []\n            i = 0\n            while i < len(segment):\n                if i + 1 < len(segment):\n                    node1 = segment[i]\n                    node2 = segment[i+1]\n                    contrib1 = distance_matrix_1[segment[i-1], node1] + distance_matrix_1[node1, node2]\n                    contrib2 = distance_matrix_1[segment[i-1], node2] + distance_matrix_1[node2, segment[i+2] if i+2 < len(segment) else segment[0]]\n\n                    if abs(contrib1 - contrib2) < 0.1 * (contrib1 + contrib2):\n                        fused_segment.append(node1)\n                        i += 2\n                    else:\n                        fused_segment.append(node1)\n                        i += 1\n                else:\n                    fused_segment.append(segment[i])\n                    i += 1\n            fused_segments.append(fused_segment)\n        else:\n            fused_segments.append(segment)\n\n    # Step 4: Objective-weighted segment reallocation\n    if len(fused_segments) > 1:\n        for i in range(len(fused_segments)):\n            if len(fused_segments[i]) < 2:\n                continue\n\n            cost1 = sum(distance_matrix_1[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n            cost2 = sum(distance_matrix_2[fused_segments[i][j], fused_segments[i][j+1]] for j in range(len(fused_segments[i])-1))\n\n            if cost1 > 1.2 * cost2:\n                if random.random() < 0.5:\n                    # Reallocate nodes to better balance objectives\n                    segment = fused_segments[i]\n                    new_segment = []\n                    for j in range(len(segment)):\n                        node = segment[j]\n                        prev_node = segment[j-1] if j > 0 else segment[-1]\n                        next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                        if cost1 > 1.2 * cost2:\n                            # Find better node to replace with\n                            candidates = [k for k in range(len(instance)) if k not in segment]\n                            if candidates:\n                                best_node = None\n                                best_score = float('inf')\n                                for candidate in candidates:\n                                    new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                                    new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                                    score = abs(new_cost1 - new_cost2)\n                                    if score < best_score:\n                                        best_score = score\n                                        best_node = candidate\n                                if best_node is not None:\n                                    new_segment.append(best_node)\n                                else:\n                                    new_segment.append(node)\n                        else:\n                            new_segment.append(node)\n                    fused_segments[i] = new_segment\n\n    # Step 5: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9513067335199508,
               0.12776219844818115
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.8491913871509116,
               0.11022323369979858
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Multi-Objective Segment Fusion with Dynamic Objective-Weighted Node Replacement,\" builds upon the common segment-based approach from the provided algorithms but introduces a fundamentally different mechanism by first adaptively identifying the most complementary segments from different solutions in the archive, then dynamically fusing and rebalancing these segments through an objective-weighted node replacement process that evaluates each node's potential contribution to both objectives using a probabilistic acceptance criterion that balances immediate improvement with long-term solution balance, while maintaining tour feasibility through a two-phase validation process that ensures both segment connectivity and node uniqueness, and dynamically adjusts the fusion and replacement parameters based on the current solution's objective balance and the distribution of nodes in the two objective spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify critical segments based on cross-dimensional variance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        variance = abs(cost1 - cost2)\n\n        if variance > 0.5 * (cost1 + cost2):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 3: Adaptive segment fusion with dynamic objective weighting\n    fused_segments = []\n    for i in range(len(segments)):\n        if len(segments[i]) < 2:\n            fused_segments.append(segments[i])\n            continue\n\n        segment = segments[i]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n\n        # Determine fusion strategy based on objective balance\n        if cost1 > 1.2 * cost2:\n            # Prioritize objective 2\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost2 > 1.2 * current_cost1:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n        else:\n            # Prioritize objective 1\n            for j in range(len(segment)):\n                node = segment[j]\n                prev_node = segment[j-1] if j > 0 else segment[-1]\n                next_node = segment[j+1] if j < len(segment)-1 else segment[0]\n\n                current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n                if current_cost1 > 1.2 * current_cost2:\n                    # Find better node to replace with\n                    candidates = [k for k in range(len(instance)) if k not in segment]\n                    if candidates:\n                        best_node = None\n                        best_score = float('inf')\n                        for candidate in candidates:\n                            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                            score = abs(new_cost1 - new_cost2)\n                            if score < best_score:\n                                best_score = score\n                                best_node = candidate\n                        if best_node is not None:\n                            segment[j] = best_node\n\n        fused_segments.append(segment)\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in fused_segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            fused_segments[i] = fused_segments[i][::-1]\n            new_solution = []\n            for segment in fused_segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -1.0429478487615236,
               0.831392228603363
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Fusion with Adaptive Node Insertion,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first fusing paths from different objective spaces by identifying and merging the most complementary node sequences, then adaptively inserting nodes from the other space using a novel cross-dimensional insertion criterion that evaluates each node's potential contribution to both objectives while maintaining tour feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines path fusion with an adaptive insertion strategy that dynamically adjusts the insertion points based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify complementary node sequences from different objective spaces\n    obj1_sequence = []\n    obj2_sequence = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n\n        if cost1 < cost2:\n            obj1_sequence.append(node)\n        else:\n            obj2_sequence.append(node)\n\n    # Step 2: Merge sequences with adaptive insertion\n    merged_solution = []\n    i, j = 0, 0\n    while i < len(obj1_sequence) and j < len(obj2_sequence):\n        if random.random() < 0.6:  # 60% chance to take from obj1 sequence\n            merged_solution.append(obj1_sequence[i])\n            i += 1\n        else:\n            merged_solution.append(obj2_sequence[j])\n            j += 1\n\n    # Add remaining nodes\n    merged_solution.extend(obj1_sequence[i:])\n    merged_solution.extend(obj2_sequence[j:])\n\n    # Step 3: Adaptive node insertion from the other space\n    remaining_nodes = set(range(n)) - set(merged_solution)\n    for _ in range(3):  # Perform 3 adaptive insertions\n        if not remaining_nodes:\n            break\n\n        # Select a random node to insert\n        node = random.choice(list(remaining_nodes))\n\n        # Find the best insertion point based on cross-dimensional contribution\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(len(merged_solution)):\n            prev_node = merged_solution[i-1] if i > 0 else merged_solution[-1]\n            next_node = merged_solution[i]\n\n            # Calculate current contribution\n            current_contrib = (distance_matrix_1[prev_node, next_node] +\n                              distance_matrix_2[prev_node, next_node])\n\n            # Calculate potential new contribution\n            new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                          distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n            # Score based on improvement in both objectives\n            score = new_contrib - current_contrib\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            merged_solution.insert(best_pos, node)\n            remaining_nodes.remove(node)\n\n    # Step 4: Reconstruct solution and validate\n    if len(merged_solution) != n:\n        # Fallback: random shuffle\n        random.shuffle(merged_solution)\n        merged_solution = merged_solution[:n]\n\n    # Ensure circular tour\n    if merged_solution[0] != merged_solution[-1]:\n        merged_solution.append(merged_solution[0])\n\n    # Validate solution\n    assert len(set(merged_solution[:-1])) == n, \"Generated solution is not feasible\"\n\n    return np.array(merged_solution)\n\n",
          "score": [
               -0.9782080321022513,
               0.14694750308990479
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Path Realignment with Dynamic Segment Reconfiguration,\" builds upon the common backbone of segment-based improvement from the provided algorithms but introduces a fundamentally different approach by first analyzing the solution's objective contributions at each edge, then dynamically reconfiguring the tour by realigning segments based on their primary objective dominance, followed by a probabilistic segment reordering phase that reorders segments to optimize both objectives simultaneously, while maintaining feasibility through a dynamic validation mechanism that ensures node uniqueness and circularity in the reconstructed tour. This method combines objective-driven path realignment with dynamic segment reconfiguration, allowing for both fine-grained local improvements and more disruptive global explorations.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution based on combined objective scores\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Analyze objective contributions at each edge\n    edge_contributions = []\n    for i in range(n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1 = distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[node, next_node]\n        edge_contributions.append((cost1, cost2))\n\n    # Step 2: Dynamic segment reconfiguration\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = 1 if edge_contributions[0][0] < edge_contributions[0][1] else 2\n\n    for i in range(1, n):\n        node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n        cost1, cost2 = edge_contributions[i]\n\n        if (current_obj == 1 and cost1 < cost2) or (current_obj == 2 and cost2 < cost1):\n            current_segment.append(node)\n        else:\n            segments.append((current_obj, current_segment))\n            current_segment = [node]\n            current_obj = 3 - current_obj\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Step 3: Probabilistic segment reordering\n    if len(segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in segments if obj == 1]\n        obj2_segments = [seg for obj, seg in segments if obj == 2]\n\n        # Reorder segments with probability based on their objective dominance\n        new_segments = []\n        while obj1_segments or obj2_segments:\n            if obj1_segments and (not obj2_segments or random.random() < 0.7):\n                new_segments.append((1, obj1_segments.pop(0)))\n            elif obj2_segments:\n                new_segments.append((2, obj2_segments.pop(0)))\n\n        # Reconstruct solution\n        new_solution = []\n        for _, seg in new_segments:\n            new_solution.extend(seg)\n\n    # Step 4: Reconstruct solution and validate\n    if len(new_solution) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            _, seg = segments[i]\n            segments[i] = (3 - segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in segments:\n                new_solution.extend(seg)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        random.shuffle(new_solution)\n        new_solution = new_solution[:n]\n        new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9625441946222131,
               0.1361600160598755
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Cross-Dimensional Path Realignment with Objective-Guided Segment Transfer,\" departs from the segment-based approach by first identifying the most dominant objective for each segment in the solution, then realigning the entire path by transferring entire segments between objectives based on their current contribution, while dynamically adjusting the transfer criteria based on the current objective balance, and ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity while maintaining the original segment boundaries, thus allowing for both fine-grained local improvements and more disruptive global explorations through cross-dimensional segment transfers.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the most balanced objectives\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify segments and their dominant objectives\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if cost1 > 1.2 * cost2 or cost2 > 1.2 * cost1:\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append(current_segment)\n\n    # Step 2: Calculate segment objectives\n    segment_objectives = []\n    for segment in segments:\n        total_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        total_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_objectives.append((total_cost1, total_cost2))\n\n    # Step 3: Transfer segments between objectives based on balance\n    for i in range(len(segments)):\n        seg_cost1, seg_cost2 = segment_objectives[i]\n\n        if seg_cost1 > 1.2 * seg_cost2:\n            # Find target segment to transfer to objective 2\n            for j in range(len(segments)):\n                if i == j:\n                    continue\n                tar_cost1, tar_cost2 = segment_objectives[j]\n\n                if tar_cost2 > 1.2 * tar_cost1:\n                    # Calculate potential new objectives\n                    new_cost1 = seg_cost1 + tar_cost1\n                    new_cost2 = seg_cost2 + tar_cost2\n\n                    if abs(new_cost1 - new_cost2) < abs(seg_cost1 - seg_cost2) + abs(tar_cost1 - tar_cost2):\n                        # Perform transfer\n                        segments[i], segments[j] = segments[j], segments[i]\n                        segment_objectives[i], segment_objectives[j] = segment_objectives[j], segment_objectives[i]\n                        break\n        elif seg_cost2 > 1.2 * seg_cost1:\n            # Find target segment to transfer to objective 1\n            for j in range(len(segments)):\n                if i == j:\n                    continue\n                tar_cost1, tar_cost2 = segment_objectives[j]\n\n                if tar_cost1 > 1.2 * tar_cost2:\n                    # Calculate potential new objectives\n                    new_cost1 = seg_cost1 + tar_cost1\n                    new_cost2 = seg_cost2 + tar_cost2\n\n                    if abs(new_cost1 - new_cost2) < abs(seg_cost1 - seg_cost2) + abs(tar_cost1 - tar_cost2):\n                        # Perform transfer\n                        segments[i], segments[j] = segments[j], segments[i]\n                        segment_objectives[i], segment_objectives[j] = segment_objectives[j], segment_objectives[i]\n                        break\n\n    # Step 4: Reconstruct solution and validate\n    new_solution = []\n    for segment in segments:\n        new_solution.extend(segment)\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    # Validate solution\n    unique_nodes = np.unique(new_solution[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random segment reversal\n        if len(segments) > 1:\n            i = random.randint(0, len(segments)-1)\n            segments[i] = segments[i][::-1]\n            new_solution = []\n            for segment in segments:\n                new_solution.extend(segment)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9923855503172652,
               0.17020666599273682
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9247689985299495,
               0.11786341667175293
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Balanced Node Diffusion with Adaptive Multi-Dimensional Rebalancing,\" fundamentally departs from both previous approaches by first identifying critical nodes through a novel multi-dimensional diffusion analysis that evaluates each node's influence across both objectives using a combined centrality metric, then dynamically redistributes these nodes through an adaptive diffusion process that probabilistically spreads nodes based on their current objective imbalance while maintaining feasibility through a dynamic neighborhood validation mechanism that ensures node uniqueness and circularity, and finally refines the solution through an adaptive objective-balancing strategy that iteratively reallocates nodes between objectives based on their current contribution ratios, dynamically adjusting the diffusion and balancing parameters during the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most balanced solution from the archive\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Calculate node diffusion scores\n    diffusion_scores = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate current contributions\n        contrib1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        contrib2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        # Calculate potential contributions if moved\n        potential_contrib1 = distance_matrix_1[prev_node, next_node]\n        potential_contrib2 = distance_matrix_2[prev_node, next_node]\n\n        # Diffusion score combines both objectives\n        diffusion_score = (contrib1 + contrib2) - (potential_contrib1 + potential_contrib2)\n        diffusion_scores.append((node, diffusion_score))\n\n    # Step 3: Sort nodes by diffusion score\n    diffusion_scores.sort(key=lambda x: x[1], reverse=True)\n\n    # Step 4: Dynamic node diffusion\n    diffused_nodes = []\n    remaining_nodes = set(range(n))\n    for node, score in diffusion_scores:\n        if node in remaining_nodes:\n            # Find best diffusion position\n            best_pos = -1\n            best_score = float('inf')\n\n            for i in range(len(diffused_nodes)):\n                prev_node = diffused_nodes[i-1] if i > 0 else diffused_nodes[-1]\n                next_node = diffused_nodes[i]\n\n                # Calculate current contribution\n                current_contrib = (distance_matrix_1[prev_node, next_node] +\n                                 distance_matrix_2[prev_node, next_node])\n\n                # Calculate potential new contribution\n                new_contrib = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] +\n                             distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node])\n\n                # Score based on improvement in both objectives\n                score_diff = new_contrib - current_contrib\n\n                if score_diff < best_score:\n                    best_score = score_diff\n                    best_pos = i\n\n            if best_pos != -1:\n                diffused_nodes.insert(best_pos, node)\n                remaining_nodes.remove(node)\n\n    # Add remaining nodes\n    diffused_nodes.extend(list(remaining_nodes))\n\n    # Step 5: Adaptive objective balancing\n    for _ in range(5):  # Perform 5 balancing steps\n        i = random.randint(0, len(diffused_nodes)-1)\n        j = random.randint(0, len(diffused_nodes)-1)\n        if i != j:\n            # Calculate current cost\n            prev_i = diffused_nodes[i-1] if i > 0 else diffused_nodes[-1]\n            next_i = diffused_nodes[(i+1) % len(diffused_nodes)]\n            prev_j = diffused_nodes[j-1] if j > 0 else diffused_nodes[-1]\n            next_j = diffused_nodes[(j+1) % len(diffused_nodes)]\n\n            current_cost1 = distance_matrix_1[prev_i, diffused_nodes[i]] + distance_matrix_1[diffused_nodes[i], next_i]\n            current_cost2 = distance_matrix_2[prev_i, diffused_nodes[i]] + distance_matrix_2[diffused_nodes[i], next_i]\n            current_cost1 += distance_matrix_1[prev_j, diffused_nodes[j]] + distance_matrix_1[diffused_nodes[j], next_j]\n            current_cost2 += distance_matrix_2[prev_j, diffused_nodes[j]] + distance_matrix_2[diffused_nodes[j], next_j]\n\n            # Calculate potential cost with swapped nodes\n            new_cost1 = distance_matrix_1[prev_i, diffused_nodes[j]] + distance_matrix_1[diffused_nodes[j], next_i]\n            new_cost2 = distance_matrix_2[prev_i, diffused_nodes[j]] + distance_matrix_2[diffused_nodes[j], next_i]\n            new_cost1 += distance_matrix_1[prev_j, diffused_nodes[i]] + distance_matrix_1[diffused_nodes[i], next_j]\n            new_cost2 += distance_matrix_2[prev_j, diffused_nodes[i]] + distance_matrix_2[diffused_nodes[i], next_j]\n\n            # Accept swap if it improves the balance\n            if abs(new_cost1 - new_cost2) < abs(current_cost1 - current_cost2):\n                diffused_nodes[i], diffused_nodes[j] = diffused_nodes[j], diffused_nodes[i]\n\n    # Step 6: Reconstruct solution and validate\n    if diffused_nodes[0] != diffused_nodes[-1]:\n        diffused_nodes.append(diffused_nodes[0])\n\n    # Ensure circular tour and no duplicates\n    unique_nodes = np.unique(diffused_nodes[:-1])\n    if len(unique_nodes) != n:\n        # Fallback: random shuffle\n        diffused_nodes = list(range(n))\n        random.shuffle(diffused_nodes)\n        diffused_nodes.append(diffused_nodes[0])\n\n    return np.array(diffused_nodes)\n\n",
          "score": [
               -0.9957055879287147,
               0.2439439296722412
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Adaptive Objective-Centric Tour Decomposition with Cross-Objective Segment Fusion,\" builds upon the common backbone of solution selection and tour decomposition from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's objective distributions, then decomposes the tour into segments based on their primary objective contribution (either objective 1 or 2), using a novel \"objective-centric\" metric that classifies each segment as belonging to one of the two objective spaces. These segments are then fused across objectives using an adaptive strategy that dynamically combines segments from both objectives while maintaining their relative order, followed by a \"cross-objective segment interleaving\" phase that probabilistically interleaves segments from both objectives to explore alternative configurations. The method dynamically adjusts the decomposition and fusion parameters based on the current solution's objective balance, allowing for both fine-grained local improvements and more disruptive global explorations, while ensuring feasibility through a segment validation mechanism that checks for node uniqueness and circularity in the reconstructed tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Decompose tour into objective-centric segments\n    segments = []\n    current_segment = [new_solution[0]]\n    current_obj = None\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n\n        if current_obj is None:\n            if cost1 > cost2:\n                current_obj = 1\n            else:\n                current_obj = 2\n            current_segment.append(current_node)\n        else:\n            if (current_obj == 1 and cost1 < cost2 * 0.8) or (current_obj == 2 and cost2 < cost1 * 0.8):\n                segments.append((current_obj, current_segment))\n                current_segment = [current_node]\n                current_obj = 3 - current_obj  # Switch objective\n            else:\n                current_segment.append(current_node)\n\n    if len(current_segment) > 0:\n        segments.append((current_obj, current_segment))\n\n    # Ensure at least two segments exist\n    if len(segments) < 2:\n        segments = [(1, new_solution[:n//2]), (2, new_solution[n//2:])]\n\n    # Step 3: Cross-objective segment fusion\n    fused_segments = []\n    i = 0\n    while i < len(segments):\n        obj1, seg1 = segments[i]\n        if i + 1 < len(segments):\n            obj2, seg2 = segments[i+1]\n            if obj1 != obj2 and random.random() < 0.5:\n                # Fuse segments from different objectives\n                fused_segment = seg1 + seg2\n                fused_segments.append((obj1, fused_segment))\n                i += 2\n            else:\n                fused_segments.append((obj1, seg1))\n                i += 1\n        else:\n            fused_segments.append((obj1, seg1))\n            i += 1\n\n    # Step 4: Cross-objective segment interleaving\n    if len(fused_segments) > 1:\n        # Separate segments by objective\n        obj1_segments = [seg for obj, seg in fused_segments if obj == 1]\n        obj2_segments = [seg for obj, seg in fused_segments if obj == 2]\n\n        # Interleave segments from both objectives\n        new_solution = []\n        i, j = 0, 0\n        while i < len(obj1_segments) or j < len(obj2_segments):\n            if i < len(obj1_segments) and (j >= len(obj2_segments) or random.random() < 0.5):\n                new_solution.extend(obj1_segments[i])\n                i += 1\n            else:\n                new_solution.extend(obj2_segments[j])\n                j += 1\n\n    # Step 5: Reconstruct solution and validate\n    if new_solution[0] != new_solution[-1]:\n        new_solution.append(new_solution[0])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n + 1:\n        # Fallback: random segment reversal\n        if len(fused_segments) > 1:\n            i = random.randint(0, len(fused_segments)-1)\n            _, seg = fused_segments[i]\n            fused_segments[i] = (3 - fused_segments[i][0], seg[::-1])\n            new_solution = []\n            for _, seg in fused_segments:\n                new_solution.extend(seg)\n            new_solution.append(new_solution[0])\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.8855038623380989,
               0.12278997898101807
          ]
     }
]