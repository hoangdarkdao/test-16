[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: select a random segment and either reverse it or insert it elsewhere\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of length 2 to 4\n        seg_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start + seg_length]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + seg_length:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6095301305355113,
            0.47597694396972656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: select a random segment and either reverse it or insert it elsewhere\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of length 2 to 4\n        seg_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start + seg_length]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + seg_length:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: select a random segment and either reverse it or insert it elsewhere\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of length 2 to 4\n        seg_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start + seg_length]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + seg_length:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6095301305355113,
            0.47597694396972656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: select a random segment and either reverse it or insert it elsewhere\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of length 2 to 4\n        seg_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start + seg_length]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + seg_length:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: select a random segment and either reverse it or insert it elsewhere\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of length 2 to 4\n        seg_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start + seg_length]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + seg_length:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6095301305355113,
            0.47597694396972656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: select a random segment and either reverse it or insert it elsewhere\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment of length 2 to 4\n        seg_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start + seg_length]\n\n        # With 50% probability, reverse the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + seg_length:]])\n\n        # Insert the segment at a random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a solution from the archive by prioritizing those with the highest crowding distance (indicating under-explored regions) or dominated solutions (potential for improvement), then applies a hybrid local search combining 3-opt with a novel edge-swapping strategy to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or dominated solutions\n    def crowding_distance(solutions, objectives):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n        objectives = np.array(objectives)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[0] = distances[-1] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance([sol for sol, _ in archive], objectives)\n    max_distance_idx = np.argmax(distances)\n    base_solution = archive[max_distance_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Apply 3-opt-like move\n    options = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Select the best option based on both objectives\n    def calculate_cost(solution, dist_mat1, dist_mat2):\n        cost1 = sum(dist_mat1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += dist_mat1[solution[-1], solution[0]]\n        cost2 = sum(dist_mat2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += dist_mat2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n    best_option = new_solution\n    best_cost1, best_cost2 = current_cost1, current_cost2\n\n    for option in options:\n        cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_option = option\n            best_cost1, best_cost2 = cost1, cost2\n\n    new_solution = best_option\n\n    # Edge-swapping for further improvement\n    for _ in range(2):  # Limit iterations to maintain efficiency\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue\n        if i > j:\n            i, j = j, i\n        # Try swapping edges\n        option1 = new_solution.copy()\n        option1[i], option1[j] = option1[j], option1[i]\n        # Try reversing segment\n        option2 = new_solution.copy()\n        option2[i:j+1] = option2[i:j+1][::-1]\n\n        for option in [option1, option2]:\n            cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                new_solution = option\n                best_cost1, best_cost2 = cost1, cost2\n\n    return new_solution\n\n",
        "score": [
            -0.8994382120367075,
            1.211432933807373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or dominated solutions\n    def crowding_distance(solutions, objectives):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n        objectives = np.array(objectives)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[0] = distances[-1] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance([sol for sol, _ in archive], objectives)\n    max_distance_idx = np.argmax(distances)\n    base_solution = archive[max_distance_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Apply 3-opt-like move\n    options = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Select the best option based on both objectives\n    def calculate_cost(solution, dist_mat1, dist_mat2):\n        cost1 = sum(dist_mat1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += dist_mat1[solution[-1], solution[0]]\n        cost2 = sum(dist_mat2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += dist_mat2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n    best_option = new_solution\n    best_cost1, best_cost2 = current_cost1, current_cost2\n\n    for option in options:\n        cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_option = option\n            best_cost1, best_cost2 = cost1, cost2\n\n    new_solution = best_option\n\n    # Edge-swapping for further improvement\n    for _ in range(2):  # Limit iterations to maintain efficiency\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue\n        if i > j:\n            i, j = j, i\n        # Try swapping edges\n        option1 = new_solution.copy()\n        option1[i], option1[j] = option1[j], option1[i]\n        # Try reversing segment\n        option2 = new_solution.copy()\n        option2[i:j+1] = option2[i:j+1][::-1]\n\n        for option in [option1, option2]:\n            cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                new_solution = option\n                best_cost1, best_cost2 = cost1, cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a solution from the archive by prioritizing those with the highest crowding distance (indicating under-explored regions) or dominated solutions (potential for improvement), then applies a hybrid local search combining 3-opt with a novel edge-swapping strategy to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or dominated solutions\n    def crowding_distance(solutions, objectives):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n        objectives = np.array(objectives)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[0] = distances[-1] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance([sol for sol, _ in archive], objectives)\n    max_distance_idx = np.argmax(distances)\n    base_solution = archive[max_distance_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Apply 3-opt-like move\n    options = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Select the best option based on both objectives\n    def calculate_cost(solution, dist_mat1, dist_mat2):\n        cost1 = sum(dist_mat1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += dist_mat1[solution[-1], solution[0]]\n        cost2 = sum(dist_mat2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += dist_mat2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n    best_option = new_solution\n    best_cost1, best_cost2 = current_cost1, current_cost2\n\n    for option in options:\n        cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_option = option\n            best_cost1, best_cost2 = cost1, cost2\n\n    new_solution = best_option\n\n    # Edge-swapping for further improvement\n    for _ in range(2):  # Limit iterations to maintain efficiency\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue\n        if i > j:\n            i, j = j, i\n        # Try swapping edges\n        option1 = new_solution.copy()\n        option1[i], option1[j] = option1[j], option1[i]\n        # Try reversing segment\n        option2 = new_solution.copy()\n        option2[i:j+1] = option2[i:j+1][::-1]\n\n        for option in [option1, option2]:\n            cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                new_solution = option\n                best_cost1, best_cost2 = cost1, cost2\n\n    return new_solution\n\n",
        "score": [
            -0.8994382120367075,
            1.211432933807373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or dominated solutions\n    def crowding_distance(solutions, objectives):\n        if len(solutions) < 2:\n            return [1.0] * len(solutions)\n        objectives = np.array(objectives)\n        sorted_indices = np.argsort(objectives[:, 0])\n        sorted_objectives = objectives[sorted_indices]\n        distances = np.zeros(len(solutions))\n        distances[0] = distances[-1] = float('inf')\n        for i in range(1, len(solutions) - 1):\n            distances[sorted_indices[i]] = sorted_objectives[i + 1, 0] - sorted_objectives[i - 1, 0]\n        return distances\n\n    objectives = [obj for _, obj in archive]\n    distances = crowding_distance([sol for sol, _ in archive], objectives)\n    max_distance_idx = np.argmax(distances)\n    base_solution = archive[max_distance_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Apply 3-opt-like move\n    options = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Select the best option based on both objectives\n    def calculate_cost(solution, dist_mat1, dist_mat2):\n        cost1 = sum(dist_mat1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += dist_mat1[solution[-1], solution[0]]\n        cost2 = sum(dist_mat2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += dist_mat2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n    best_option = new_solution\n    best_cost1, best_cost2 = current_cost1, current_cost2\n\n    for option in options:\n        cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_option = option\n            best_cost1, best_cost2 = cost1, cost2\n\n    new_solution = best_option\n\n    # Edge-swapping for further improvement\n    for _ in range(2):  # Limit iterations to maintain efficiency\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue\n        if i > j:\n            i, j = j, i\n        # Try swapping edges\n        option1 = new_solution.copy()\n        option1[i], option1[j] = option1[j], option1[i]\n        # Try reversing segment\n        option2 = new_solution.copy()\n        option2[i:j+1] = option2[i:j+1][::-1]\n\n        for option in [option1, option2]:\n            cost1, cost2 = calculate_cost(option, distance_matrix_1, distance_matrix_2)\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                new_solution = option\n                best_cost1, best_cost2 = cost1, cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9178105329874824,
            0.679682195186615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9178105329874824,
            0.679682195186615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions by intelligently relocating nodes and reversing subpaths while balancing improvements in both objective spaces and maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion phase\n    for _ in range(3):\n        # Select a random node and remove it from the tour\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position considering both objectives\n        min_cost = float('inf')\n        best_pos = 0\n\n        for pos in range(n-1):\n            # Calculate cost for insertion at position pos\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path reversal phase\n    for _ in range(2):\n        # Select a random subpath to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+5, n-1))\n\n        # Calculate cost before reversal\n        prev_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        prev_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Reverse the subpath\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_solution[end]] + distance_matrix_1[new_solution[start], new_solution[(end+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_solution[end]] + distance_matrix_2[new_solution[start], new_solution[(end+1)%n]]\n\n        # If reversal worsens both objectives, revert it\n        if (new_cost1 > prev_cost1 and new_cost2 > prev_cost2):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8619335744396124,
            0.8445874452590942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion phase\n    for _ in range(3):\n        # Select a random node and remove it from the tour\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position considering both objectives\n        min_cost = float('inf')\n        best_pos = 0\n\n        for pos in range(n-1):\n            # Calculate cost for insertion at position pos\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path reversal phase\n    for _ in range(2):\n        # Select a random subpath to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, min(start+5, n-1))\n\n        # Calculate cost before reversal\n        prev_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        prev_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Reverse the subpath\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Calculate cost after reversal\n        new_cost1 = distance_matrix_1[new_solution[start-1], new_solution[end]] + distance_matrix_1[new_solution[start], new_solution[(end+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[start-1], new_solution[end]] + distance_matrix_2[new_solution[start], new_solution[(end+1)%n]]\n\n        # If reversal worsens both objectives, revert it\n        if (new_cost1 > prev_cost1 and new_cost2 > prev_cost2):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search strategy that combines multi-scale segment inversion with adaptive edge insertion to explore high-quality solutions in both objective spaces by dynamically adjusting segment sizes and intelligently inserting edges while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment sizes based on problem size\n    n = len(new_solution)\n    segment_size_small = max(2, n // 6)\n    segment_size_large = max(3, n // 3)\n\n    # Multi-scale segment inversion\n    for _ in range(2):\n        # Randomly choose between small and large segments\n        if random.random() < 0.5:\n            seg_size = segment_size_small\n        else:\n            seg_size = segment_size_large\n\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(3):\n        # Select two distinct positions\n        i, j = random.sample(range(n), 2)\n\n        # Insert edge between them if it improves both objectives\n        if i != j:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            potential_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            potential_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Only insert if both objectives improve\n            if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n                # Perform the insertion\n                if i < j:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                else:\n                    new_solution[j+1:i+1] = new_solution[j+1:i+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8186684100115578,
            0.5358609557151794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment sizes based on problem size\n    n = len(new_solution)\n    segment_size_small = max(2, n // 6)\n    segment_size_large = max(3, n // 3)\n\n    # Multi-scale segment inversion\n    for _ in range(2):\n        # Randomly choose between small and large segments\n        if random.random() < 0.5:\n            seg_size = segment_size_small\n        else:\n            seg_size = segment_size_large\n\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive edge insertion\n    for _ in range(3):\n        # Select two distinct positions\n        i, j = random.sample(range(n), 2)\n\n        # Insert edge between them if it improves both objectives\n        if i != j:\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            potential_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            potential_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Only insert if both objectives improve\n            if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n                # Perform the insertion\n                if i < j:\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                else:\n                    new_solution[j+1:i+1] = new_solution[j+1:i+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive cluster-based rearrangement with dynamic objective-aware edge optimization to explore high-quality solutions by intelligently grouping nodes based on their spatial proximity in both objective spaces and then optimizing the tour structure while balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (closest to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Cluster nodes based on their positions in both objective spaces\n    n = len(new_solution)\n    clusters = []\n    visited = set()\n\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(i+1, n):\n                if j not in visited:\n                    node_i = new_solution[i]\n                    node_j = new_solution[j]\n                    # Check spatial proximity in both objective spaces\n                    dist1 = distance_matrix_1[node_i, node_j]\n                    dist2 = distance_matrix_2[node_i, node_j]\n                    if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                        cluster.append(j)\n                        visited.add(j)\n            if len(cluster) > 1:\n                clusters.append(cluster)\n\n    # Rearrange clusters in a new order\n    if clusters:\n        random.shuffle(clusters)\n        new_order = []\n        for cluster in clusters:\n            new_order.extend(cluster)\n        # Add remaining nodes not in any cluster\n        remaining = [i for i in range(n) if i not in new_order]\n        new_order.extend(remaining)\n        new_solution = new_solution[new_order]\n\n    # Dynamic objective-aware edge optimization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Decide which objective to optimize based on current solution quality\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            if obj1 > obj2:\n                # Focus on improving objective 1\n                if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(j+1)%n]] < \\\n                   distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j-1)%n]]:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Focus on improving objective 2\n                if distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(j+1)%n]] < \\\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j-1)%n]]:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7657449218938976,
            1.541605830192566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (closest to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Cluster nodes based on their positions in both objective spaces\n    n = len(new_solution)\n    clusters = []\n    visited = set()\n\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(i+1, n):\n                if j not in visited:\n                    node_i = new_solution[i]\n                    node_j = new_solution[j]\n                    # Check spatial proximity in both objective spaces\n                    dist1 = distance_matrix_1[node_i, node_j]\n                    dist2 = distance_matrix_2[node_i, node_j]\n                    if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                        cluster.append(j)\n                        visited.add(j)\n            if len(cluster) > 1:\n                clusters.append(cluster)\n\n    # Rearrange clusters in a new order\n    if clusters:\n        random.shuffle(clusters)\n        new_order = []\n        for cluster in clusters:\n            new_order.extend(cluster)\n        # Add remaining nodes not in any cluster\n        remaining = [i for i in range(n) if i not in new_order]\n        new_order.extend(remaining)\n        new_solution = new_solution[new_order]\n\n    # Dynamic objective-aware edge optimization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Decide which objective to optimize based on current solution quality\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            if obj1 > obj2:\n                # Focus on improving objective 1\n                if distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[(j+1)%n]] < \\\n                   distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j-1)%n]]:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                # Focus on improving objective 2\n                if distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[(j+1)%n]] < \\\n                   distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j-1)%n]]:\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{A novel local search strategy that combines multi-objective aware node insertion with dynamic segment reversal to explore Pareto-optimal regions by intelligently reordering nodes while maintaining feasibility and balancing improvement across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol, _ = max(archive_solutions, key=lambda x: -(x[1][0] + x[1][1]))\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n\n    # Multi-objective aware node insertion\n    for _ in range(3):\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx - 1) % n:\n                continue\n\n            # Calculate potential insertion cost\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            combined_score = cost1 + cost2\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = i\n\n        # Perform insertion\n        if best_pos != node_idx:\n            new_solution = np.roll(new_solution, -node_idx)\n            new_solution = np.roll(new_solution, best_pos - node_idx)\n            node_idx = best_pos\n\n    # Dynamic segment reversal with objective-aware selection\n    for _ in range(2):\n        # Select segment to reverse\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate segment's contribution to both objectives\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end))\n\n        # Calculate potential improvement if reversed\n        new_segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] for i in reversed(range(start, end)))\n        new_segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] for i in reversed(range(start, end)))\n\n        # Only reverse if it improves at least one objective\n        if (new_segment_cost1 < segment_cost1 or new_segment_cost2 < segment_cost2):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7406407311517137,
            0.8436449766159058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol, _ = max(archive_solutions, key=lambda x: -(x[1][0] + x[1][1]))\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n\n    # Multi-objective aware node insertion\n    for _ in range(3):\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion position based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == node_idx or i == (node_idx - 1) % n:\n                continue\n\n            # Calculate potential insertion cost\n            prev_node = new_solution[i-1]\n            next_node = new_solution[i]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            combined_score = cost1 + cost2\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = i\n\n        # Perform insertion\n        if best_pos != node_idx:\n            new_solution = np.roll(new_solution, -node_idx)\n            new_solution = np.roll(new_solution, best_pos - node_idx)\n            node_idx = best_pos\n\n    # Dynamic segment reversal with objective-aware selection\n    for _ in range(2):\n        # Select segment to reverse\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate segment's contribution to both objectives\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(start, end))\n\n        # Calculate potential improvement if reversed\n        new_segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i-1)%n]] for i in reversed(range(start, end)))\n        new_segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i-1)%n]] for i in reversed(range(start, end)))\n\n        # Only reverse if it improves at least one objective\n        if (new_segment_cost1 < segment_cost1 or new_segment_cost2 < segment_cost2):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path optimization to explore diverse high-quality solutions by strategically reinserting nodes and optimizing paths while balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 5))\n\n    # Adaptive node insertion\n    for _ in range(3):\n        node_to_move = random.randint(0, n - 1)\n        insert_pos = random.randint(0, n - 1)\n\n        if node_to_move != insert_pos:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n\n            # Calculate cost difference\n            original_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n\n            original_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n            # Accept if improvement in either objective\n            if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8529722953201333,
            0.5563496351242065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 5))\n\n    # Adaptive node insertion\n    for _ in range(3):\n        node_to_move = random.randint(0, n - 1)\n        insert_pos = random.randint(0, n - 1)\n\n        if node_to_move != insert_pos:\n            node = new_solution[node_to_move]\n            new_solution = np.delete(new_solution, node_to_move)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            segment = new_solution[i:j]\n            reversed_segment = segment[::-1]\n\n            # Calculate cost difference\n            original_cost1 = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n\n            original_cost2 = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n            # Accept if improvement in either objective\n            if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{An adaptive hybrid local search strategy that combines dynamic node clustering with multi-objective edge flipping to explore Pareto-optimal regions by intelligently grouping and rearranging nodes while balancing improvements in both objective spaces through guided edge modifications.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Dynamic node clustering based on spatial proximity in both objectives\n    n = len(new_solution)\n    cluster_size = max(2, min(4, n // 5))\n\n    # Create clusters of nodes that are close in both objective spaces\n    clusters = []\n    remaining_nodes = list(range(n))\n    while len(remaining_nodes) > cluster_size:\n        # Select a random node as cluster center\n        center = random.choice(remaining_nodes)\n        remaining_nodes.remove(center)\n\n        # Find closest nodes in both spaces\n        cluster = [center]\n        for _ in range(cluster_size - 1):\n            if not remaining_nodes:\n                break\n            # Calculate combined distance to center\n            distances = []\n            for node in remaining_nodes:\n                d1 = distance_matrix_1[center, node]\n                d2 = distance_matrix_2[center, node]\n                distances.append((d1 + d2, node))\n\n            # Select node with minimum combined distance\n            _, closest_node = min(distances, key=lambda x: x[0])\n            cluster.append(closest_node)\n            remaining_nodes.remove(closest_node)\n\n        clusters.append(cluster)\n\n    if remaining_nodes:\n        clusters.append(remaining_nodes)\n\n    # Multi-objective edge flipping within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Evaluate edges in both objective spaces\n        edges = []\n        for i in range(len(cluster)):\n            a = cluster[i]\n            b = cluster[(i+1)%len(cluster)]\n            cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, a]\n            cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, a]\n            edges.append((cost1 + cost2, a, b))\n\n        # Sort edges by combined cost\n        edges.sort()\n\n        # Flip edges with high combined cost\n        for _ in range(min(2, len(cluster)//2)):\n            if not edges:\n                break\n            _, a, b = edges.pop()\n            # Find positions of a and b in new_solution\n            pos_a = np.where(new_solution == a)[0][0]\n            pos_b = np.where(new_solution == b)[0][0]\n\n            # Flip the segment between a and b\n            if pos_a < pos_b:\n                new_solution[pos_a:pos_b+1] = new_solution[pos_a:pos_b+1][::-1]\n            else:\n                # Handle circular case\n                segment = np.concatenate([new_solution[pos_a:], new_solution[:pos_b+1]])\n                flipped = segment[::-1]\n                new_solution = np.concatenate([flipped[len(segment)-pos_b-1:], new_solution[pos_b+1:pos_a], flipped[:len(segment)-pos_b-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.9042047609840351,
            1.2708448767662048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Dynamic node clustering based on spatial proximity in both objectives\n    n = len(new_solution)\n    cluster_size = max(2, min(4, n // 5))\n\n    # Create clusters of nodes that are close in both objective spaces\n    clusters = []\n    remaining_nodes = list(range(n))\n    while len(remaining_nodes) > cluster_size:\n        # Select a random node as cluster center\n        center = random.choice(remaining_nodes)\n        remaining_nodes.remove(center)\n\n        # Find closest nodes in both spaces\n        cluster = [center]\n        for _ in range(cluster_size - 1):\n            if not remaining_nodes:\n                break\n            # Calculate combined distance to center\n            distances = []\n            for node in remaining_nodes:\n                d1 = distance_matrix_1[center, node]\n                d2 = distance_matrix_2[center, node]\n                distances.append((d1 + d2, node))\n\n            # Select node with minimum combined distance\n            _, closest_node = min(distances, key=lambda x: x[0])\n            cluster.append(closest_node)\n            remaining_nodes.remove(closest_node)\n\n        clusters.append(cluster)\n\n    if remaining_nodes:\n        clusters.append(remaining_nodes)\n\n    # Multi-objective edge flipping within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Evaluate edges in both objective spaces\n        edges = []\n        for i in range(len(cluster)):\n            a = cluster[i]\n            b = cluster[(i+1)%len(cluster)]\n            cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, a]\n            cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, a]\n            edges.append((cost1 + cost2, a, b))\n\n        # Sort edges by combined cost\n        edges.sort()\n\n        # Flip edges with high combined cost\n        for _ in range(min(2, len(cluster)//2)):\n            if not edges:\n                break\n            _, a, b = edges.pop()\n            # Find positions of a and b in new_solution\n            pos_a = np.where(new_solution == a)[0][0]\n            pos_b = np.where(new_solution == b)[0][0]\n\n            # Flip the segment between a and b\n            if pos_a < pos_b:\n                new_solution[pos_a:pos_b+1] = new_solution[pos_a:pos_b+1][::-1]\n            else:\n                # Handle circular case\n                segment = np.concatenate([new_solution[pos_a:], new_solution[:pos_b+1]])\n                flipped = segment[::-1]\n                new_solution = np.concatenate([flipped[len(segment)-pos_b-1:], new_solution[pos_b+1:pos_a], flipped[:len(segment)-pos_b-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{An adaptive tour fragmentation and recombination strategy that intelligently partitions the solution into multiple segments based on objective-specific edge importance, then reorders these segments using a hybrid of bi-objective-aware segment shifting and dynamic edge insertion to explore high-quality Pareto front solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance for both objectives\n    def calculate_edge_importance(sol, distance_matrix):\n        importance = np.zeros(n)\n        for i in range(n):\n            u = sol[i]\n            v = sol[(i+1)%n]\n            importance[i] = distance_matrix[u, v]\n        return importance\n\n    importance1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    importance2 = calculate_edge_importance(new_solution, distance_matrix_2)\n\n    # Combine importance scores\n    combined_importance = importance1 + importance2\n    threshold = np.percentile(combined_importance, 75)\n\n    # Identify critical edges (segments to preserve)\n    critical_edges = np.where(combined_importance > threshold)[0]\n    critical_nodes = [new_solution[i] for i in critical_edges]\n\n    # Create remaining nodes list\n    remaining_nodes = [node for node in new_solution if node not in critical_nodes]\n\n    # Perform fragmentation and recombination\n    if len(remaining_nodes) > 2:\n        # Split remaining nodes into segments\n        segment_size = max(2, len(remaining_nodes) // 3)\n        segments = [remaining_nodes[i:i+segment_size] for i in range(0, len(remaining_nodes), segment_size)]\n\n        # Reorder segments based on their average importance\n        segment_importances = []\n        for seg in segments:\n            seg_importance = 0\n            for i in range(len(seg)-1):\n                u = seg[i]\n                v = seg[i+1]\n                seg_importance += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            segment_importances.append(seg_importance / (len(seg)-1 if len(seg)>1 else 1))\n\n        # Sort segments by importance (descending)\n        sorted_segments = [x for _, x in sorted(zip(segment_importances, segments), reverse=True)]\n\n        # Rebuild solution with critical nodes and reordered segments\n        new_solution = []\n        for edge in critical_edges:\n            new_solution.append(selected_sol[edge])\n\n        for seg in sorted_segments:\n            new_solution.extend(seg)\n\n        # Ensure all nodes are included and maintain tour structure\n        new_solution = np.array(new_solution)\n        if len(new_solution) != n:\n            # If fragmentation caused issues, fall back to simple insertion\n            new_solution = selected_sol.copy()\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate((new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]))\n\n    return new_solution\n\n",
        "score": [
            -0.7726420181568744,
            0.7000589370727539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Calculate edge importance for both objectives\n    def calculate_edge_importance(sol, distance_matrix):\n        importance = np.zeros(n)\n        for i in range(n):\n            u = sol[i]\n            v = sol[(i+1)%n]\n            importance[i] = distance_matrix[u, v]\n        return importance\n\n    importance1 = calculate_edge_importance(new_solution, distance_matrix_1)\n    importance2 = calculate_edge_importance(new_solution, distance_matrix_2)\n\n    # Combine importance scores\n    combined_importance = importance1 + importance2\n    threshold = np.percentile(combined_importance, 75)\n\n    # Identify critical edges (segments to preserve)\n    critical_edges = np.where(combined_importance > threshold)[0]\n    critical_nodes = [new_solution[i] for i in critical_edges]\n\n    # Create remaining nodes list\n    remaining_nodes = [node for node in new_solution if node not in critical_nodes]\n\n    # Perform fragmentation and recombination\n    if len(remaining_nodes) > 2:\n        # Split remaining nodes into segments\n        segment_size = max(2, len(remaining_nodes) // 3)\n        segments = [remaining_nodes[i:i+segment_size] for i in range(0, len(remaining_nodes), segment_size)]\n\n        # Reorder segments based on their average importance\n        segment_importances = []\n        for seg in segments:\n            seg_importance = 0\n            for i in range(len(seg)-1):\n                u = seg[i]\n                v = seg[i+1]\n                seg_importance += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n            segment_importances.append(seg_importance / (len(seg)-1 if len(seg)>1 else 1))\n\n        # Sort segments by importance (descending)\n        sorted_segments = [x for _, x in sorted(zip(segment_importances, segments), reverse=True)]\n\n        # Rebuild solution with critical nodes and reordered segments\n        new_solution = []\n        for edge in critical_edges:\n            new_solution.append(selected_sol[edge])\n\n        for seg in sorted_segments:\n            new_solution.extend(seg)\n\n        # Ensure all nodes are included and maintain tour structure\n        new_solution = np.array(new_solution)\n        if len(new_solution) != n:\n            # If fragmentation caused issues, fall back to simple insertion\n            new_solution = selected_sol.copy()\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate((new_solution[:j], new_solution[j+1:i+1], [node], new_solution[i+1:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently inverting segments and inserting nodes while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(2):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):  # Perform multiple insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8054104032366884,
            0.48522746562957764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(2):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):  # Perform multiple insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel adaptive segment inversion with probabilistic edge insertion strategy that dynamically balances exploration and exploitation by selectively inverting segments and probabilistically inserting edges based on their contribution to both objective spaces while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistic edge insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if random.random() < 0.7 * (1 / (1 + edge_cost1 + edge_cost2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8629758308846882,
            0.4831377863883972
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistic edge insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if random.random() < 0.7 * (1 / (1 + edge_cost1 + edge_cost2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node clustering with multi-objective edge insertion to explore high-quality solutions by dynamically grouping nodes based on their spatial properties and strategically inserting edges that improve both objective values while maintaining tour feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering based on spatial properties\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        # Check if node is close to previous node in both spaces\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n        if dist1 < np.mean(distance_matrix_1) * 0.7 and dist2 < np.mean(distance_matrix_2) * 0.7:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        # Select a cluster to modify\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        if len(cluster) > 2:\n            # Select two nodes in the cluster\n            i, j = sorted(random.sample(range(len(cluster)), 2))\n\n            # Try inserting the segment elsewhere\n            for pos in range(n):\n                if pos not in cluster:\n                    # Calculate potential improvement\n                    old_cost1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                                distance_matrix_1[new_solution[pos], new_solution[pos+1]])\n                    new_cost1 = (distance_matrix_1[new_solution[pos-1], cluster[i]] +\n                                distance_matrix_1[cluster[j], new_solution[pos+1]])\n\n                    old_cost2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                                distance_matrix_2[new_solution[pos], new_solution[pos+1]])\n                    new_cost2 = (distance_matrix_2[new_solution[pos-1], cluster[i]] +\n                                distance_matrix_2[cluster[j], new_solution[pos+1]])\n\n                    # If improvement in at least one objective, perform insertion\n                    if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                        # Insert the segment\n                        segment = cluster[i:j+1]\n                        new_solution = np.concatenate([\n                            new_solution[:pos],\n                            segment,\n                            new_solution[pos:]\n                        ])\n                        # Remove duplicates (maintain feasibility)\n                        unique, indices = np.unique(new_solution, return_index=True)\n                        new_solution = new_solution[np.sort(indices)]\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.6524598014945859,
            3.196439802646637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering based on spatial properties\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        # Check if node is close to previous node in both spaces\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n        if dist1 < np.mean(distance_matrix_1) * 0.7 and dist2 < np.mean(distance_matrix_2) * 0.7:\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        # Select a cluster to modify\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        if len(cluster) > 2:\n            # Select two nodes in the cluster\n            i, j = sorted(random.sample(range(len(cluster)), 2))\n\n            # Try inserting the segment elsewhere\n            for pos in range(n):\n                if pos not in cluster:\n                    # Calculate potential improvement\n                    old_cost1 = (distance_matrix_1[new_solution[pos-1], new_solution[pos]] +\n                                distance_matrix_1[new_solution[pos], new_solution[pos+1]])\n                    new_cost1 = (distance_matrix_1[new_solution[pos-1], cluster[i]] +\n                                distance_matrix_1[cluster[j], new_solution[pos+1]])\n\n                    old_cost2 = (distance_matrix_2[new_solution[pos-1], new_solution[pos]] +\n                                distance_matrix_2[new_solution[pos], new_solution[pos+1]])\n                    new_cost2 = (distance_matrix_2[new_solution[pos-1], cluster[i]] +\n                                distance_matrix_2[cluster[j], new_solution[pos+1]])\n\n                    # If improvement in at least one objective, perform insertion\n                    if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                        # Insert the segment\n                        segment = cluster[i:j+1]\n                        new_solution = np.concatenate([\n                            new_solution[:pos],\n                            segment,\n                            new_solution[pos:]\n                        ])\n                        # Remove duplicates (maintain feasibility)\n                        unique, indices = np.unique(new_solution, return_index=True)\n                        new_solution = new_solution[np.sort(indices)]\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment relocation with objective-aware edge swapping to create a neighbor solution by strategically relocating segments based on their combined objective improvement potential while swapping edges to balance the tour length in both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment relocation based on combined objective improvement\n    for _ in range(3):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best position to relocate the segment\n        best_pos = start\n        best_cost = float('inf')\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos <= start + segment_length - 1:\n                continue\n\n            # Calculate cost of relocating segment to position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos + segment_length] if pos + segment_length < n else new_solution[0]\n\n            cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                    distance_matrix_1[segment[-1], next_node] -\n                    distance_matrix_1[prev_node, next_node])\n\n            cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                    distance_matrix_2[segment[-1], next_node] -\n                    distance_matrix_2[prev_node, next_node])\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the segment and insert at best position\n        new_solution = np.delete(new_solution, range(start, start+segment_length))\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Objective-aware edge swapping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after swapping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8796508599719162,
            0.8323820233345032
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment relocation based on combined objective improvement\n    for _ in range(3):\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best position to relocate the segment\n        best_pos = start\n        best_cost = float('inf')\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos <= start + segment_length - 1:\n                continue\n\n            # Calculate cost of relocating segment to position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos + segment_length] if pos + segment_length < n else new_solution[0]\n\n            cost1 = (distance_matrix_1[prev_node, segment[0]] +\n                    distance_matrix_1[segment[-1], next_node] -\n                    distance_matrix_1[prev_node, next_node])\n\n            cost2 = (distance_matrix_2[prev_node, segment[0]] +\n                    distance_matrix_2[segment[-1], next_node] -\n                    distance_matrix_2[prev_node, next_node])\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the segment and insert at best position\n        new_solution = np.delete(new_solution, range(start, start+segment_length))\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Objective-aware edge swapping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after swapping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic segment reversal to explore high-quality solutions by intelligently reinserting nodes and reversing segments while maintaining feasibility and balancing exploration across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node and its position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic segment reversal\n    for _ in range(2):\n        # Select a segment to reverse\n        start = random.randint(0, n-1-segment_size)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8238261755707659,
            0.49481022357940674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node and its position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic segment reversal\n    for _ in range(2):\n        # Select a segment to reverse\n        start = random.randint(0, n-1-segment_size)\n        end = start + segment_size\n\n        # Reverse the segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9459011245393834,
            0.46104997396469116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9459011245393834,
            0.46104997396469116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently inverting segments of the tour and strategically inserting nodes while maintaining feasibility and balancing exploration of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node1, node2 = random.sample(range(n), 2)\n        if node1 != node2:\n            node_val = new_solution[node2]\n            new_solution = np.delete(new_solution, node2)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.6804760807297631,
            0.527186930179596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node1, node2 = random.sample(range(n), 2)\n        if node1 != node2:\n            node_val = new_solution[node2]\n            new_solution = np.delete(new_solution, node2)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment reversal with objective-balanced node insertion to create a neighbor solution by strategically reversing segments based on their combined cost impact while inserting nodes at positions that optimize the trade-off between both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after reversal\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            # Objective-balanced decision\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-balanced node insertion\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Weighted combined cost for objective balance\n            combined_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8771892314978974,
            0.7438660860061646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after reversal\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            # Objective-balanced decision\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-balanced node insertion\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Weighted combined cost for objective balance\n            combined_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node relocation with objective-balanced edge swapping to create a neighbor solution by strategically repositioning nodes based on their dominance in both objective spaces while swapping edges to balance the tour length reduction in both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node relocation based on objective dominance\n    for _ in range(3):\n        # Select a random node to relocate\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best relocation position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of relocating node to position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Balance both costs for evaluation\n            combined_cost = 0.7 * cost1 + 0.3 * cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-balanced edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after swapping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n            if (0.6 * cost1_after + 0.4 * cost2_after) < (0.6 * cost1_before + 0.4 * cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8358924886101018,
            0.7593289017677307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node relocation based on objective dominance\n    for _ in range(3):\n        # Select a random node to relocate\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best relocation position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of relocating node to position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Balance both costs for evaluation\n            combined_cost = 0.7 * cost1 + 0.3 * cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-balanced edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after swapping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n            if (0.6 * cost1_after + 0.4 * cost2_after) < (0.6 * cost1_before + 0.4 * cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node relocation with multi-objective edge swapping to create a neighbor solution by strategically repositioning nodes based on their combined objective impact while performing edge swaps that balance improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (using Pareto dominance)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if pareto_front:\n        selected_sol = random.choice(pareto_front)\n    else:\n        selected_sol = random.choice([sol for sol, _ in archive])\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation based on combined objective impact\n    for _ in range(3):\n        # Select a random node to relocate\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best relocation position considering both objectives\n        best_pos = node_pos\n        best_impact = 0\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos - 1) % n or pos == (node_pos + 1) % n:\n                continue\n\n            # Calculate impact of moving node to position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n            old_prev = new_solution[node_pos - 1] if node_pos > 0 else new_solution[-1]\n            old_next = new_solution[node_pos] if node_pos < n - 1 else new_solution[0]\n\n            # Cost in objective 1\n            cost1_before = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next] + distance_matrix_1[prev_node, next_node]\n            cost1_after = distance_matrix_1[old_prev, old_next] + distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n\n            # Cost in objective 2\n            cost2_before = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next] + distance_matrix_2[prev_node, next_node]\n            cost2_after = distance_matrix_2[old_prev, old_next] + distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Combined impact (normalized)\n            impact1 = (cost1_before - cost1_after) / (distance_matrix_1[old_prev, old_next] + 1e-6)\n            impact2 = (cost2_before - cost2_after) / (distance_matrix_2[old_prev, old_next] + 1e-6)\n            combined_impact = impact1 + impact2\n\n            if combined_impact > best_impact:\n                best_impact = combined_impact\n                best_pos = pos\n\n        # Relocate the node if beneficial\n        if best_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after swapping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i + 1] if i < n - 1 else new_solution[0]\n            prev_j = new_solution[j - 1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j + 1] if j < n - 1 else new_solution[0]\n\n            # Cost in objective 1\n            cost1_before = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + \\\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n\n            # Cost in objective 2\n            cost2_before = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + \\\n                          distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n               (cost1_after < cost1_before and (cost2_after - cost2_before) < 0.1 * cost2_before) or \\\n               (cost2_after < cost2_before and (cost1_after - cost1_before) < 0.1 * cost1_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7354116175136185,
            3.9556230902671814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (using Pareto dominance)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if pareto_front:\n        selected_sol = random.choice(pareto_front)\n    else:\n        selected_sol = random.choice([sol for sol, _ in archive])\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation based on combined objective impact\n    for _ in range(3):\n        # Select a random node to relocate\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best relocation position considering both objectives\n        best_pos = node_pos\n        best_impact = 0\n\n        for pos in range(n):\n            if pos == node_pos or pos == (node_pos - 1) % n or pos == (node_pos + 1) % n:\n                continue\n\n            # Calculate impact of moving node to position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n            old_prev = new_solution[node_pos - 1] if node_pos > 0 else new_solution[-1]\n            old_next = new_solution[node_pos] if node_pos < n - 1 else new_solution[0]\n\n            # Cost in objective 1\n            cost1_before = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next] + distance_matrix_1[prev_node, next_node]\n            cost1_after = distance_matrix_1[old_prev, old_next] + distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n\n            # Cost in objective 2\n            cost2_before = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next] + distance_matrix_2[prev_node, next_node]\n            cost2_after = distance_matrix_2[old_prev, old_next] + distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Combined impact (normalized)\n            impact1 = (cost1_before - cost1_after) / (distance_matrix_1[old_prev, old_next] + 1e-6)\n            impact2 = (cost2_before - cost2_after) / (distance_matrix_2[old_prev, old_next] + 1e-6)\n            combined_impact = impact1 + impact2\n\n            if combined_impact > best_impact:\n                best_impact = combined_impact\n                best_pos = pos\n\n        # Relocate the node if beneficial\n        if best_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after swapping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i + 1] if i < n - 1 else new_solution[0]\n            prev_j = new_solution[j - 1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j + 1] if j < n - 1 else new_solution[0]\n\n            # Cost in objective 1\n            cost1_before = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + \\\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n\n            # Cost in objective 2\n            cost2_before = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + \\\n                          distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n               (cost1_after < cost1_before and (cost2_after - cost2_before) < 0.1 * cost2_before) or \\\n               (cost2_after < cost2_before and (cost1_after - cost1_before) < 0.1 * cost1_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{An adaptive multi-segment relocation strategy that combines objective-aware segment selection with dynamic edge refinement to explore high-quality solutions by intelligently relocating multiple segments of the tour while maintaining feasibility and balancing improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    num_segments = max(2, min(4, n // 5))\n\n    # Adaptive multi-segment relocation\n    for _ in range(3):\n        # Select non-overlapping segments\n        segments = []\n        for _ in range(num_segments):\n            seg_size = random.randint(2, min(5, n // 3))\n            seg_start = random.randint(0, n - seg_size)\n            seg_end = seg_start + seg_size\n            segments.append((seg_start, seg_end))\n\n        # Sort segments by start position\n        segments.sort()\n\n        # Check for overlaps and adjust\n        for i in range(1, len(segments)):\n            if segments[i][0] < segments[i-1][1]:\n                segments[i] = (segments[i-1][1], segments[i-1][1] + (segments[i][1] - segments[i][0]))\n\n        # Extract segments and their positions\n        segment_data = []\n        for start, end in segments:\n            if start < n and end <= n:\n                segment_data.append((start, end, new_solution[start:end]))\n\n        # Relocate segments to new positions\n        for i in range(len(segment_data)):\n            start, end, seg = segment_data[i]\n            new_pos = random.randint(0, n - len(seg))\n            # Ensure the segment is not relocated to its original position\n            if new_pos != start and new_pos + len(seg) != end:\n                # Remove the segment from its original position\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n                # Insert the segment at the new position\n                new_solution = np.concatenate([new_solution[:new_pos], seg, new_solution[new_pos:]])\n\n    # Dynamic edge refinement based on objective improvement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Evaluate the potential improvement in both objectives\n            orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Only perform swap if it improves at least one objective\n            if new_cost1 < orig_cost1 or new_cost2 < orig_cost2:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7608318644096113,
            0.11456215381622314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    num_segments = max(2, min(4, n // 5))\n\n    # Adaptive multi-segment relocation\n    for _ in range(3):\n        # Select non-overlapping segments\n        segments = []\n        for _ in range(num_segments):\n            seg_size = random.randint(2, min(5, n // 3))\n            seg_start = random.randint(0, n - seg_size)\n            seg_end = seg_start + seg_size\n            segments.append((seg_start, seg_end))\n\n        # Sort segments by start position\n        segments.sort()\n\n        # Check for overlaps and adjust\n        for i in range(1, len(segments)):\n            if segments[i][0] < segments[i-1][1]:\n                segments[i] = (segments[i-1][1], segments[i-1][1] + (segments[i][1] - segments[i][0]))\n\n        # Extract segments and their positions\n        segment_data = []\n        for start, end in segments:\n            if start < n and end <= n:\n                segment_data.append((start, end, new_solution[start:end]))\n\n        # Relocate segments to new positions\n        for i in range(len(segment_data)):\n            start, end, seg = segment_data[i]\n            new_pos = random.randint(0, n - len(seg))\n            # Ensure the segment is not relocated to its original position\n            if new_pos != start and new_pos + len(seg) != end:\n                # Remove the segment from its original position\n                new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n                # Insert the segment at the new position\n                new_solution = np.concatenate([new_solution[:new_pos], seg, new_solution[new_pos:]])\n\n    # Dynamic edge refinement based on objective improvement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Evaluate the potential improvement in both objectives\n            orig_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            orig_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Only perform swap if it improves at least one objective\n            if new_cost1 < orig_cost1 or new_cost2 < orig_cost2:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{This novel hybrid local search strategy combines adaptive node clustering with multi-objective edge optimization by intelligently grouping nodes based on their proximity in both objective spaces and then performing targeted edge swaps to simultaneously improve tour lengths in both dimensions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on proximity in both objective spaces\n    clusters = []\n    unassigned = list(range(n))\n\n    while unassigned:\n        seed = random.choice(unassigned)\n        cluster = [seed]\n        unassigned.remove(seed)\n\n        for node in unassigned[:]:\n            for member in cluster:\n                # Calculate combined distance in both spaces\n                dist1 = distance_matrix_1[new_solution[member], new_solution[node]]\n                dist2 = distance_matrix_2[new_solution[member], new_solution[node]]\n                combined_dist = dist1 + dist2\n\n                if combined_dist < 2 * (distance_matrix_1[new_solution[member], new_solution[member]] +\n                                       distance_matrix_2[new_solution[member], new_solution[member]]):\n                    cluster.append(node)\n                    unassigned.remove(node)\n                    break\n\n        clusters.append(cluster)\n\n    # Reorder clusters based on their total combined distance\n    clusters.sort(key=lambda c: sum(distance_matrix_1[new_solution[i], new_solution[j]] +\n                                    distance_matrix_2[new_solution[i], new_solution[j]]\n                                    for i in c for j in c if i != j), reverse=True)\n\n    # Reconstruct solution by placing clusters in order\n    ordered_nodes = []\n    for cluster in clusters:\n        ordered_nodes.extend([new_solution[i] for i in cluster])\n\n    new_solution = np.array(ordered_nodes)\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        # Select two random positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate cost before and after swap\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        cost1_before = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                       distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n        cost1_after = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                      distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j])\n\n        cost2_before = (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                       distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n        cost2_after = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                      distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8218158363234916,
            2.863283097743988
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on proximity in both objective spaces\n    clusters = []\n    unassigned = list(range(n))\n\n    while unassigned:\n        seed = random.choice(unassigned)\n        cluster = [seed]\n        unassigned.remove(seed)\n\n        for node in unassigned[:]:\n            for member in cluster:\n                # Calculate combined distance in both spaces\n                dist1 = distance_matrix_1[new_solution[member], new_solution[node]]\n                dist2 = distance_matrix_2[new_solution[member], new_solution[node]]\n                combined_dist = dist1 + dist2\n\n                if combined_dist < 2 * (distance_matrix_1[new_solution[member], new_solution[member]] +\n                                       distance_matrix_2[new_solution[member], new_solution[member]]):\n                    cluster.append(node)\n                    unassigned.remove(node)\n                    break\n\n        clusters.append(cluster)\n\n    # Reorder clusters based on their total combined distance\n    clusters.sort(key=lambda c: sum(distance_matrix_1[new_solution[i], new_solution[j]] +\n                                    distance_matrix_2[new_solution[i], new_solution[j]]\n                                    for i in c for j in c if i != j), reverse=True)\n\n    # Reconstruct solution by placing clusters in order\n    ordered_nodes = []\n    for cluster in clusters:\n        ordered_nodes.extend([new_solution[i] for i in cluster])\n\n    new_solution = np.array(ordered_nodes)\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        # Select two random positions\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate cost before and after swap\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n        prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n        cost1_before = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                       distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n        cost1_after = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                      distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j])\n\n        cost2_before = (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                       distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n        cost2_after = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                      distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n        if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive node insertion with objective-aware edge flipping to create a neighbor solution by strategically inserting nodes based on their proximity in both objective spaces while flipping edges to reduce the total tour length in both dimensions.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on objective-aware proximity\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Find the best insertion position considering both objectives\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            # Calculate cost of inserting node at position pos\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine both costs for evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the node and insert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate cost before and after flipping\n            prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i]\n            prev_j = new_solution[j - 1]\n            next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, next_i] + distance_matrix_1[prev_j, next_j]\n            cost1_after = distance_matrix_1[prev_i, prev_j] + distance_matrix_1[next_i, next_j]\n            cost2_before = distance_matrix_2[prev_i, next_i] + distance_matrix_2[prev_j, next_j]\n            cost2_after = distance_matrix_2[prev_i, prev_j] + distance_matrix_2[next_i, next_j]\n\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm implements a novel hybrid local search strategy that combines adaptive segment relocation with bi-objective-aware path smoothing, where segments of the tour are relocated based on their potential to improve both objectives, while simultaneously smoothing the path by adjusting the sequence of nodes to reduce overall distance in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (random selection)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    for _ in range(2):\n        # Select a random segment\n        segment_length = random.randint(2, min(5, n // 2))\n        start_pos = random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Find the best position to insert the segment\n        best_pos = start_pos\n        best_cost = float('inf')\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start_pos and pos < start_pos + segment_length:\n                continue\n\n            # Calculate cost of moving segment to new position\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos + segment_length] if pos + segment_length < n else new_solution[0]\n            first_node = segment[0]\n            last_node = segment[-1]\n\n            cost1 = distance_matrix_1[prev_node, first_node] + distance_matrix_1[last_node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, first_node] + distance_matrix_2[last_node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the segment and insert at best position\n        new_solution = np.delete(new_solution, range(start_pos, start_pos + segment_length))\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Bi-objective-aware path smoothing\n    for _ in range(3):\n        # Select three random nodes\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Calculate cost before and after reordering\n        prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n        next_k = new_solution[k] if k < n - 1 else new_solution[0]\n\n        # Current sequence: prev_i -> i -> ... -> j -> ... -> k -> next_k\n        # Possible new sequences:\n        # 1. prev_i -> i -> ... -> k -> ... -> j -> next_k\n        # 2. prev_i -> j -> ... -> k -> ... -> i -> next_k\n\n        # Evaluate sequence 1\n        cost1_seq1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[k-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], next_k]\n        cost2_seq1 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[k-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], next_k]\n\n        # Evaluate sequence 2\n        cost1_seq2 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[i]] + distance_matrix_1[new_solution[i-1], next_k]\n        cost2_seq2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], next_k]\n\n        # Choose the better sequence\n        if (cost1_seq1 + cost2_seq1) < (cost1_seq2 + cost2_seq2):\n            # Keep original sequence\n            continue\n        else:\n            # Apply the better sequence\n            if i + 1 <= j - 1 and j + 1 <= k - 1:\n                new_solution[i:k] = np.concatenate([new_solution[j:k], new_solution[i:j]])\n\n    return new_solution\n\n",
        "score": [
            -0.9287098076535965,
            0.725428581237793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (random selection)\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    for _ in range(2):\n        # Select a random segment\n        segment_length = random.randint(2, min(5, n // 2))\n        start_pos = random.randint(0, n - segment_length)\n        segment = new_solution[start_pos:start_pos + segment_length]\n\n        # Find the best position to insert the segment\n        best_pos = start_pos\n        best_cost = float('inf')\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start_pos and pos < start_pos + segment_length:\n                continue\n\n            # Calculate cost of moving segment to new position\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos + segment_length] if pos + segment_length < n else new_solution[0]\n            first_node = segment[0]\n            last_node = segment[-1]\n\n            cost1 = distance_matrix_1[prev_node, first_node] + distance_matrix_1[last_node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, first_node] + distance_matrix_2[last_node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Remove the segment and insert at best position\n        new_solution = np.delete(new_solution, range(start_pos, start_pos + segment_length))\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Bi-objective-aware path smoothing\n    for _ in range(3):\n        # Select three random nodes\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Calculate cost before and after reordering\n        prev_i = new_solution[i - 1] if i > 0 else new_solution[-1]\n        next_k = new_solution[k] if k < n - 1 else new_solution[0]\n\n        # Current sequence: prev_i -> i -> ... -> j -> ... -> k -> next_k\n        # Possible new sequences:\n        # 1. prev_i -> i -> ... -> k -> ... -> j -> next_k\n        # 2. prev_i -> j -> ... -> k -> ... -> i -> next_k\n\n        # Evaluate sequence 1\n        cost1_seq1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[k-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], next_k]\n        cost2_seq1 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[k-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], next_k]\n\n        # Evaluate sequence 2\n        cost1_seq2 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[i]] + distance_matrix_1[new_solution[i-1], next_k]\n        cost2_seq2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], next_k]\n\n        # Choose the better sequence\n        if (cost1_seq1 + cost2_seq1) < (cost1_seq2 + cost2_seq2):\n            # Keep original sequence\n            continue\n        else:\n            # Apply the better sequence\n            if i + 1 <= j - 1 and j + 1 <= k - 1:\n                new_solution[i:k] = np.concatenate([new_solution[j:k], new_solution[i:j]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment reversal with dynamic node insertion to explore high-quality solutions by intelligently reversing segments and inserting nodes while maintaining feasibility and balancing both objective spaces through a weighted evaluation of potential moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_pos = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-1)\n        if node_pos != insert_pos:\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Weighted move evaluation to balance both objectives\n    def evaluate_move(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = evaluate_move(new_solution)\n\n    # Try to improve by considering both objectives\n    for _ in range(2):\n        temp_sol = new_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n            temp_cost1, temp_cost2 = evaluate_move(temp_sol)\n            if (temp_cost1 <= current_cost1 and temp_cost2 <= current_cost2) or \\\n               (random.random() < 0.3):  # Small chance to accept worse but diverse solutions\n                new_solution = temp_sol\n                current_cost1, current_cost2 = temp_cost1, temp_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.8333939811378601,
            0.6642212867736816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_pos = random.randint(0, n-1)\n        insert_pos = random.randint(0, n-1)\n        if node_pos != insert_pos:\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Weighted move evaluation to balance both objectives\n    def evaluate_move(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        return cost1, cost2\n\n    current_cost1, current_cost2 = evaluate_move(new_solution)\n\n    # Try to improve by considering both objectives\n    for _ in range(2):\n        temp_sol = new_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n            temp_cost1, temp_cost2 = evaluate_move(temp_sol)\n            if (temp_cost1 <= current_cost1 and temp_cost2 <= current_cost2) or \\\n               (random.random() < 0.3):  # Small chance to accept worse but diverse solutions\n                new_solution = temp_sol\n                current_cost1, current_cost2 = temp_cost1, temp_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently reversing segments of the tour and strategically inserting nodes while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path inversion\n    for _ in range(2):  # Perform multiple inversions\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):  # Perform multiple insertions\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8117782377163537,
            0.5177407264709473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path inversion\n    for _ in range(2):  # Perform multiple inversions\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):  # Perform multiple insertions\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore high-quality solutions by intelligently reversing segments of the tour and inserting nodes in optimal positions while maintaining feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly chosen)\n    selected_sol = random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(4):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7395716294056501,
            0.5114683508872986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly chosen)\n    selected_sol = random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(4):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = (i + j) // 2\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{This new algorithm combines multi-objective adaptive segment insertion with objective-aware node swapping, where segments from high-performing solutions are intelligently inserted into random positions, followed by targeted node swaps based on their combined contribution to both objectives, while maintaining feasibility through careful validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    for _ in range(3):\n        # Select a random segment from another high-performing solution\n        other_sol = random.choice(archive_solutions)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_sol[a:b]\n\n        # Insert segment at a random position\n        pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos + len(segment):]])\n\n        # Remove duplicates and fill gaps\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) < n:\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] not in unique_nodes:\n                    new_solution[i] = missing_nodes.pop(0)\n\n    # Objective-aware node swapping\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        # Evaluate current and swapped positions\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8913844577801842,
            1.3368121981620789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    for _ in range(3):\n        # Select a random segment from another high-performing solution\n        other_sol = random.choice(archive_solutions)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_sol[a:b]\n\n        # Insert segment at a random position\n        pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos + len(segment):]])\n\n        # Remove duplicates and fill gaps\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) < n:\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] not in unique_nodes:\n                    new_solution[i] = missing_nodes.pop(0)\n\n    # Objective-aware node swapping\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        if i == j:\n            continue\n\n        # Evaluate current and swapped positions\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if swapped_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{An innovative hybrid local search strategy that combines adaptive node insertion with multi-objective guided segment inversion, where nodes are strategically inserted into promising positions based on their contributions to both objectives, followed by segment inversions guided by a combined objective function to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on multi-objective guidance\n    for _ in range(3):\n        # Select a random node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion positions that improve both objectives\n        best_pos = -1\n        best_improvement = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                continue\n\n            # Create temporary solution\n            temp_sol = new_solution.copy()\n            temp_sol = np.roll(temp_sol, -node_idx)\n            temp_sol = np.roll(temp_sol, pos)\n\n            # Calculate cost change\n            old_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                         distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n            new_cost1 = (distance_matrix_1[temp_sol[node_idx-1], temp_sol[node_idx]] +\n                        distance_matrix_1[temp_sol[node_idx], temp_sol[(node_idx+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                         distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n            new_cost2 = (distance_matrix_2[temp_sol[node_idx-1], temp_sol[node_idx]] +\n                        distance_matrix_2[temp_sol[node_idx], temp_sol[(node_idx+1)%n]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.roll(new_solution, -node_idx)\n            new_solution = np.roll(new_solution, best_pos)\n\n    # Multi-objective guided segment inversion\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Calculate inverted segment cost\n        inv_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inv_segment[i-1], inv_segment[i]] for i in range(len(inv_segment)))\n        inv_cost2 = sum(distance_matrix_2[inv_segment[i-1], inv_segment[i]] for i in range(len(inv_segment)))\n\n        # Combined cost improvement\n        if (inv_cost1 + inv_cost2) < (seg_cost1 + seg_cost2):\n            new_solution[a:b] = inv_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7862420840407662,
            3.475587010383606
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion based on multi-objective guidance\n    for _ in range(3):\n        # Select a random node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find insertion positions that improve both objectives\n        best_pos = -1\n        best_improvement = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx + 1) % n:\n                continue\n\n            # Create temporary solution\n            temp_sol = new_solution.copy()\n            temp_sol = np.roll(temp_sol, -node_idx)\n            temp_sol = np.roll(temp_sol, pos)\n\n            # Calculate cost change\n            old_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                         distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n            new_cost1 = (distance_matrix_1[temp_sol[node_idx-1], temp_sol[node_idx]] +\n                        distance_matrix_1[temp_sol[node_idx], temp_sol[(node_idx+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                         distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n            new_cost2 = (distance_matrix_2[temp_sol[node_idx-1], temp_sol[node_idx]] +\n                        distance_matrix_2[temp_sol[node_idx], temp_sol[(node_idx+1)%n]])\n\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.roll(new_solution, -node_idx)\n            new_solution = np.roll(new_solution, best_pos)\n\n    # Multi-objective guided segment inversion\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment cost\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Calculate inverted segment cost\n        inv_segment = segment[::-1]\n        inv_cost1 = sum(distance_matrix_1[inv_segment[i-1], inv_segment[i]] for i in range(len(inv_segment)))\n        inv_cost2 = sum(distance_matrix_2[inv_segment[i-1], inv_segment[i]] for i in range(len(inv_segment)))\n\n        # Combined cost improvement\n        if (inv_cost1 + inv_cost2) < (seg_cost1 + seg_cost2):\n            new_solution[a:b] = inv_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently reversing segments of the tour and inserting nodes at optimal positions while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):  # Perform multiple inversions\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):  # Perform multiple insertions\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9534098185133875,
            0.492692232131958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):  # Perform multiple inversions\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):  # Perform multiple insertions\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently reversing segments of the tour and inserting nodes at optimal positions while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):  # Perform multiple inversions\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):  # Perform multiple insertions\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9534098185133875,
            0.492692232131958
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):  # Perform multiple inversions\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):  # Perform multiple insertions\n        node = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0])\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment insertion with dynamic path optimization, where a high-performing solution from the archive is modified by strategically inserting segments from a random solution while dynamically optimizing the path based on both objectives and their trade-offs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random solution from archive for segment insertion\n    random_sol = random.choice([sol for sol, _ in archive])\n    n = len(new_solution)\n\n    # Dynamic segment insertion\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find insertion point that minimizes combined cost\n        min_cost = float('inf')\n        best_pos = -1\n\n        for i in range(n - len(segment) + 1):\n            # Test inserting segment at position i\n            temp_sol = np.concatenate((new_solution[:i], segment, new_solution[i:]))\n            temp_sol = np.unique(temp_sol)[:n]  # Ensure no duplicates\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate((new_solution[:best_pos], segment, new_solution[best_pos:]))\n            new_solution = np.unique(new_solution)[:n]\n\n    # Dynamic path optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate original and reversed segments\n            original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n            reversed_segment = new_solution[i:j+1][::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (original_cost1 + original_cost2):\n                new_solution[i:j+1] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8527639969938994,
            6.409917116165161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Select a random solution from archive for segment insertion\n    random_sol = random.choice([sol for sol, _ in archive])\n    n = len(new_solution)\n\n    # Dynamic segment insertion\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find insertion point that minimizes combined cost\n        min_cost = float('inf')\n        best_pos = -1\n\n        for i in range(n - len(segment) + 1):\n            # Test inserting segment at position i\n            temp_sol = np.concatenate((new_solution[:i], segment, new_solution[i:]))\n            temp_sol = np.unique(temp_sol)[:n]  # Ensure no duplicates\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < min_cost:\n                min_cost = combined_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate((new_solution[:best_pos], segment, new_solution[best_pos:]))\n            new_solution = np.unique(new_solution)[:n]\n\n    # Dynamic path optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate original and reversed segments\n            original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n            original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n            reversed_segment = new_solution[i:j+1][::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (original_cost1 + original_cost2):\n                new_solution[i:j+1] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9562472386861592,
            0.4804345369338989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9562472386861592,
            0.4804345369338989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel adaptive segment swapping with dynamic edge selection strategy that combines probabilistic segment selection with objective-aware edge swapping to explore high-quality solutions by intelligently rearranging segments and edges while maintaining feasibility and balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment selection with objective-aware probability\n    for _ in range(3):\n        # Calculate segment quality based on both objectives\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n        seg1 = new_solution[seg1_start:seg1_end]\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        # Calculate improvement potential\n        cost1_before = sum(distance_matrix_1[seg1[i-1], seg1[i]] for i in range(len(seg1))) + sum(distance_matrix_1[seg2[i-1], seg2[i]] for i in range(len(seg2)))\n        cost2_before = sum(distance_matrix_2[seg1[i-1], seg1[i]] for i in range(len(seg1))) + sum(distance_matrix_2[seg2[i-1], seg2[i]] for i in range(len(seg2)))\n\n        # Swap segments\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n        # Check if swap improved at least one objective\n        cost1_after = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        cost2_after = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before):\n            # Revert if no improvement\n            new_solution[seg1_start:seg1_end] = seg1\n            new_solution[seg2_start:seg2_end] = seg2\n\n    # Dynamic edge selection with objective-aware swapping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate edge quality\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Perform edge swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Calculate new edge quality\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2):\n                # Revert if no improvement\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8846421135540692,
            0.2516152858734131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective diversity\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment selection with objective-aware probability\n    for _ in range(3):\n        # Calculate segment quality based on both objectives\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n        seg1 = new_solution[seg1_start:seg1_end]\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        # Calculate improvement potential\n        cost1_before = sum(distance_matrix_1[seg1[i-1], seg1[i]] for i in range(len(seg1))) + sum(distance_matrix_1[seg2[i-1], seg2[i]] for i in range(len(seg2)))\n        cost2_before = sum(distance_matrix_2[seg1[i-1], seg1[i]] for i in range(len(seg1))) + sum(distance_matrix_2[seg2[i-1], seg2[i]] for i in range(len(seg2)))\n\n        # Swap segments\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n        # Check if swap improved at least one objective\n        cost1_after = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        cost2_after = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n        if (cost1_after >= cost1_before and cost2_after >= cost2_before):\n            # Revert if no improvement\n            new_solution[seg1_start:seg1_end] = seg1\n            new_solution[seg2_start:seg2_end] = seg2\n\n    # Dynamic edge selection with objective-aware swapping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate edge quality\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Perform edge swap\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n            # Calculate new edge quality\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2):\n                # Revert if no improvement\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node clustering with multi-objective edge insertion, where nodes are grouped based on their proximity in both objective spaces, and then strategically inserted into the tour to balance the trade-off between the two objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    clusters = []\n    remaining_nodes = set(range(n))\n    while remaining_nodes:\n        current_node = random.choice(list(remaining_nodes))\n        cluster = [current_node]\n        remaining_nodes.remove(current_node)\n\n        for node in remaining_nodes.copy():\n            # Check proximity in both objective spaces\n            dist1 = distance_matrix_1[current_node, node]\n            dist2 = distance_matrix_2[current_node, node]\n            if (dist1 < 10 and dist2 < 10) or len(cluster) < 2:  # Threshold and minimum size\n                cluster.append(node)\n                remaining_nodes.remove(node)\n\n        clusters.append(cluster)\n\n    # Multi-objective edge insertion\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Find insertion points\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Try inserting the cluster at position i\n            temp_sol = np.concatenate([new_solution[:i], cluster, new_solution[i:]])\n            if len(temp_sol) != n:\n                continue  # Skip invalid insertions\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], cluster, new_solution[best_pos:]])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6460537427153253,
            3.078668534755707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    clusters = []\n    remaining_nodes = set(range(n))\n    while remaining_nodes:\n        current_node = random.choice(list(remaining_nodes))\n        cluster = [current_node]\n        remaining_nodes.remove(current_node)\n\n        for node in remaining_nodes.copy():\n            # Check proximity in both objective spaces\n            dist1 = distance_matrix_1[current_node, node]\n            dist2 = distance_matrix_2[current_node, node]\n            if (dist1 < 10 and dist2 < 10) or len(cluster) < 2:  # Threshold and minimum size\n                cluster.append(node)\n                remaining_nodes.remove(node)\n\n        clusters.append(cluster)\n\n    # Multi-objective edge insertion\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Find insertion points\n        best_pos = -1\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Try inserting the cluster at position i\n            temp_sol = np.concatenate([new_solution[:i], cluster, new_solution[i:]])\n            if len(temp_sol) != n:\n                continue  # Skip invalid insertions\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[j-1], temp_sol[j]] for j in range(n))\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], cluster, new_solution[best_pos:]])\n            new_solution = new_solution[:n]  # Ensure correct length\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective edge insertion with adaptive segment reversal, where a high-performing solution from the archive is first processed through a multi-objective edge insertion step that evaluates candidate edges based on their combined contribution to both objectives, followed by an adaptive segment reversal step that strategically reverses segments of the tour based on their potential to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        i, j, k = random.sample(range(n), 3)\n        if i == j or j == k or i == k:\n            continue\n\n        # Evaluate the candidate edge insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n            # Perform the edge insertion\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:i] = new_solution[j:i][::-1]\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n\n        segment = new_solution[a:b]\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n        if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n            new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8404422474698923,
            0.6302695870399475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        i, j, k = random.sample(range(n), 3)\n        if i == j or j == k or i == k:\n            continue\n\n        # Evaluate the candidate edge insertion\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]]\n\n        if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n            # Perform the edge insertion\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[j:i] = new_solution[j:i][::-1]\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n\n        segment = new_solution[a:b]\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n        if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n            new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with multi-objective edge evaluation, where nodes are strategically reinserted at positions that optimize both objectives while maintaining feasibility, and edges are evaluated for potential reversal based on their combined contribution to both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    selected_sol = random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with multi-objective evaluation\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Evaluate potential insertion positions\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            # Insert node at position pos\n            temp_solution = np.insert(new_solution, pos, node)\n\n            # Calculate the cost of the new edges\n            prev_node = temp_solution[pos-1] if pos > 0 else temp_solution[-1]\n            next_node = temp_solution[pos+1] if pos < n-1 else temp_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Combine costs for multi-objective evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-objective edge evaluation and reversal\n    for _ in range(2):\n        # Select a random edge to potentially reverse\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n\n        if i > j:\n            i, j = j, i\n\n        # Get the current segment\n        segment = new_solution[i:j+1]\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) + distance_matrix_1[segment[-1], segment[0]]\n        current_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Calculate reversed cost\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) + distance_matrix_1[reversed_segment[-1], reversed_segment[0]]\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n\n        # Accept reversal if it improves the combined cost\n        if (reversed_cost1 + reversed_cost2) < (current_cost1 + current_cost2):\n            new_solution[i:j+1] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8061270767410127,
            2.0675163865089417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    selected_sol = random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with multi-objective evaluation\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Evaluate potential insertion positions\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            # Insert node at position pos\n            temp_solution = np.insert(new_solution, pos, node)\n\n            # Calculate the cost of the new edges\n            prev_node = temp_solution[pos-1] if pos > 0 else temp_solution[-1]\n            next_node = temp_solution[pos+1] if pos < n-1 else temp_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Combine costs for multi-objective evaluation\n            combined_cost = cost1 + cost2\n\n            if combined_cost < best_cost:\n                best_cost = combined_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-objective edge evaluation and reversal\n    for _ in range(2):\n        # Select a random edge to potentially reverse\n        i = random.randint(0, n-1)\n        j = (i + random.randint(1, n//2)) % n\n\n        if i > j:\n            i, j = j, i\n\n        # Get the current segment\n        segment = new_solution[i:j+1]\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) + distance_matrix_1[segment[-1], segment[0]]\n        current_cost2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment))) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Calculate reversed cost\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) + distance_matrix_1[reversed_segment[-1], reversed_segment[0]]\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment))) + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n\n        # Accept reversal if it improves the combined cost\n        if (reversed_cost1 + reversed_cost2) < (current_cost1 + current_cost2):\n            new_solution[i:j+1] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{This novel hybrid local search strategy combines adaptive segment insertion with dynamic objective-aware segment selection, where segments are strategically inserted from a high-performing solution into a random solution, with segment selection prioritizing those that show promise of improving both objectives while maintaining feasibility through careful insertion points and validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution and a random solution\n    high_perf_sol = archive[0][0].copy()\n    random_sol = np.random.permutation(high_perf_sol)\n    new_solution = random_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):\n        # Select a segment from high-perf solution\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = high_perf_sol[seg_start:seg_end]\n\n        # Evaluate segment quality in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Find insertion point in random solution\n        insert_pos = random.randint(0, n - segment_size)\n\n        # Insert segment if it improves combined cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        temp_sol = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        temp_sol = temp_sol[:n]  # Ensure correct length\n\n        new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution = temp_sol\n\n    # Dynamic objective-aware segment selection\n    for _ in range(2):\n        # Select a segment to replace\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Find a better segment from high-perf solution\n        for i in range(n - segment_size + 1):\n            candidate_seg = high_perf_sol[i:i+segment_size]\n            candidate_cost1 = sum(distance_matrix_1[candidate_seg[i-1], candidate_seg[i]] for i in range(len(candidate_seg)))\n            candidate_cost2 = sum(distance_matrix_2[candidate_seg[i-1], candidate_seg[i]] for i in range(len(candidate_seg)))\n\n            current_seg = new_solution[seg_start:seg_end]\n            current_cost1 = sum(distance_matrix_1[current_seg[i-1], current_seg[i]] for i in range(len(current_seg)))\n            current_cost2 = sum(distance_matrix_2[current_seg[i-1], current_seg[i]] for i in range(len(current_seg)))\n\n            if (candidate_cost1 + candidate_cost2) < (current_cost1 + current_cost2):\n                new_solution[seg_start:seg_end] = candidate_seg\n                break\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9379388721322306,
            0.866766095161438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution and a random solution\n    high_perf_sol = archive[0][0].copy()\n    random_sol = np.random.permutation(high_perf_sol)\n    new_solution = random_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):\n        # Select a segment from high-perf solution\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = high_perf_sol[seg_start:seg_end]\n\n        # Evaluate segment quality in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Find insertion point in random solution\n        insert_pos = random.randint(0, n - segment_size)\n\n        # Insert segment if it improves combined cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        temp_sol = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n        temp_sol = temp_sol[:n]  # Ensure correct length\n\n        new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n\n        if (new_cost1 + new_cost2) < (current_cost1 + current_cost2):\n            new_solution = temp_sol\n\n    # Dynamic objective-aware segment selection\n    for _ in range(2):\n        # Select a segment to replace\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Find a better segment from high-perf solution\n        for i in range(n - segment_size + 1):\n            candidate_seg = high_perf_sol[i:i+segment_size]\n            candidate_cost1 = sum(distance_matrix_1[candidate_seg[i-1], candidate_seg[i]] for i in range(len(candidate_seg)))\n            candidate_cost2 = sum(distance_matrix_2[candidate_seg[i-1], candidate_seg[i]] for i in range(len(candidate_seg)))\n\n            current_seg = new_solution[seg_start:seg_end]\n            current_cost1 = sum(distance_matrix_1[current_seg[i-1], current_seg[i]] for i in range(len(current_seg)))\n            current_cost2 = sum(distance_matrix_2[current_seg[i-1], current_seg[i]] for i in range(len(current_seg)))\n\n            if (candidate_cost1 + candidate_cost2) < (current_cost1 + current_cost2):\n                new_solution[seg_start:seg_end] = candidate_seg\n                break\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0289096300238922,
            6.122824847698212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for i in range(n):\n        if random.random() < 0.3:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering\n    for _ in range(2):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Decide to reverse or not based on combined cost\n        if random.random() < 0.5:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0289096300238922,
            6.122824847698212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{An innovative hybrid local search strategy that combines multi-objective segment decomposition with dynamic node insertion, where high-performing solutions from the archive are decomposed into critical and non-critical segments based on their contribution to both objectives, then strategically reinsert non-critical segments into different positions while preserving feasibility and maintaining balanced exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Decompose into critical and non-critical segments\n    critical_segments = []\n    non_critical_segments = []\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        if (segment_cost1 + segment_cost2) > (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n            critical_segments.append(segment)\n        else:\n            non_critical_segments.append(segment)\n\n    # Reinsert non-critical segments dynamically\n    for segment in non_critical_segments:\n        if len(segment) == 0:\n            continue\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution) - len(segment) + 1):\n            temp_sol = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            temp_cost = temp_cost1 + temp_cost2\n\n            if temp_cost < best_cost:\n                best_cost = temp_cost\n                best_pos = i\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7715513778677219,
            3.005585014820099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Decompose into critical and non-critical segments\n    critical_segments = []\n    non_critical_segments = []\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        if (segment_cost1 + segment_cost2) > (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)):\n            critical_segments.append(segment)\n        else:\n            non_critical_segments.append(segment)\n\n    # Reinsert non-critical segments dynamically\n    for segment in non_critical_segments:\n        if len(segment) == 0:\n            continue\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(new_solution) - len(segment) + 1):\n            temp_sol = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            temp_cost = temp_cost1 + temp_cost2\n\n            if temp_cost < best_cost:\n                best_cost = temp_cost\n                best_pos = i\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{A novel adaptive segment exchange and inversion strategy that dynamically selects segments based on their Pareto dominance in both objectives, then inverts or exchanges them with higher probability when they improve both objectives, while maintaining feasibility through a multi-step validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_sol = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_sol.copy()\n    n = len(new_solution)\n\n    # Generate a random solution for exchange\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment exchange with higher probability\n    for i in range(n):\n        if random.random() < 0.6:\n            new_solution[i] = random_sol[i]\n\n    # Multi-objective segment inversion with dynamic probability\n    for _ in range(4):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n        segment = new_solution[a:b]\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Higher probability to invert if both objectives improve\n        if random.random() < 0.8:\n            reversed_segment = segment[::-1]\n            rev_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n            rev_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n            if (rev_cost1 < seg_cost1 and rev_cost2 < seg_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8338004119029868,
            0.5581565499305725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_sol = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_sol.copy()\n    n = len(new_solution)\n\n    # Generate a random solution for exchange\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment exchange with higher probability\n    for i in range(n):\n        if random.random() < 0.6:\n            new_solution[i] = random_sol[i]\n\n    # Multi-objective segment inversion with dynamic probability\n    for _ in range(4):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n        segment = new_solution[a:b]\n\n        # Calculate segment costs\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Higher probability to invert if both objectives improve\n        if random.random() < 0.8:\n            reversed_segment = segment[::-1]\n            rev_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n            rev_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(1, len(reversed_segment)))\n\n            if (rev_cost1 < seg_cost1 and rev_cost2 < seg_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive k-opt moves with objective-aware edge selection to explore high-quality solutions by dynamically adjusting the number of edges to swap based on the relative improvement potential in each objective space while ensuring feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = random.randint(3, min(5, n//2))  # Randomly select k for k-opt move\n\n    # Perform k-opt move\n    indices = sorted(random.sample(range(n), k))\n    segment = new_solution[indices[0]:indices[-1]+1]\n\n    # Reverse the segment with probability 0.5, otherwise rotate\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        rotate_pos = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n\n    new_solution[indices[0]:indices[-1]+1] = segment\n\n    # Objective-aware edge selection\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate potential improvement in both objectives\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j-1]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8248286923786218,
            0.48010188341140747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = random.randint(3, min(5, n//2))  # Randomly select k for k-opt move\n\n    # Perform k-opt move\n    indices = sorted(random.sample(range(n), k))\n    segment = new_solution[indices[0]:indices[-1]+1]\n\n    # Reverse the segment with probability 0.5, otherwise rotate\n    if random.random() < 0.5:\n        segment = segment[::-1]\n    else:\n        rotate_pos = random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[rotate_pos:], segment[:rotate_pos]])\n\n    new_solution[indices[0]:indices[-1]+1] = segment\n\n    # Objective-aware edge selection\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate potential improvement in both objectives\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[j-1]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[j-1]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node clustering with dynamic path inversion to explore high-quality solutions by intelligently grouping nodes based on their dual-objective distances and then inverting paths between these clusters while ensuring feasibility and maintaining solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on distance matrices\n    cluster_size = max(2, min(5, n // 3))\n    clusters = []\n\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Dynamic path inversion between clusters\n    for _ in range(3):\n        if len(clusters) < 2:\n            break\n\n        i, j = random.sample(range(len(clusters)), 2)\n        if i > j:\n            i, j = j, i\n\n        # Invert the path between clusters\n        start_pos = sum(len(clusters[k]) for k in range(i)) + i\n        end_pos = sum(len(clusters[k]) for k in range(j+1)) + j\n\n        if end_pos - start_pos > 1:\n            new_solution[start_pos:end_pos] = new_solution[start_pos:end_pos][::-1]\n\n        # Rebuild clusters\n        clusters = []\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            clusters.append(cluster)\n\n    # Final local refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7968554412779573,
            0.4616137742996216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on distance matrices\n    cluster_size = max(2, min(5, n // 3))\n    clusters = []\n\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Dynamic path inversion between clusters\n    for _ in range(3):\n        if len(clusters) < 2:\n            break\n\n        i, j = random.sample(range(len(clusters)), 2)\n        if i > j:\n            i, j = j, i\n\n        # Invert the path between clusters\n        start_pos = sum(len(clusters[k]) for k in range(i)) + i\n        end_pos = sum(len(clusters[k]) for k in range(j+1)) + j\n\n        if end_pos - start_pos > 1:\n            new_solution[start_pos:end_pos] = new_solution[start_pos:end_pos][::-1]\n\n        # Rebuild clusters\n        clusters = []\n        for i in range(0, n, cluster_size):\n            cluster = new_solution[i:i+cluster_size]\n            clusters.append(cluster)\n\n    # Final local refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{This novel hybrid local search strategy combines multi-objective path relinking with adaptive node clustering, where a high-performing solution from the archive is combined with a diverse solution to create a new path, then nodes are strategically clustered and reinserted based on their spatial proximity and contribution to both objectives, while ensuring the solution remains feasible through a novel clustering and reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    diverse_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = diverse_sol[i]\n\n    # Adaptive node clustering and reinsertion\n    for _ in range(3):\n        # Select a random cluster size\n        cluster_size = random.randint(2, min(5, n-1))\n        a = random.randint(0, n - cluster_size)\n        cluster = new_solution[a:a+cluster_size]\n\n        # Calculate centroids for both objectives\n        centroid1_x = np.mean(instance[cluster, 0])\n        centroid1_y = np.mean(instance[cluster, 1])\n        centroid2_x = np.mean(instance[cluster, 2])\n        centroid2_y = np.mean(instance[cluster, 3])\n\n        # Find the closest node in the remaining solution to the centroid\n        remaining_nodes = [node for node in new_solution if node not in cluster]\n        closest_node = None\n        min_distance = float('inf')\n\n        for node in remaining_nodes:\n            dist1 = np.sqrt((instance[node, 0] - centroid1_x)**2 + (instance[node, 1] - centroid1_y)**2)\n            dist2 = np.sqrt((instance[node, 2] - centroid2_x)**2 + (instance[node, 3] - centroid2_y)**2)\n            total_dist = dist1 + dist2\n            if total_dist < min_distance:\n                min_distance = total_dist\n                closest_node = node\n\n        if closest_node is not None:\n            # Reinsert the cluster after the closest node\n            new_solution = np.concatenate([new_solution[:a], new_solution[a+cluster_size:]])\n            insert_pos = np.where(new_solution == closest_node)[0][0] + 1\n            new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8960903836451275,
            1.4057912230491638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    diverse_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = diverse_sol[i]\n\n    # Adaptive node clustering and reinsertion\n    for _ in range(3):\n        # Select a random cluster size\n        cluster_size = random.randint(2, min(5, n-1))\n        a = random.randint(0, n - cluster_size)\n        cluster = new_solution[a:a+cluster_size]\n\n        # Calculate centroids for both objectives\n        centroid1_x = np.mean(instance[cluster, 0])\n        centroid1_y = np.mean(instance[cluster, 1])\n        centroid2_x = np.mean(instance[cluster, 2])\n        centroid2_y = np.mean(instance[cluster, 3])\n\n        # Find the closest node in the remaining solution to the centroid\n        remaining_nodes = [node for node in new_solution if node not in cluster]\n        closest_node = None\n        min_distance = float('inf')\n\n        for node in remaining_nodes:\n            dist1 = np.sqrt((instance[node, 0] - centroid1_x)**2 + (instance[node, 1] - centroid1_y)**2)\n            dist2 = np.sqrt((instance[node, 2] - centroid2_x)**2 + (instance[node, 3] - centroid2_y)**2)\n            total_dist = dist1 + dist2\n            if total_dist < min_distance:\n                min_distance = total_dist\n                closest_node = node\n\n        if closest_node is not None:\n            # Reinsert the cluster after the closest node\n            new_solution = np.concatenate([new_solution[:a], new_solution[a+cluster_size:]])\n            insert_pos = np.where(new_solution == closest_node)[0][0] + 1\n            new_solution = np.insert(new_solution, insert_pos, cluster)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm combines multi-objective guided segment insertion with dynamic neighborhood exploration, where high-performing segments from the archive are strategically inserted into a randomly perturbed solution while dynamically adjusting the neighborhood size based on the combined improvement potential of both objectives, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Dynamic neighborhood exploration\n    neighborhood_size = min(5, n // 3)\n    for _ in range(3):\n        # Select a segment from the archive solution\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n        segment = new_solution[a:b]\n\n        # Find insertion point in random solution\n        insertion_point = random.randint(0, n - len(segment))\n        candidate = np.concatenate([random_sol[:insertion_point], segment, random_sol[insertion_point + len(segment):]])\n\n        # Evaluate candidate solution\n        candidate_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        candidate_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Accept if better in either objective\n        if (candidate_cost1 < sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))) or \\\n           (candidate_cost2 < sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n            new_solution = candidate.copy()\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7724016740688575,
            1.2001637816429138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Dynamic neighborhood exploration\n    neighborhood_size = min(5, n // 3)\n    for _ in range(3):\n        # Select a segment from the archive solution\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n        segment = new_solution[a:b]\n\n        # Find insertion point in random solution\n        insertion_point = random.randint(0, n - len(segment))\n        candidate = np.concatenate([random_sol[:insertion_point], segment, random_sol[insertion_point + len(segment):]])\n\n        # Evaluate candidate solution\n        candidate_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        candidate_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Accept if better in either objective\n        if (candidate_cost1 < sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))) or \\\n           (candidate_cost2 < sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n            new_solution = candidate.copy()\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route segmentation with dynamic node insertion and removal to explore high-quality solutions in both objective spaces by intelligently rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive route segmentation and rearrangement\n    segment_size = max(2, min(5, n // 3))\n    for _ in range(3):\n        # Select a segment and rotate it\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Rotate the segment\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        new_solution[seg_start:seg_end] = rotated_segment\n\n    # Dynamic node insertion and removal\n    for _ in range(2):\n        # Select a node to remove and reinsert\n        remove_idx = random.randint(0, n - 1)\n        node = new_solution[remove_idx]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Insert the node at a new position\n        insert_idx = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_idx, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8419394705981331,
            0.45146358013153076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive route segmentation and rearrangement\n    segment_size = max(2, min(5, n // 3))\n    for _ in range(3):\n        # Select a segment and rotate it\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Rotate the segment\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n        new_solution[seg_start:seg_end] = rotated_segment\n\n    # Dynamic node insertion and removal\n    for _ in range(2):\n        # Select a node to remove and reinsert\n        remove_idx = random.randint(0, n - 1)\n        node = new_solution[remove_idx]\n\n        # Remove the node\n        new_solution = np.concatenate([new_solution[:remove_idx], new_solution[remove_idx+1:]])\n\n        # Insert the node at a new position\n        insert_idx = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_idx, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{An adaptive hybrid local search algorithm that combines multi-segment relocation with dynamic edge optimization, where segment sizes are determined based on solution quality and edge swaps are guided by objective-space diversity to balance exploration and exploitation in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmax([(obj[0] + obj[1]) for obj in objectives])\n    selected_sol = archive_solutions[selected_idx]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Multi-segment relocation with adaptive size\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Relocate segment to a different position\n        new_pos = random.randint(0, n - segment_size)\n        while abs(new_pos - seg_start) < segment_size:\n            new_pos = random.randint(0, n - segment_size)\n\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Dynamic edge optimization with objective-space guidance\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            # Evaluate potential swap based on both objectives\n            orig_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                       distance_matrix_1[new_solution[i], new_solution[j]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                       distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if new_cost < orig_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8971555407118531,
            0.13628971576690674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmax([(obj[0] + obj[1]) for obj in objectives])\n    selected_sol = archive_solutions[selected_idx]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Multi-segment relocation with adaptive size\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Relocate segment to a different position\n        new_pos = random.randint(0, n - segment_size)\n        while abs(new_pos - seg_start) < segment_size:\n            new_pos = random.randint(0, n - segment_size)\n\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:new_pos],\n            segment,\n            new_solution[new_pos:]\n        ])\n\n    # Dynamic edge optimization with objective-space guidance\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            # Evaluate potential swap based on both objectives\n            orig_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                       distance_matrix_1[new_solution[i], new_solution[j]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                       distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if new_cost < orig_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion and dominance-based selection, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility using Pareto dominance criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive using Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_sol = None\n\n    for sol, obj in archive:\n        dominated = False\n        for other_obj in objectives:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            selected_sol = sol\n            break\n\n    if selected_sol is None:\n        selected_sol = random.choice(archive_solutions)\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + 0.5 * cost2  # Weighted sum for balance\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.92861145895507,
            4.114558517932892
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive using Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_sol = None\n\n    for sol, obj in archive:\n        dominated = False\n        for other_obj in objectives:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                dominated = True\n                break\n        if not dominated:\n            selected_sol = sol\n            break\n\n    if selected_sol is None:\n        selected_sol = random.choice(archive_solutions)\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + 0.5 * cost2  # Weighted sum for balance\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reordering, where a high-performing solution from the archive is combined with a random solution to create a new path, then segments of this path are strategically reordered based on their contribution to both objectives, while ensuring the solution remains feasible, with adjusted parameters for segment selection and reversal probability.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with higher probability\n    for i in range(n):\n        if random.random() < 0.5:\n            new_solution[i] = random_sol[i]\n\n    # Adaptive segment reordering with more iterations\n    for _ in range(3):\n        # Select a longer segment\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 3:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.7:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective adaptive segment reinsertion with probabilistic segment reversal, where a high-performing solution from the archive is modified by strategically reinserting segments from a random solution while adaptively reversing segments based on their combined cost contribution to both objectives, ensuring feasibility through careful validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective adaptive segment reinsertion\n    for i in range(n):\n        if random.random() < 0.4:\n            # Find a segment in the random solution\n            segment_length = random.randint(2, min(4, n//2))\n            segment_start = random.randint(0, n - segment_length)\n            segment = random_sol[segment_start:segment_start+segment_length]\n\n            # Find a position to insert the segment in the new solution\n            insert_pos = random.randint(0, n - segment_length)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos + segment_length:]\n            ])\n\n            # Remove duplicates and fill missing nodes\n            unique_nodes = np.unique(new_solution)\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] in unique_nodes:\n                    continue\n                new_solution[i] = missing_nodes.pop(0)\n\n    # Probabilistic segment reversal\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.6:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8889343430425443,
            7.288899719715118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective adaptive segment reinsertion\n    for i in range(n):\n        if random.random() < 0.4:\n            # Find a segment in the random solution\n            segment_length = random.randint(2, min(4, n//2))\n            segment_start = random.randint(0, n - segment_length)\n            segment = random_sol[segment_start:segment_start+segment_length]\n\n            # Find a position to insert the segment in the new solution\n            insert_pos = random.randint(0, n - segment_length)\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                segment,\n                new_solution[insert_pos + segment_length:]\n            ])\n\n            # Remove duplicates and fill missing nodes\n            unique_nodes = np.unique(new_solution)\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] in unique_nodes:\n                    continue\n                new_solution[i] = missing_nodes.pop(0)\n\n    # Probabilistic segment reversal\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a < 2:\n            continue\n        segment = new_solution[a:b]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n        # Higher probability to reverse based on combined cost\n        if random.random() < 0.6:\n            reversed_segment = segment[::-1]\n            reversed_cost1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n            reversed_cost2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n            if (reversed_cost1 + reversed_cost2) < (segment_cost1 + segment_cost2):\n                new_solution[a:b] = reversed_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{A novel adaptive local search strategy that combines dynamic segment rearrangement with objective-aware edge optimization, where segment sizes and swap probabilities are dynamically adjusted based on the solution's current quality in both objective spaces, while maintaining feasibility through constrained edge selection and reversal.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with potential for improvement (lowest combined distance)\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol, selected_obj = min(archive_solutions, key=lambda x: sum(x[1]))\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment swapping based on objective quality\n    for _ in range(3):\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Objective-aware edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate potential improvement in both objectives\n            before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            reversed_segment = new_solution[i:j][::-1]\n            after_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n            after_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n            # Accept if improvement in at least one objective\n            if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.895304364751447,
            0.0957382321357727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with potential for improvement (lowest combined distance)\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol, selected_obj = min(archive_solutions, key=lambda x: sum(x[1]))\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment swapping based on objective quality\n    for _ in range(3):\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Objective-aware edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate potential improvement in both objectives\n            before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            reversed_segment = new_solution[i:j][::-1]\n            after_cost1 = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n            after_cost2 = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n            # Accept if improvement in at least one objective\n            if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node reinsertion to explore diverse solution spaces by selectively inverting segments and reinserting nodes while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Adaptive segment inversion\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion\n    for _ in range(2):\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7345602471781354,
            0.5977656245231628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Adaptive segment inversion\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion\n    for _ in range(2):\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with multi-objective segment merging, where it intelligently selects and inverts segments of the tour while merging them with other segments to create diverse high-quality solutions, balancing the exploration of both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if (b - a) > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective segment merging\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b]\n\n        c, d = sorted(random.sample(range(n), 2))\n        segment2 = new_solution[c:d]\n\n        # Merge segments by alternating nodes\n        merged = []\n        i, j = 0, 0\n        while i < len(segment1) and j < len(segment2):\n            if random.random() > 0.5:\n                merged.append(segment1[i])\n                i += 1\n            else:\n                merged.append(segment2[j])\n                j += 1\n        merged.extend(segment1[i:])\n        merged.extend(segment2[j:])\n\n        # Replace original segments with merged segment\n        new_solution[a:b] = merged[:min(len(merged), b - a)]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9800815187381482,
            0.38536345958709717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if (b - a) > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective segment merging\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[a:b]\n\n        c, d = sorted(random.sample(range(n), 2))\n        segment2 = new_solution[c:d]\n\n        # Merge segments by alternating nodes\n        merged = []\n        i, j = 0, 0\n        while i < len(segment1) and j < len(segment2):\n            if random.random() > 0.5:\n                merged.append(segment1[i])\n                i += 1\n            else:\n                merged.append(segment2[j])\n                j += 1\n        merged.extend(segment1[i:])\n        merged.extend(segment2[j:])\n\n        # Replace original segments with merged segment\n        new_solution[a:b] = merged[:min(len(merged), b - a)]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{This algorithm combines adaptive path decomposition with multi-objective segment reassembly, where it strategically breaks down high-performing solutions into meaningful segments and reassembles them in a way that optimizes both objectives while maintaining feasibility through dynamic constraint-aware merging.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition\n    segment_size = max(2, min(4, n // 3))\n    segments = []\n    for i in range(0, n, segment_size):\n        segments.append(new_solution[i:i+segment_size])\n\n    # Multi-objective segment reassembly\n    for _ in range(2):\n        # Randomly select two segments to swap\n        if len(segments) >= 2:\n            i, j = random.sample(range(len(segments)), 2)\n            segments[i], segments[j] = segments[j], segments[i]\n\n    # Dynamic constraint-aware merging\n    merged = []\n    for seg in segments:\n        if len(merged) + len(seg) <= n:\n            merged.extend(seg)\n\n    # Ensure feasibility by filling missing nodes\n    if len(merged) < n:\n        missing = [i for i in range(n) if i not in merged]\n        merged.extend(missing)\n\n    new_solution = np.array(merged)\n\n    # Further refinement with edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8644937826377768,
            0.5012622475624084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition\n    segment_size = max(2, min(4, n // 3))\n    segments = []\n    for i in range(0, n, segment_size):\n        segments.append(new_solution[i:i+segment_size])\n\n    # Multi-objective segment reassembly\n    for _ in range(2):\n        # Randomly select two segments to swap\n        if len(segments) >= 2:\n            i, j = random.sample(range(len(segments)), 2)\n            segments[i], segments[j] = segments[j], segments[i]\n\n    # Dynamic constraint-aware merging\n    merged = []\n    for seg in segments:\n        if len(merged) + len(seg) <= n:\n            merged.extend(seg)\n\n    # Ensure feasibility by filling missing nodes\n    if len(merged) < n:\n        missing = [i for i in range(n) if i not in merged]\n        merged.extend(missing)\n\n    new_solution = np.array(merged)\n\n    # Further refinement with edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{This novel algorithm combines adaptive node clustering with multi-objective segment reversal, where the solution is first partitioned into clusters based on spatial proximity in both objective spaces, then high-quality segments are identified by evaluating their contribution to both objectives, and finally, promising segments are reversed to explore new regions of the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on spatial proximity in both objective spaces\n    clusters = []\n    current_cluster = [new_solution[0]]\n\n    for i in range(1, n):\n        # Calculate spatial distance in both spaces\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n\n        dist1 = np.sqrt((instance[prev_node, 0] - instance[curr_node, 0])**2 +\n                        (instance[prev_node, 1] - instance[curr_node, 1])**2)\n        dist2 = np.sqrt((instance[prev_node, 2] - instance[curr_node, 2])**2 +\n                        (instance[prev_node, 3] - instance[curr_node, 3])**2)\n\n        # Cluster threshold based on average distance\n        avg_dist = (dist1 + dist2) / 2\n        threshold = avg_dist * 0.7  # Adjustable parameter\n\n        if dist1 < threshold and dist2 < threshold:\n            current_cluster.append(curr_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [curr_node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Multi-objective segment reversal\n    for cluster in clusters:\n        if len(cluster) > 2:  # Only consider clusters with more than 2 nodes\n            # Evaluate segment contribution to both objectives\n            seg_start = new_solution.tolist().index(cluster[0])\n            seg_end = new_solution.tolist().index(cluster[-1]) + 1\n\n            # Calculate original cost\n            orig_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n            orig_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n\n            # Calculate reversed cost\n            reversed_seg = cluster[::-1]\n            reversed_cost1 = (distance_matrix_1[new_solution[seg_start-1], reversed_seg[0]] +\n                             distance_matrix_1[reversed_seg[-1], new_solution[seg_end]] if seg_end < n else 0)\n            reversed_cost2 = (distance_matrix_2[new_solution[seg_start-1], reversed_seg[0]] +\n                             distance_matrix_2[reversed_seg[-1], new_solution[seg_end]] if seg_end < n else 0)\n\n            # Accept reversal if it improves either objective\n            if (reversed_cost1 < orig_cost1 or reversed_cost2 < orig_cost2):\n                new_solution[seg_start:seg_end] = reversed_seg\n\n    return new_solution\n\n",
        "score": [
            -0.8453846995265901,
            2.949606955051422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on spatial proximity in both objective spaces\n    clusters = []\n    current_cluster = [new_solution[0]]\n\n    for i in range(1, n):\n        # Calculate spatial distance in both spaces\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n\n        dist1 = np.sqrt((instance[prev_node, 0] - instance[curr_node, 0])**2 +\n                        (instance[prev_node, 1] - instance[curr_node, 1])**2)\n        dist2 = np.sqrt((instance[prev_node, 2] - instance[curr_node, 2])**2 +\n                        (instance[prev_node, 3] - instance[curr_node, 3])**2)\n\n        # Cluster threshold based on average distance\n        avg_dist = (dist1 + dist2) / 2\n        threshold = avg_dist * 0.7  # Adjustable parameter\n\n        if dist1 < threshold and dist2 < threshold:\n            current_cluster.append(curr_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [curr_node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Multi-objective segment reversal\n    for cluster in clusters:\n        if len(cluster) > 2:  # Only consider clusters with more than 2 nodes\n            # Evaluate segment contribution to both objectives\n            seg_start = new_solution.tolist().index(cluster[0])\n            seg_end = new_solution.tolist().index(cluster[-1]) + 1\n\n            # Calculate original cost\n            orig_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n            orig_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n\n            # Calculate reversed cost\n            reversed_seg = cluster[::-1]\n            reversed_cost1 = (distance_matrix_1[new_solution[seg_start-1], reversed_seg[0]] +\n                             distance_matrix_1[reversed_seg[-1], new_solution[seg_end]] if seg_end < n else 0)\n            reversed_cost2 = (distance_matrix_2[new_solution[seg_start-1], reversed_seg[0]] +\n                             distance_matrix_2[reversed_seg[-1], new_solution[seg_end]] if seg_end < n else 0)\n\n            # Accept reversal if it improves either objective\n            if (reversed_cost1 < orig_cost1 or reversed_cost2 < orig_cost2):\n                new_solution[seg_start:seg_end] = reversed_seg\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment inversion, where a high-performing solution from the archive is combined with a random solution by strategically inverting segments from the archive solution while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with segment inversion\n    for _ in range(3):\n        # Select a segment from the archive solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point in the random solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(inverted_segment)):\n            # Insert inverted segment at position i in random solution\n            candidate = np.concatenate([random_sol[:i], inverted_segment, random_sol[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best inverted segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.931450520697888,
            5.717956006526947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with segment inversion\n    for _ in range(3):\n        # Select a segment from the archive solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point in the random solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(inverted_segment)):\n            # Insert inverted segment at position i in random solution\n            candidate = np.concatenate([random_sol[:i], inverted_segment, random_sol[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best inverted segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm combines multi-objective optimization with a novel adaptive segment rearrangement strategy, where segments from a high-performing archive solution are strategically reordered and repositioned based on their impact on both objectives, while ensuring feasibility through a dynamic segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rearrangement\n    for _ in range(2):\n        # Select a random segment\n        seg_length = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - seg_length)\n        segment = new_solution[a:a+seg_length]\n\n        # Evaluate segment impact\n        seg_cost1 = sum(distance_matrix_1[new_solution[(a+i-1)%n], new_solution[(a+i)%n]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[new_solution[(a+i-1)%n], new_solution[(a+i)%n]] for i in range(seg_length))\n\n        # Find best rearrangement position\n        best_pos = a\n        best_score = float('inf')\n\n        for i in range(n - seg_length):\n            if i == a:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:i],\n                segment,\n                np.delete(new_solution, list(range(a, a+seg_length)))\n            ])\n\n            # Calculate new segment cost\n            new_seg_cost1 = sum(distance_matrix_1[candidate[(i+j-1)%n], candidate[(i+j)%n]] for j in range(seg_length))\n            new_seg_cost2 = sum(distance_matrix_2[candidate[(i+j-1)%n], candidate[(i+j)%n]] for j in range(seg_length))\n\n            # Calculate total cost improvement\n            cost_improvement = (seg_cost1 + seg_cost2) - (new_seg_cost1 + new_seg_cost2)\n\n            if cost_improvement < best_score:\n                best_score = cost_improvement\n                best_pos = i\n\n        # Apply best rearrangement\n        if best_pos != a:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, list(range(a, a+seg_length)))\n            ])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9297621983535596,
            1.1730005145072937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment rearrangement\n    for _ in range(2):\n        # Select a random segment\n        seg_length = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - seg_length)\n        segment = new_solution[a:a+seg_length]\n\n        # Evaluate segment impact\n        seg_cost1 = sum(distance_matrix_1[new_solution[(a+i-1)%n], new_solution[(a+i)%n]] for i in range(seg_length))\n        seg_cost2 = sum(distance_matrix_2[new_solution[(a+i-1)%n], new_solution[(a+i)%n]] for i in range(seg_length))\n\n        # Find best rearrangement position\n        best_pos = a\n        best_score = float('inf')\n\n        for i in range(n - seg_length):\n            if i == a:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:i],\n                segment,\n                np.delete(new_solution, list(range(a, a+seg_length)))\n            ])\n\n            # Calculate new segment cost\n            new_seg_cost1 = sum(distance_matrix_1[candidate[(i+j-1)%n], candidate[(i+j)%n]] for j in range(seg_length))\n            new_seg_cost2 = sum(distance_matrix_2[candidate[(i+j-1)%n], candidate[(i+j)%n]] for j in range(seg_length))\n\n            # Calculate total cost improvement\n            cost_improvement = (seg_cost1 + seg_cost2) - (new_seg_cost1 + new_seg_cost2)\n\n            if cost_improvement < best_score:\n                best_score = cost_improvement\n                best_pos = i\n\n        # Apply best rearrangement\n        if best_pos != a:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, list(range(a, a+seg_length)))\n            ])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive edge insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting edges from the random solution into the archive solution's path, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with edge insertion\n    for _ in range(3):\n        # Select a random edge from random solution\n        a, b = random.sample(range(n), 2)\n        edge = (random_sol[a], random_sol[b])\n\n        # Find best insertion point to add the edge\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert edge at position i\n            candidate = np.concatenate([new_solution[:i], [edge[0], edge[1]], new_solution[i:]])\n            # Ensure no duplicates and valid tour\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best edge\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [edge[0], edge[1]], new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8694752612581709,
            8.681533455848694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with edge insertion\n    for _ in range(3):\n        # Select a random edge from random solution\n        a, b = random.sample(range(n), 2)\n        edge = (random_sol[a], random_sol[b])\n\n        # Find best insertion point to add the edge\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert edge at position i\n            candidate = np.concatenate([new_solution[:i], [edge[0], edge[1]], new_solution[i:]])\n            # Ensure no duplicates and valid tour\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best edge\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [edge[0], edge[1]], new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route fragmentation with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently breaking and reconstructing segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine fragment size based on problem size\n    n = len(new_solution)\n    fragment_size = max(2, min(5, n // 3))\n\n    # Adaptive route fragmentation and reconstruction\n    for _ in range(2):  # Perform multiple fragmentations\n        # Select a random fragment\n        frag_start = random.randint(0, n - fragment_size)\n        frag_end = frag_start + fragment_size\n        fragment = new_solution[frag_start:frag_end]\n\n        # Remove the fragment and insert it at a new position\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], fragment, new_solution[insert_pos:]])\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):  # Perform multiple node insertions\n        # Select a random node and remove it\n        node_idx = random.randint(0, len(new_solution) - 1)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n        # Insert the node at a new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8491981844067891,
            0.44293397665023804
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine fragment size based on problem size\n    n = len(new_solution)\n    fragment_size = max(2, min(5, n // 3))\n\n    # Adaptive route fragmentation and reconstruction\n    for _ in range(2):  # Perform multiple fragmentations\n        # Select a random fragment\n        frag_start = random.randint(0, n - fragment_size)\n        frag_end = frag_start + fragment_size\n        fragment = new_solution[frag_start:frag_end]\n\n        # Remove the fragment and insert it at a new position\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], fragment, new_solution[insert_pos:]])\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):  # Perform multiple node insertions\n        # Select a random node and remove it\n        node_idx = random.randint(0, len(new_solution) - 1)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n        # Insert the node at a new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node relocation with dynamic path inversion, where high-quality segments from archive solutions are strategically relocated and inverted to create diverse high-performing tours while maintaining feasibility and balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with dynamic path inversion\n    for _ in range(3):\n        # Select a segment to relocate\n        seg_size = max(2, min(4, n // 5))\n        seg_start = random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n\n        # Remove the segment from the solution\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_size:]])\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            # Try inserting the segment normally\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n            # Try inserting the inverted segment\n            inverted_segment = segment[::-1]\n            candidate_inv = np.concatenate([remaining[:i], inverted_segment, remaining[i:]])\n            cost1_inv = sum(distance_matrix_1[candidate_inv[j-1], candidate_inv[j]] for j in range(1, n))\n            cost2_inv = sum(distance_matrix_2[candidate_inv[j-1], candidate_inv[j]] for j in range(1, n))\n            total_cost_inv = cost1_inv + cost2_inv\n\n            if total_cost_inv < best_cost:\n                best_cost = total_cost_inv\n                best_pos = i\n                segment = inverted_segment\n\n        # Insert the best segment (possibly inverted)\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Dynamic path inversion for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Invert the path between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9057592339424624,
            14.546084225177765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with dynamic path inversion\n    for _ in range(3):\n        # Select a segment to relocate\n        seg_size = max(2, min(4, n // 5))\n        seg_start = random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n\n        # Remove the segment from the solution\n        remaining = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_size:]])\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(remaining)):\n            # Try inserting the segment normally\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n            # Try inserting the inverted segment\n            inverted_segment = segment[::-1]\n            candidate_inv = np.concatenate([remaining[:i], inverted_segment, remaining[i:]])\n            cost1_inv = sum(distance_matrix_1[candidate_inv[j-1], candidate_inv[j]] for j in range(1, n))\n            cost2_inv = sum(distance_matrix_2[candidate_inv[j-1], candidate_inv[j]] for j in range(1, n))\n            total_cost_inv = cost1_inv + cost2_inv\n\n            if total_cost_inv < best_cost:\n                best_cost = total_cost_inv\n                best_pos = i\n                segment = inverted_segment\n\n        # Insert the best segment (possibly inverted)\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Dynamic path inversion for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Invert the path between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive tour partitioning with multi-objective edge insertion to explore diverse solutions by intelligently inserting and rearranging sub-tours while balancing improvements in both objective spaces and maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine partition size based on problem size\n    n = len(new_solution)\n    partition_size = max(2, min(5, n // 3))\n\n    # Adaptive tour partitioning and rearrangement\n    for _ in range(3):  # Perform multiple partitions\n        # Select a partition point\n        partition_point = random.randint(partition_size, n - partition_size)\n\n        # Split the tour into three parts\n        part1 = new_solution[:partition_point]\n        part2 = new_solution[partition_point:]\n\n        # Recombine parts in different orders\n        if random.random() < 0.5:\n            new_solution = np.concatenate([part2, part1])\n        else:\n            new_solution = np.concatenate([part1[::-1], part2[::-1]])\n\n    # Multi-objective edge insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        # Select two random nodes\n        a, b = random.sample(range(n), 2)\n\n        # Calculate potential improvements in both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Try inserting node a after node b\n        temp_sol = new_solution.copy()\n        temp_sol = np.delete(temp_sol, a)\n        temp_sol = np.insert(temp_sol, b, new_solution[a])\n\n        new_cost1 = distance_matrix_1[temp_sol[a-1], temp_sol[a]] + distance_matrix_1[temp_sol[b-1], temp_sol[b]]\n        new_cost2 = distance_matrix_2[temp_sol[a-1], temp_sol[a]] + distance_matrix_2[temp_sol[b-1], temp_sol[b]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.8039887391614644,
            0.5646273493766785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine partition size based on problem size\n    n = len(new_solution)\n    partition_size = max(2, min(5, n // 3))\n\n    # Adaptive tour partitioning and rearrangement\n    for _ in range(3):  # Perform multiple partitions\n        # Select a partition point\n        partition_point = random.randint(partition_size, n - partition_size)\n\n        # Split the tour into three parts\n        part1 = new_solution[:partition_point]\n        part2 = new_solution[partition_point:]\n\n        # Recombine parts in different orders\n        if random.random() < 0.5:\n            new_solution = np.concatenate([part2, part1])\n        else:\n            new_solution = np.concatenate([part1[::-1], part2[::-1]])\n\n    # Multi-objective edge insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        # Select two random nodes\n        a, b = random.sample(range(n), 2)\n\n        # Calculate potential improvements in both objectives\n        original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Try inserting node a after node b\n        temp_sol = new_solution.copy()\n        temp_sol = np.delete(temp_sol, a)\n        temp_sol = np.insert(temp_sol, b, new_solution[a])\n\n        new_cost1 = distance_matrix_1[temp_sol[a-1], temp_sol[a]] + distance_matrix_1[temp_sol[b-1], temp_sol[b]]\n        new_cost2 = distance_matrix_2[temp_sol[a-1], temp_sol[a]] + distance_matrix_2[temp_sol[b-1], temp_sol[b]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n            new_solution = temp_sol\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path optimization to explore high-quality solutions by intelligently inserting and reordering nodes while maintaining feasibility and balancing improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert it at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path optimization\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is not feasible\")\n\n    return new_solution\n\n",
        "score": [
            -1.0038676831756883,
            0.5127674341201782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert it at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path optimization\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is not feasible\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment inversion, where a high-performing solution from the archive is combined with a random solution by strategically inverting and inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with segment inversion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(inverted_segment)):\n            # Insert inverted segment at position i\n            candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best inverted segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8687812087220392,
            5.991790771484375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with segment inversion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(inverted_segment)):\n            # Insert inverted segment at position i\n            candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best inverted segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm employs a dynamic segment inversion strategy combined with adaptive edge flipping to explore diverse neighborhoods while balancing exploration and exploitation, using problem-specific distance matrices to guide the search toward Pareto-optimal regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    def objective_score(sol, obj):\n        return obj[0] + obj[1] * 0.7  # Weighted sum of objectives\n\n    scored_solutions = [(sol, objective_score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[1])\n    base_solution = random.choice(scored_solutions[:max(3, len(scored_solutions)//3)])[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - 3)\n        seg_end = seg_start + random.randint(2, min(6, n - seg_start - 1))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive edge flipping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate potential flip based on both objectives\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            flipped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_1[new_solution[i], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if flipped_cost < current_cost * 1.05:  # Allow small worsening\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7769093680974576,
            0.5280559659004211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    def objective_score(sol, obj):\n        return obj[0] + obj[1] * 0.7  # Weighted sum of objectives\n\n    scored_solutions = [(sol, objective_score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[1])\n    base_solution = random.choice(scored_solutions[:max(3, len(scored_solutions)//3)])[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - 3)\n        seg_end = seg_start + random.randint(2, min(6, n - seg_start - 1))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive edge flipping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate potential flip based on both objectives\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            flipped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_1[new_solution[i], new_solution[j]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if flipped_cost < current_cost * 1.05:  # Allow small worsening\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment reversal, where a high-performing solution from the archive is combined with a random solution by strategically reversing segments from the random solution and inserting them into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n        reversed_segment = segment[::-1]\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9280395248916219,
            6.046106517314911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n        reversed_segment = segment[::-1]\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{This novel hybrid local search strategy combines multi-objective path decomposition with adaptive node relocation, where a promising solution from the archive is decomposed into critical and non-critical segments based on their contribution to both objectives, and then intelligently relocates non-critical nodes to alternative positions while preserving the core structure of the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Calculate edge contributions for both objectives\n    edge_contributions = []\n    for i in range(n):\n        j = (i + 1) % n\n        contrib1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        contrib2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        edge_contributions.append((contrib1 + contrib2, i))\n\n    # Sort edges by contribution (highest first)\n    edge_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Identify critical edges (top 20% or at least 2 edges)\n    num_critical = max(2, int(n * 0.2))\n    critical_edges = [edge_contributions[i][1] for i in range(num_critical)]\n\n    # Create a mask of critical nodes\n    critical_nodes = set()\n    for edge in critical_edges:\n        critical_nodes.add(new_solution[edge])\n        critical_nodes.add(new_solution[(edge + 1) % n])\n\n    # Relocate non-critical nodes\n    non_critical_nodes = [node for node in new_solution if node not in critical_nodes]\n\n    # Shuffle non-critical nodes\n    random.shuffle(non_critical_nodes)\n\n    # Rebuild solution with critical nodes fixed and non-critical nodes inserted\n    rebuilt_solution = []\n    critical_index = 0\n    non_critical_index = 0\n\n    # First pass: place critical nodes in order\n    for i in range(n):\n        if new_solution[i] in critical_nodes:\n            rebuilt_solution.append(new_solution[i])\n            critical_index += 1\n\n    # Second pass: insert non-critical nodes in remaining positions\n    for i in range(n):\n        if new_solution[i] not in critical_nodes:\n            rebuilt_solution.insert(i, non_critical_nodes[non_critical_index])\n            non_critical_index += 1\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(rebuilt_solution)) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in rebuilt_solution]\n        for i in range(n):\n            if rebuilt_solution[i] in critical_nodes:\n                continue\n            rebuilt_solution[i] = missing_nodes.pop(0)\n\n    return np.array(rebuilt_solution)\n\n",
        "score": [
            -0.837266544591657,
            0.5664799809455872
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Calculate edge contributions for both objectives\n    edge_contributions = []\n    for i in range(n):\n        j = (i + 1) % n\n        contrib1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        contrib2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        edge_contributions.append((contrib1 + contrib2, i))\n\n    # Sort edges by contribution (highest first)\n    edge_contributions.sort(reverse=True, key=lambda x: x[0])\n\n    # Identify critical edges (top 20% or at least 2 edges)\n    num_critical = max(2, int(n * 0.2))\n    critical_edges = [edge_contributions[i][1] for i in range(num_critical)]\n\n    # Create a mask of critical nodes\n    critical_nodes = set()\n    for edge in critical_edges:\n        critical_nodes.add(new_solution[edge])\n        critical_nodes.add(new_solution[(edge + 1) % n])\n\n    # Relocate non-critical nodes\n    non_critical_nodes = [node for node in new_solution if node not in critical_nodes]\n\n    # Shuffle non-critical nodes\n    random.shuffle(non_critical_nodes)\n\n    # Rebuild solution with critical nodes fixed and non-critical nodes inserted\n    rebuilt_solution = []\n    critical_index = 0\n    non_critical_index = 0\n\n    # First pass: place critical nodes in order\n    for i in range(n):\n        if new_solution[i] in critical_nodes:\n            rebuilt_solution.append(new_solution[i])\n            critical_index += 1\n\n    # Second pass: insert non-critical nodes in remaining positions\n    for i in range(n):\n        if new_solution[i] not in critical_nodes:\n            rebuilt_solution.insert(i, non_critical_nodes[non_critical_index])\n            non_critical_index += 1\n\n    # Ensure solution is valid (no duplicates)\n    if len(np.unique(rebuilt_solution)) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in rebuilt_solution]\n        for i in range(n):\n            if rebuilt_solution[i] in critical_nodes:\n                continue\n            rebuilt_solution[i] = missing_nodes.pop(0)\n\n    return np.array(rebuilt_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective adaptive path reversal with dynamic node reinsertion, where segments of the tour are intelligently reversed based on their contribution to both objectives, followed by selective reinsertion of nodes to balance the trade-off between the two objectives while ensuring feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective adaptive path reversal\n    for _ in range(3):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment costs in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Decide whether to reverse based on objective balance\n        if random.random() < 0.5 or (seg_cost1 > seg_cost2 and random.random() < 0.7):\n            new_solution[a:b] = segment[::-1]\n\n    # Dynamic node reinsertion\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Insert node at position i\n            candidate = np.insert(new_solution, i, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9030505770627675,
            6.393947422504425
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective adaptive path reversal\n    for _ in range(3):\n        # Select a random segment\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment costs in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Decide whether to reverse based on objective balance\n        if random.random() < 0.5 or (seg_cost1 > seg_cost2 and random.random() < 0.7):\n            new_solution[a:b] = segment[::-1]\n\n    # Dynamic node reinsertion\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Insert node at position i\n            candidate = np.insert(new_solution, i, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path decomposition with multi-objective edge insertion, where a solution from the archive is decomposed into multiple segments based on their contribution to both objectives, then strategically reinserts these segments using a multi-objective evaluation to balance improvements in both spaces while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = max(2, n // 5)  # Number of segments to decompose\n\n    # Adaptive path decomposition\n    segments = []\n    segment_length = n // k\n    for i in range(k):\n        start = i * segment_length\n        end = (i + 1) * segment_length if i < k - 1 else n\n        segments.append(new_solution[start:end])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg))) if len(seg) > 1 else 0\n        seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg))) if len(seg) > 1 else 0\n        total_cost = seg_cost1 + seg_cost2\n        segment_scores.append(total_cost)\n\n    # Sort segments by their score (lower is better)\n    sorted_segments = [x for _, x in sorted(zip(segment_scores, segments), key=lambda pair: pair[0])]\n\n    # Reconstruct solution with segments in order of their scores\n    new_solution = np.concatenate(sorted_segments)\n\n    # Multi-objective edge insertion for further refinement\n    for _ in range(3):\n        # Select a random segment to reinsert\n        seg_idx = random.randint(0, len(segments) - 1)\n        segment = segments[seg_idx]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.85357783791323,
            8.199887096881866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = max(2, n // 5)  # Number of segments to decompose\n\n    # Adaptive path decomposition\n    segments = []\n    segment_length = n // k\n    for i in range(k):\n        start = i * segment_length\n        end = (i + 1) * segment_length if i < k - 1 else n\n        segments.append(new_solution[start:end])\n\n    # Evaluate segments based on their contribution to both objectives\n    segment_scores = []\n    for seg in segments:\n        seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(1, len(seg))) if len(seg) > 1 else 0\n        seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(1, len(seg))) if len(seg) > 1 else 0\n        total_cost = seg_cost1 + seg_cost2\n        segment_scores.append(total_cost)\n\n    # Sort segments by their score (lower is better)\n    sorted_segments = [x for _, x in sorted(zip(segment_scores, segments), key=lambda pair: pair[0])]\n\n    # Reconstruct solution with segments in order of their scores\n    new_solution = np.concatenate(sorted_segments)\n\n    # Multi-objective edge insertion for further refinement\n    for _ in range(3):\n        # Select a random segment to reinsert\n        seg_idx = random.randint(0, len(segments) - 1)\n        segment = segments[seg_idx]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path optimization to explore the solution space by intelligently repositioning nodes and optimizing paths in both objective spaces while maintaining tour feasibility and balancing exploration of diverse regions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with path optimization\n    for _ in range(3):\n        # Randomly select a node to reposition\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position considering both objectives\n        best_cost = float('inf')\n        best_pos = 0\n\n        for pos in range(len(new_solution)):\n            # Insert node at position pos and calculate cost\n            temp_solution = np.insert(new_solution, pos, node)\n\n            # Calculate total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n            # Use weighted sum to balance both objectives\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path optimization by reversing segments\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.934672141112483,
            9.339787304401398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with path optimization\n    for _ in range(3):\n        # Randomly select a node to reposition\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position considering both objectives\n        best_cost = float('inf')\n        best_pos = 0\n\n        for pos in range(len(new_solution)):\n            # Insert node at position pos and calculate cost\n            temp_solution = np.insert(new_solution, pos, node)\n\n            # Calculate total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n            # Use weighted sum to balance both objectives\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path optimization by reversing segments\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path optimization to explore high-quality solutions by intelligently reinserting nodes and optimizing paths while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with dynamic path optimization\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution, pos, node)\n\n            # Calculate total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path optimization for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Reverse the segment between i and j\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8986598729346438,
            9.345024406909943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with dynamic path optimization\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n - 1):\n            temp_sol = np.insert(new_solution, pos, node)\n\n            # Calculate total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path optimization for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Reverse the segment between i and j\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment rearrangement with dynamic node reordering to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 30% by combined objective)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = random.choice(sorted_archive[:max(1, len(archive) // 3)])[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Randomly shift the segment\n        shift = random.randint(-segment_size, segment_size)\n        new_start = max(0, min(n - segment_size, seg_start + shift))\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove and reinsert the segment\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert at new position\n        new_solution = np.concatenate([\n            new_solution[:new_start],\n            segment,\n            new_solution[new_start:]\n        ])\n\n    # Dynamic node reordering\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            # Reverse a middle segment\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9089475384321295,
            0.10442501306533813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 30% by combined objective)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = random.choice(sorted_archive[:max(1, len(archive) // 3)])[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Randomly shift the segment\n        shift = random.randint(-segment_size, segment_size)\n        new_start = max(0, min(n - segment_size, seg_start + shift))\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove and reinsert the segment\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert at new position\n        new_solution = np.concatenate([\n            new_solution[:new_start],\n            segment,\n            new_solution[new_start:]\n        ])\n\n    # Dynamic node reordering\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            # Reverse a middle segment\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{An adaptive tour restructuring algorithm that combines dynamic segment inversion with objective-aware edge replacement to exploit complementary patterns in multi-objective spaces by selectively modifying and reconfiguring solution segments while maintaining feasibility and balancing improvement across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment inversion with objective-aware selection\n    for _ in range(3):\n        # Select a segment based on objective improvement potential\n        segment_size = max(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate potential improvement for this segment\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n\n        # Invert the segment if it shows potential for improvement\n        if random.random() < 0.7 or (current_cost1 > 0 and current_cost2 > 0):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware edge replacement\n    for _ in range(2):\n        # Select two edges based on their contribution to the objectives\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Replace edges if it improves both objectives\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8850995972328828,
            0.5377463102340698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment inversion with objective-aware selection\n    for _ in range(3):\n        # Select a segment based on objective improvement potential\n        segment_size = max(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate potential improvement for this segment\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n\n        # Invert the segment if it shows potential for improvement\n        if random.random() < 0.7 or (current_cost1 > 0 and current_cost2 > 0):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Objective-aware edge replacement\n    for _ in range(2):\n        # Select two edges based on their contribution to the objectives\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the potential improvement\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Replace edges if it improves both objectives\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The new algorithm combines multi-objective segment relocation with dynamic segment inversion, where high-performing segments from archive solutions are strategically relocated and inverted to explore diverse regions of the search space while maintaining feasibility and balancing both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Multi-objective segment relocation with dynamic inversion\n    for _ in range(3):\n        # Select a random segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Decide whether to invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best relocation position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - segment_size + 1):\n            # Create candidate solution\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the segment\n        if best_pos != seg_start:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8828189332519172,
            8.686497271060944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Multi-objective segment relocation with dynamic inversion\n    for _ in range(3):\n        # Select a random segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Decide whether to invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best relocation position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - segment_size + 1):\n            # Create candidate solution\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the segment\n        if best_pos != seg_start:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment reversal, where a high-performing solution from the archive is combined with a random solution by strategically reversing segments from the random solution and inserting them into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment reversal and insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            # Insert reversed segment at position i\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best reversed segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.917494101410463,
            6.427163779735565
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment reversal and insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            # Insert reversed segment at position i\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best reversed segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        # Select a segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge selection for further refinement\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8038931476752869,
            0.49576348066329956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        # Select a segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge selection for further refinement\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions by intelligently inserting nodes and reversing segments while maintaining feasibility and balancing the trade-off between the two objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(2):\n        # Select a random node to remove and reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n - 1):\n            # Insert node at position pos\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8947623339417943,
            6.607869982719421
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(2):\n        # Select a random node to remove and reinsert\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(n - 1):\n            # Insert node at position pos\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Insert at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{This algorithm implements a novel hybrid local search strategy that combines multi-objective path relinking with adaptive node reinsertion, where a high-performing solution from the archive is combined with a random solution by strategically reinserting nodes from the random solution into the archive solution while evaluating the impact on both objectives and ensuring feasibility through a novel node repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node from random solution\n        node_to_insert = random.choice(random_sol)\n        if node_to_insert in new_solution:\n            continue\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Create candidate solution by inserting node at position i\n            candidate = np.insert(new_solution, i, node_to_insert)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Adaptive node reinsertion for further refinement\n    for _ in range(2):\n        # Select a random node to remove\n        node_to_remove = random.choice(new_solution)\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_remove)[0][0])\n\n        # Find best position to reinsert the removed node\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Create candidate solution by inserting node at position i\n            candidate = np.insert(temp_solution, i, node_to_remove)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Reinsert the node at best position\n        new_solution = np.insert(temp_solution, best_pos, node_to_remove)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7522095376171418,
            7.520192921161652
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node from random solution\n        node_to_insert = random.choice(random_sol)\n        if node_to_insert in new_solution:\n            continue\n\n        # Find best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Create candidate solution by inserting node at position i\n            candidate = np.insert(new_solution, i, node_to_insert)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at best position\n        new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Adaptive node reinsertion for further refinement\n    for _ in range(2):\n        # Select a random node to remove\n        node_to_remove = random.choice(new_solution)\n        temp_solution = np.delete(new_solution, np.where(new_solution == node_to_remove)[0][0])\n\n        # Find best position to reinsert the removed node\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Create candidate solution by inserting node at position i\n            candidate = np.insert(temp_solution, i, node_to_remove)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Reinsert the node at best position\n        new_solution = np.insert(temp_solution, best_pos, node_to_remove)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective-aware node insertion with adaptive path reversal to explore high-quality solutions by intelligently inserting nodes from promising segments and reversing paths based on their contribution to both objectives while maintaining feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_sol, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = best_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware node insertion\n    for _ in range(3):\n        # Select a random segment of nodes\n        seg_size = max(2, min(5, n // 5))\n        seg_start = random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start + seg_size]\n\n        # Calculate the average contribution of the segment to both objectives\n        seg_contrib = 0\n        for i in range(seg_size - 1):\n            seg_contrib += (distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]) / 2\n        seg_contrib += (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) / 2\n\n        # Insert the segment in a different position if it improves the solution\n        for _ in range(2):\n            new_pos = random.randint(0, n - 1)\n            if new_pos < seg_start:\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:seg_start], new_solution[seg_start + seg_size:]])\n            else:\n                new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_size:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive path reversal based on objective improvement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate the change in total cost\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8175634833569143,
            0.13533645868301392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_sol, _ = min(archive, key=lambda x: sum(x[1]))\n    new_solution = best_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective-aware node insertion\n    for _ in range(3):\n        # Select a random segment of nodes\n        seg_size = max(2, min(5, n // 5))\n        seg_start = random.randint(0, n - seg_size)\n        segment = new_solution[seg_start:seg_start + seg_size]\n\n        # Calculate the average contribution of the segment to both objectives\n        seg_contrib = 0\n        for i in range(seg_size - 1):\n            seg_contrib += (distance_matrix_1[segment[i], segment[i+1]] + distance_matrix_2[segment[i], segment[i+1]]) / 2\n        seg_contrib += (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]) / 2\n\n        # Insert the segment in a different position if it improves the solution\n        for _ in range(2):\n            new_pos = random.randint(0, n - 1)\n            if new_pos < seg_start:\n                new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:seg_start], new_solution[seg_start + seg_size:]])\n            else:\n                new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_size:new_pos], segment, new_solution[new_pos:]])\n\n    # Adaptive path reversal based on objective improvement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate the change in total cost\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{A novel adaptive hybrid local search strategy that combines dynamic segment rearrangement with objective-aware edge insertion to explore Pareto-optimal regions by intelligently balancing segment swaps with edge-based improvements while maintaining feasibility and diversity through adaptive neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    def objective_score(obj):\n        return obj[0] + obj[1]  # Simple sum for selection\n\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: objective_score(x[1]))\n    selected_sol = archive_solutions[0][0] if archive_solutions else archive[0][0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Dynamic segment rearrangement\n    for _ in range(3):\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n        seg1 = new_solution[seg1_start:seg1_end]\n\n        # Insert elsewhere\n        insert_pos = random.randint(0, n - segment_size)\n        if insert_pos >= seg1_start:\n            insert_pos += segment_size\n\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            new_solution[seg1_end:insert_pos],\n            seg1,\n            new_solution[insert_pos:]\n        ])\n\n    # Objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j and (j - i) % n > 1:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6714009016903708,
            0.10255312919616699
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    def objective_score(obj):\n        return obj[0] + obj[1]  # Simple sum for selection\n\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: objective_score(x[1]))\n    selected_sol = archive_solutions[0][0] if archive_solutions else archive[0][0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Dynamic segment rearrangement\n    for _ in range(3):\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n        seg1 = new_solution[seg1_start:seg1_end]\n\n        # Insert elsewhere\n        insert_pos = random.randint(0, n - segment_size)\n        if insert_pos >= seg1_start:\n            insert_pos += segment_size\n\n        new_solution = np.concatenate([\n            new_solution[:seg1_start],\n            new_solution[seg1_end:insert_pos],\n            seg1,\n            new_solution[insert_pos:]\n        ])\n\n    # Objective-aware edge insertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j and (j - i) % n > 1:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{An adaptive multi-segment rearrangement strategy that combines hierarchical segment decomposition with dynamic objective-aware segment merging to explore diverse high-quality solutions by intelligently partitioning, reordering, and merging segments while balancing improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Hierarchical segment decomposition\n    segments = []\n    for i in range(0, n, segment_size):\n        segments.append(new_solution[i:i+segment_size])\n\n    # Dynamic objective-aware segment merging\n    for _ in range(2):\n        if len(segments) < 2:\n            break\n\n        # Select segments to merge\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate merging in both objectives\n        merged = np.concatenate([segments[i], segments[j]])\n        cost1 = sum(distance_matrix_1[merged[k-1], merged[k]] for k in range(1, len(merged)))\n        cost2 = sum(distance_matrix_2[merged[k-1], merged[k]] for k in range(1, len(merged)))\n\n        # Calculate original costs\n        orig_cost1 = (sum(distance_matrix_1[segments[i][k-1], segments[i][k]] for k in range(1, len(segments[i]))) +\n                      sum(distance_matrix_1[segments[j][k-1], segments[j][k]] for k in range(1, len(segments[j]))))\n        orig_cost2 = (sum(distance_matrix_2[segments[i][k-1], segments[i][k]] for k in range(1, len(segments[i]))) +\n                      sum(distance_matrix_2[segments[j][k-1], segments[j][k]] for k in range(1, len(segments[j]))))\n\n        # Merge if beneficial in at least one objective\n        if (cost1 < orig_cost1 or cost2 < orig_cost2):\n            segments[i] = merged\n            del segments[j]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment reordering\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        i, j = random.sample(range(len(segments)), 2)\n        segments[i], segments[j] = segments[j], segments[i]\n        new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6788154556296615,
            0.5106204152107239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Hierarchical segment decomposition\n    segments = []\n    for i in range(0, n, segment_size):\n        segments.append(new_solution[i:i+segment_size])\n\n    # Dynamic objective-aware segment merging\n    for _ in range(2):\n        if len(segments) < 2:\n            break\n\n        # Select segments to merge\n        i, j = random.sample(range(len(segments)), 2)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate merging in both objectives\n        merged = np.concatenate([segments[i], segments[j]])\n        cost1 = sum(distance_matrix_1[merged[k-1], merged[k]] for k in range(1, len(merged)))\n        cost2 = sum(distance_matrix_2[merged[k-1], merged[k]] for k in range(1, len(merged)))\n\n        # Calculate original costs\n        orig_cost1 = (sum(distance_matrix_1[segments[i][k-1], segments[i][k]] for k in range(1, len(segments[i]))) +\n                      sum(distance_matrix_1[segments[j][k-1], segments[j][k]] for k in range(1, len(segments[j]))))\n        orig_cost2 = (sum(distance_matrix_2[segments[i][k-1], segments[i][k]] for k in range(1, len(segments[i]))) +\n                      sum(distance_matrix_2[segments[j][k-1], segments[j][k]] for k in range(1, len(segments[j]))))\n\n        # Merge if beneficial in at least one objective\n        if (cost1 < orig_cost1 or cost2 < orig_cost2):\n            segments[i] = merged\n            del segments[j]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Adaptive segment reordering\n    for _ in range(3):\n        if len(segments) < 2:\n            break\n\n        i, j = random.sample(range(len(segments)), 2)\n        segments[i], segments[j] = segments[j], segments[i]\n        new_solution = np.concatenate(segments)\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective edge selection with adaptive segment inversion to explore high-quality solutions by dynamically balancing improvements in both objective spaces through selective segment reversal and edge swaps while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective edge selection and inversion\n    for _ in range(3):\n        # Select a segment to potentially invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[seg_start], new_solution[seg_end]] + distance_matrix_1[new_solution[seg_end], new_solution[(seg_start + 1) % n]]\n        original_cost2 = distance_matrix_2[new_solution[seg_start], new_solution[seg_end]] + distance_matrix_2[new_solution[seg_end], new_solution[(seg_start + 1) % n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[seg_start], new_solution[(seg_end - 1) % n]] + distance_matrix_1[new_solution[(seg_end - 1) % n], new_solution[(seg_start + 1) % n]]\n        inverted_cost2 = distance_matrix_2[new_solution[seg_start], new_solution[(seg_end - 1) % n]] + distance_matrix_2[new_solution[(seg_end - 1) % n], new_solution[(seg_start + 1) % n]]\n\n        # Invert if it improves at least one objective\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive segment swapping based on distance matrices\n    for _ in range(2):\n        seg1_start = random.randint(0, n - 3)\n        seg1_end = random.randint(seg1_start + 1, n - 2)\n\n        seg2_start = random.randint(0, n - 3)\n        seg2_end = random.randint(seg2_start + 1, n - 2)\n\n        # Ensure segments don't overlap\n        if not (seg1_start < seg2_end and seg1_end > seg2_start):\n            # Calculate potential improvement\n            seg1_cost1 = distance_matrix_1[new_solution[seg1_start], new_solution[seg1_end]] + distance_matrix_1[new_solution[seg1_end], new_solution[(seg1_start + 1) % n]]\n            seg1_cost2 = distance_matrix_2[new_solution[seg1_start], new_solution[seg1_end]] + distance_matrix_2[new_solution[seg1_end], new_solution[(seg1_start + 1) % n]]\n\n            seg2_cost1 = distance_matrix_1[new_solution[seg2_start], new_solution[seg2_end]] + distance_matrix_1[new_solution[seg2_end], new_solution[(seg2_start + 1) % n]]\n            seg2_cost2 = distance_matrix_2[new_solution[seg2_start], new_solution[seg2_end]] + distance_matrix_2[new_solution[seg2_end], new_solution[(seg2_start + 1) % n]]\n\n            # Swap if it improves at least one objective\n            if (seg1_cost1 + seg2_cost1 > seg2_cost1 + seg1_cost1) or (seg1_cost2 + seg2_cost2 > seg2_cost2 + seg1_cost2):\n                seg1 = new_solution[seg1_start:seg1_end].copy()\n                seg2 = new_solution[seg2_start:seg2_end].copy()\n                new_solution[seg1_start:seg1_end] = seg2\n                new_solution[seg2_start:seg2_end] = seg1\n\n    return new_solution\n\n",
        "score": [
            -0.8321039757134503,
            0.5236735343933105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective edge selection and inversion\n    for _ in range(3):\n        # Select a segment to potentially invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[seg_start], new_solution[seg_end]] + distance_matrix_1[new_solution[seg_end], new_solution[(seg_start + 1) % n]]\n        original_cost2 = distance_matrix_2[new_solution[seg_start], new_solution[seg_end]] + distance_matrix_2[new_solution[seg_end], new_solution[(seg_start + 1) % n]]\n\n        inverted_cost1 = distance_matrix_1[new_solution[seg_start], new_solution[(seg_end - 1) % n]] + distance_matrix_1[new_solution[(seg_end - 1) % n], new_solution[(seg_start + 1) % n]]\n        inverted_cost2 = distance_matrix_2[new_solution[seg_start], new_solution[(seg_end - 1) % n]] + distance_matrix_2[new_solution[(seg_end - 1) % n], new_solution[(seg_start + 1) % n]]\n\n        # Invert if it improves at least one objective\n        if (inverted_cost1 < original_cost1) or (inverted_cost2 < original_cost2):\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive segment swapping based on distance matrices\n    for _ in range(2):\n        seg1_start = random.randint(0, n - 3)\n        seg1_end = random.randint(seg1_start + 1, n - 2)\n\n        seg2_start = random.randint(0, n - 3)\n        seg2_end = random.randint(seg2_start + 1, n - 2)\n\n        # Ensure segments don't overlap\n        if not (seg1_start < seg2_end and seg1_end > seg2_start):\n            # Calculate potential improvement\n            seg1_cost1 = distance_matrix_1[new_solution[seg1_start], new_solution[seg1_end]] + distance_matrix_1[new_solution[seg1_end], new_solution[(seg1_start + 1) % n]]\n            seg1_cost2 = distance_matrix_2[new_solution[seg1_start], new_solution[seg1_end]] + distance_matrix_2[new_solution[seg1_end], new_solution[(seg1_start + 1) % n]]\n\n            seg2_cost1 = distance_matrix_1[new_solution[seg2_start], new_solution[seg2_end]] + distance_matrix_1[new_solution[seg2_end], new_solution[(seg2_start + 1) % n]]\n            seg2_cost2 = distance_matrix_2[new_solution[seg2_start], new_solution[seg2_end]] + distance_matrix_2[new_solution[seg2_end], new_solution[(seg2_start + 1) % n]]\n\n            # Swap if it improves at least one objective\n            if (seg1_cost1 + seg2_cost1 > seg2_cost1 + seg1_cost1) or (seg1_cost2 + seg2_cost2 > seg2_cost2 + seg1_cost2):\n                seg1 = new_solution[seg1_start:seg1_end].copy()\n                seg2 = new_solution[seg2_start:seg2_end].copy()\n                new_solution[seg1_start:seg1_end] = seg2\n                new_solution[seg2_start:seg2_end] = seg1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node relocation to explore high-quality solutions by intelligently inverting segments of the tour and strategically relocating nodes while balancing the trade-off between the two objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    for _ in range(3):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node relocation\n    for _ in range(2):\n        node_idx = random.randint(0, n - 1)\n        new_pos = random.randint(0, n - 1)\n        if node_idx != new_pos:\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7948070113662085,
            0.48037493228912354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    for _ in range(3):\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node relocation\n    for _ in range(2):\n        node_idx = random.randint(0, n - 1)\n        new_pos = random.randint(0, n - 1)\n        if node_idx != new_pos:\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This algorithm employs a novel hybrid approach combining adaptive node clustering with multi-objective edge inversion, where nodes are dynamically grouped based on their proximity in both objective spaces, followed by selective inversion of edges that most improve Pareto dominance while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objectives\n    cluster_size = max(3, n // 5)\n    clusters = []\n    remaining_nodes = set(range(n))\n\n    while remaining_nodes:\n        current_node = random.choice(list(remaining_nodes))\n        cluster = [current_node]\n        remaining_nodes.remove(current_node)\n\n        # Expand cluster based on proximity in both spaces\n        for _ in range(cluster_size - 1):\n            if not remaining_nodes:\n                break\n            nearest_node = min(remaining_nodes,\n                              key=lambda x: (distance_matrix_1[current_node, x] +\n                                           distance_matrix_2[current_node, x]))\n            cluster.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        clusters.append(cluster)\n\n    # Multi-objective edge inversion\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges within the cluster to invert\n        i, j = sorted(random.sample(range(len(cluster)), 2))\n        node_i = cluster[i]\n        node_j = cluster[j]\n\n        # Find positions in the tour\n        pos_i = np.where(new_solution == node_i)[0][0]\n        pos_j = np.where(new_solution == node_j)[0][0]\n\n        # Invert the segment between them\n        if pos_j - pos_i > 1:\n            new_solution[pos_i:pos_j+1] = new_solution[pos_i:pos_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8407273874759913,
            1.0411967635154724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objectives\n    cluster_size = max(3, n // 5)\n    clusters = []\n    remaining_nodes = set(range(n))\n\n    while remaining_nodes:\n        current_node = random.choice(list(remaining_nodes))\n        cluster = [current_node]\n        remaining_nodes.remove(current_node)\n\n        # Expand cluster based on proximity in both spaces\n        for _ in range(cluster_size - 1):\n            if not remaining_nodes:\n                break\n            nearest_node = min(remaining_nodes,\n                              key=lambda x: (distance_matrix_1[current_node, x] +\n                                           distance_matrix_2[current_node, x]))\n            cluster.append(nearest_node)\n            remaining_nodes.remove(nearest_node)\n            current_node = nearest_node\n\n        clusters.append(cluster)\n\n    # Multi-objective edge inversion\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select two edges within the cluster to invert\n        i, j = sorted(random.sample(range(len(cluster)), 2))\n        node_i = cluster[i]\n        node_j = cluster[j]\n\n        # Find positions in the tour\n        pos_i = np.where(new_solution == node_i)[0][0]\n        pos_j = np.where(new_solution == node_j)[0][0]\n\n        # Invert the segment between them\n        if pos_j - pos_i > 1:\n            new_solution[pos_i:pos_j+1] = new_solution[pos_i:pos_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{A novel hybrid local search strategy that combines dynamic path inversion with adaptive segment relocation to explore the solution space by selectively inverting segments and relocating them to different positions while maintaining feasibility and balancing the trade-off between both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 3))\n\n    # Dynamic path inversion\n    for _ in range(3):\n        i = random.randint(0, n - segment_size)\n        j = i + segment_size\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adaptive segment relocation\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8305073661077352,
            0.5143009424209595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 3))\n\n    # Dynamic path inversion\n    for _ in range(3):\n        i = random.randint(0, n - segment_size)\n        j = i + segment_size\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adaptive segment relocation\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path inversion with adaptive segment relocation, where a high-performing solution from the archive is modified by strategically inverting segments and relocating them to different positions while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path inversion with segment relocation\n    for _ in range(3):\n        # Select a random segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        inverted_segment = segment[::-1]\n\n        # Find best position to relocate the inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate inverted segment at position i\n            candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the inverted segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.905940066812946,
            6.100843369960785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path inversion with segment relocation\n    for _ in range(3):\n        # Select a random segment to invert\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n        inverted_segment = segment[::-1]\n\n        # Find best position to relocate the inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate inverted segment at position i\n            candidate = np.concatenate([new_solution[:i], inverted_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the inverted segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], inverted_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel multi-objective local search algorithm that combines adaptive segment reversal with probabilistic edge insertion, where a high-performing solution is modified by strategically reversing segments and inserting edges from a random solution while evaluating Pareto dominance and feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic edge insertion\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            if i != j and new_solution[i] != random_sol[j]:\n                new_solution[i], new_solution[j] = random_sol[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.771053401723746,
            0.3610948324203491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic edge insertion\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            if i != j and new_solution[i] != random_sol[j]:\n                new_solution[i], new_solution[j] = random_sol[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{An adaptive hybrid local search strategy that combines dynamic path inversion with biased segment relocation to explore high-quality solutions by intelligently inverting node sequences and relocating segments while considering both objective spaces to maintain balance in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic path inversion with objective-aware selection\n    for _ in range(3):\n        # Select a segment to invert based on distance improvement potential\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            segment = new_solution[i:j]\n            new_solution[i:j] = segment[::-1]\n\n    # Biased segment relocation considering both objectives\n    for _ in range(2):\n        # Select a segment to relocate\n        seg_size = max(2, min(5, n // 5))\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Find a new position with potential for improvement\n        new_pos = random.randint(0, n - seg_size)\n        while abs(new_pos - seg_start) < seg_size:\n            new_pos = random.randint(0, n - seg_size)\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:seg_start],\n            new_solution[seg_end:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8304275329103367,
            0.14405381679534912
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic path inversion with objective-aware selection\n    for _ in range(3):\n        # Select a segment to invert based on distance improvement potential\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            segment = new_solution[i:j]\n            new_solution[i:j] = segment[::-1]\n\n    # Biased segment relocation considering both objectives\n    for _ in range(2):\n        # Select a segment to relocate\n        seg_size = max(2, min(5, n // 5))\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Find a new position with potential for improvement\n        new_pos = random.randint(0, n - seg_size)\n        while abs(new_pos - seg_start) < seg_size:\n            new_pos = random.randint(0, n - seg_size)\n\n        # Insert the segment at the new position\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:seg_start],\n            new_solution[seg_end:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment relocation with probabilistic edge flipping to explore diverse solution regions by intelligently repositioning segments and selectively flipping edges based on their contribution to both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment relocation\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert at a new random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic edge flipping\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate improvement potential for both objectives\n            old_edges = [(new_solution[i], new_solution[i+1]), (new_solution[j], new_solution[j-1])]\n            new_edges = [(new_solution[i], new_solution[j]), (new_solution[i+1], new_solution[j-1])]\n\n            # Compute cost change\n            cost_change1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                          distance_matrix_1[old_edges[0]] - distance_matrix_1[old_edges[1]])\n            cost_change2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                          distance_matrix_2[old_edges[0]] - distance_matrix_2[old_edges[1]])\n\n            # Flip with probability based on improvement\n            if cost_change1 <= 0 or cost_change2 <= 0 or random.random() < 0.3:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7852410978975941,
            0.5180021524429321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment relocation\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert at a new random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic edge flipping\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate improvement potential for both objectives\n            old_edges = [(new_solution[i], new_solution[i+1]), (new_solution[j], new_solution[j-1])]\n            new_edges = [(new_solution[i], new_solution[j]), (new_solution[i+1], new_solution[j-1])]\n\n            # Compute cost change\n            cost_change1 = (distance_matrix_1[new_edges[0]] + distance_matrix_1[new_edges[1]] -\n                          distance_matrix_1[old_edges[0]] - distance_matrix_1[old_edges[1]])\n            cost_change2 = (distance_matrix_2[new_edges[0]] + distance_matrix_2[new_edges[1]] -\n                          distance_matrix_2[old_edges[0]] - distance_matrix_2[old_edges[1]])\n\n            # Flip with probability based on improvement\n            if cost_change1 <= 0 or cost_change2 <= 0 or random.random() < 0.3:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective edge selection with adaptive segment inversion to explore high-quality solutions by dynamically identifying critical edges based on both objective spaces and selectively inverting segments to balance the trade-off between objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    best_idx = combined_scores.index(min(combined_scores))\n    selected_sol = archive_solutions[best_idx]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective edge selection\n    for _ in range(3):\n        # Select edges with high potential for improvement in either objective\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate edge costs in both objectives\n        edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate potential new costs if we reverse the segment\n        new_edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if either objective improves\n        if (new_edge_cost1 < edge_cost1) or (new_edge_cost2 < edge_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        # Select segment size based on problem size and objective trade-off\n        segment_size = max(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n\n        # Calculate potential new costs if we reverse the segment\n        new_segment_cost1 = sum(distance_matrix_1[new_solution[i+1], new_solution[i]] for i in range(start, end-1))\n        new_segment_cost2 = sum(distance_matrix_2[new_solution[i+1], new_solution[i]] for i in range(start, end-1))\n\n        # Accept if either objective improves or if the trade-off is beneficial\n        if (new_segment_cost1 < segment_cost1) or (new_segment_cost2 < segment_cost2) or (random.random() < 0.3):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8623086588346678,
            0.5174254775047302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in objectives]\n    best_idx = combined_scores.index(min(combined_scores))\n    selected_sol = archive_solutions[best_idx]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective edge selection\n    for _ in range(3):\n        # Select edges with high potential for improvement in either objective\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n\n        # Calculate edge costs in both objectives\n        edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate potential new costs if we reverse the segment\n        new_edge_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_edge_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if either objective improves\n        if (new_edge_cost1 < edge_cost1) or (new_edge_cost2 < edge_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        # Select segment size based on problem size and objective trade-off\n        segment_size = max(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end-1))\n\n        # Calculate potential new costs if we reverse the segment\n        new_segment_cost1 = sum(distance_matrix_1[new_solution[i+1], new_solution[i]] for i in range(start, end-1))\n        new_segment_cost2 = sum(distance_matrix_2[new_solution[i+1], new_solution[i]] for i in range(start, end-1))\n\n        # Accept if either objective improves or if the trade-off is beneficial\n        if (new_segment_cost1 < segment_cost1) or (new_segment_cost2 < segment_cost2) or (random.random() < 0.3):\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions by intelligently rearranging nodes and reversing segments while maintaining feasibility and balancing improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node and remove it\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new position\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7883829164224045,
            0.4650886058807373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node and remove it\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new position\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with dynamic node reordering to explore high-quality solutions by intelligently inserting segments and reordering nodes while balancing improvement across both objectives and maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment and insert it at a new position\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic node reordering\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            # Reverse a random subsequence\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Swap two random nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.867548182865244,
            0.5409665107727051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment and insert it at a new position\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic node reordering\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            # Reverse a random subsequence\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Swap two random nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{An innovative hybrid local search strategy that combines multi-objective segment inversion with adaptive edge rebalancing to explore Pareto-optimal regions by dynamically adjusting tour segments based on their contribution to both objectives while maintaining solution feasibility and diversity through probabilistic segment selection and objective-aware edge adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential improvement\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol, _ = max(archive_solutions, key=lambda x: sum(x[1]))\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    for _ in range(3):\n        # Select segment based on both objectives\n        seg_size = random.randint(2, min(6, n//3))\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Calculate segment contribution to both objectives\n        seg_nodes = new_solution[seg_start:seg_end]\n        cost1 = sum(distance_matrix_1[seg_nodes[i-1], seg_nodes[i]] for i in range(1, len(seg_nodes)))\n        cost1 += distance_matrix_1[seg_nodes[-1], seg_nodes[0]]\n        cost2 = sum(distance_matrix_2[seg_nodes[i-1], seg_nodes[i]] for i in range(1, len(seg_nodes)))\n        cost2 += distance_matrix_2[seg_nodes[-1], seg_nodes[0]]\n\n        # Invert segment with probability based on objective balance\n        if random.random() < (cost1 / (cost1 + cost2 + 1e-6)):\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive edge rebalancing\n    for _ in range(4):\n        # Select edges based on both objectives\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate edge contributions\n        edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        new_edge1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_edge2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Swap nodes if both objectives improve\n        if (new_edge1 < edge1 and new_edge2 < edge2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8660806723059358,
            0.5340685248374939
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential improvement\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol, _ = max(archive_solutions, key=lambda x: sum(x[1]))\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Multi-objective segment inversion\n    for _ in range(3):\n        # Select segment based on both objectives\n        seg_size = random.randint(2, min(6, n//3))\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Calculate segment contribution to both objectives\n        seg_nodes = new_solution[seg_start:seg_end]\n        cost1 = sum(distance_matrix_1[seg_nodes[i-1], seg_nodes[i]] for i in range(1, len(seg_nodes)))\n        cost1 += distance_matrix_1[seg_nodes[-1], seg_nodes[0]]\n        cost2 = sum(distance_matrix_2[seg_nodes[i-1], seg_nodes[i]] for i in range(1, len(seg_nodes)))\n        cost2 += distance_matrix_2[seg_nodes[-1], seg_nodes[0]]\n\n        # Invert segment with probability based on objective balance\n        if random.random() < (cost1 / (cost1 + cost2 + 1e-6)):\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Adaptive edge rebalancing\n    for _ in range(4):\n        # Select edges based on both objectives\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n\n        # Calculate edge contributions\n        edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        new_edge1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_edge2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Swap nodes if both objectives improve\n        if (new_edge1 < edge1 and new_edge2 < edge2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel adaptive segment exchange strategy that selectively exchanges segments between a high-performing archive solution and a randomly generated solution, using a weighted cost function to balance both objectives and incorporating a probabilistic acceptance criterion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment exchange with weighted cost function\n    for _ in range(2):\n        # Select a segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate weighted cost (alpha balances objectives)\n            alpha = random.uniform(0.3, 0.7)\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            weighted_cost = alpha * cost1 + (1 - alpha) * cost2\n\n            # Probabilistic acceptance to escape local optima\n            if weighted_cost < best_cost or random.random() < 0.1:\n                best_cost = weighted_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8979390190708059,
            4.1886579394340515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment exchange with weighted cost function\n    for _ in range(2):\n        # Select a segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate weighted cost (alpha balances objectives)\n            alpha = random.uniform(0.3, 0.7)\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            weighted_cost = alpha * cost1 + (1 - alpha) * cost2\n\n            # Probabilistic acceptance to escape local optima\n            if weighted_cost < best_cost or random.random() < 0.1:\n                best_cost = weighted_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{This algorithm employs a novel hybrid local search strategy that combines adaptive node clustering with dynamic path reconfiguration, where it first partitions the tour into clusters based on spatial proximity in both objective spaces, then intelligently reconfigures paths between clusters while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    num_clusters = max(2, min(5, n // 5))\n\n    # Adaptive node clustering based on both objective spaces\n    cluster_centers = random.sample(range(n), num_clusters)\n    cluster_assignments = [0] * n\n\n    for i in range(n):\n        min_dist = float('inf')\n        best_cluster = 0\n        for j, center in enumerate(cluster_centers):\n            dist1 = distance_matrix_1[new_solution[i], new_solution[center]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[center]]\n            total_dist = dist1 + dist2\n            if total_dist < min_dist:\n                min_dist = total_dist\n                best_cluster = j\n        cluster_assignments[i] = best_cluster\n\n    # Dynamic path reconfiguration between clusters\n    for _ in range(3):\n        # Select two different clusters\n        cluster1, cluster2 = random.sample(range(num_clusters), 2)\n\n        # Find nodes in each cluster\n        nodes_in_cluster1 = [i for i in range(n) if cluster_assignments[i] == cluster1]\n        nodes_in_cluster2 = [i for i in range(n) if cluster_assignments[i] == cluster2]\n\n        if not nodes_in_cluster1 or not nodes_in_cluster2:\n            continue\n\n        # Select random nodes from each cluster\n        node1 = random.choice(nodes_in_cluster1)\n        node2 = random.choice(nodes_in_cluster2)\n\n        # Find positions of these nodes in the solution\n        pos1 = np.where(new_solution == new_solution[node1])[0][0]\n        pos2 = np.where(new_solution == new_solution[node2])[0][0]\n\n        # Swap the nodes if they are not adjacent\n        if abs(pos1 - pos2) > 1:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8663875747956638,
            0.7744341492652893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    num_clusters = max(2, min(5, n // 5))\n\n    # Adaptive node clustering based on both objective spaces\n    cluster_centers = random.sample(range(n), num_clusters)\n    cluster_assignments = [0] * n\n\n    for i in range(n):\n        min_dist = float('inf')\n        best_cluster = 0\n        for j, center in enumerate(cluster_centers):\n            dist1 = distance_matrix_1[new_solution[i], new_solution[center]]\n            dist2 = distance_matrix_2[new_solution[i], new_solution[center]]\n            total_dist = dist1 + dist2\n            if total_dist < min_dist:\n                min_dist = total_dist\n                best_cluster = j\n        cluster_assignments[i] = best_cluster\n\n    # Dynamic path reconfiguration between clusters\n    for _ in range(3):\n        # Select two different clusters\n        cluster1, cluster2 = random.sample(range(num_clusters), 2)\n\n        # Find nodes in each cluster\n        nodes_in_cluster1 = [i for i in range(n) if cluster_assignments[i] == cluster1]\n        nodes_in_cluster2 = [i for i in range(n) if cluster_assignments[i] == cluster2]\n\n        if not nodes_in_cluster1 or not nodes_in_cluster2:\n            continue\n\n        # Select random nodes from each cluster\n        node1 = random.choice(nodes_in_cluster1)\n        node2 = random.choice(nodes_in_cluster2)\n\n        # Find positions of these nodes in the solution\n        pos1 = np.where(new_solution == new_solution[node1])[0][0]\n        pos2 = np.where(new_solution == new_solution[node2])[0][0]\n\n        # Swap the nodes if they are not adjacent\n        if abs(pos1 - pos2) > 1:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{A novel adaptive segment inversion with multi-objective edge optimization strategy that dynamically balances segment inversions and edge swaps based on the relative improvement in both objective spaces to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Evaluate potential improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if both objectives improve or if one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 * 0.9 and new_cost2 < old_cost2 * 1.1) or \\\n               (new_cost1 < old_cost1 * 1.1 and new_cost2 < old_cost2 * 0.9):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8076841051939737,
            0.4454067349433899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Evaluate potential improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if both objectives improve or if one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 * 0.9 and new_cost2 < old_cost2 * 1.1) or \\\n               (new_cost1 < old_cost1 * 1.1 and new_cost2 < old_cost2 * 0.9):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive tour fragmentation with multi-objective edge insertion, where the solution is dynamically split into critical and non-critical segments based on their contribution to both objectives, followed by intelligent reinsertion of critical segments to balance improvements in both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate edge importance scores based on both objectives\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i]\n        curr = new_solution[(i+1)%n]\n        edge_scores[i] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n\n    # Identify critical segments (top 30% of edges)\n    critical_threshold = np.percentile(edge_scores, 70)\n    critical_edges = np.where(edge_scores > critical_threshold)[0]\n\n    if len(critical_edges) < 2:\n        return new_solution\n\n    # Split the tour into critical and non-critical parts\n    critical_segments = []\n    current_segment = []\n    in_critical = False\n\n    for i in range(n):\n        if i in critical_edges:\n            if not in_critical:\n                if current_segment:\n                    critical_segments.append(current_segment)\n                    current_segment = []\n                in_critical = True\n            current_segment.append(new_solution[i])\n        else:\n            if in_critical:\n                if current_segment:\n                    critical_segments.append(current_segment)\n                    current_segment = []\n                in_critical = False\n            current_segment.append(new_solution[i])\n\n    if current_segment:\n        critical_segments.append(current_segment)\n\n    # Reconstruct the tour by intelligently reinserting critical segments\n    if len(critical_segments) > 1:\n        # Remove all critical segments\n        non_critical_nodes = []\n        for i in range(n):\n            if i not in critical_edges:\n                non_critical_nodes.append(new_solution[i])\n\n        # Rebuild tour by alternating between non-critical and critical segments\n        new_tour = []\n        critical_index = 0\n        non_critical_index = 0\n\n        while non_critical_index < len(non_critical_nodes):\n            # Add non-critical nodes\n            if non_critical_index < len(non_critical_nodes):\n                new_tour.append(non_critical_nodes[non_critical_index])\n                non_critical_index += 1\n\n            # Add critical segments\n            if critical_index < len(critical_segments):\n                new_tour.extend(critical_segments[critical_index])\n                critical_index += 1\n\n        # Ensure all nodes are included\n        if len(new_tour) != n:\n            remaining = [node for node in new_solution if node not in new_tour]\n            new_tour.extend(remaining)\n\n        new_solution = np.array(new_tour)\n\n    # Additional local improvement with edge swaps\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9268242267124537,
            0.5137709975242615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate edge importance scores based on both objectives\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i]\n        curr = new_solution[(i+1)%n]\n        edge_scores[i] = distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr]\n\n    # Identify critical segments (top 30% of edges)\n    critical_threshold = np.percentile(edge_scores, 70)\n    critical_edges = np.where(edge_scores > critical_threshold)[0]\n\n    if len(critical_edges) < 2:\n        return new_solution\n\n    # Split the tour into critical and non-critical parts\n    critical_segments = []\n    current_segment = []\n    in_critical = False\n\n    for i in range(n):\n        if i in critical_edges:\n            if not in_critical:\n                if current_segment:\n                    critical_segments.append(current_segment)\n                    current_segment = []\n                in_critical = True\n            current_segment.append(new_solution[i])\n        else:\n            if in_critical:\n                if current_segment:\n                    critical_segments.append(current_segment)\n                    current_segment = []\n                in_critical = False\n            current_segment.append(new_solution[i])\n\n    if current_segment:\n        critical_segments.append(current_segment)\n\n    # Reconstruct the tour by intelligently reinserting critical segments\n    if len(critical_segments) > 1:\n        # Remove all critical segments\n        non_critical_nodes = []\n        for i in range(n):\n            if i not in critical_edges:\n                non_critical_nodes.append(new_solution[i])\n\n        # Rebuild tour by alternating between non-critical and critical segments\n        new_tour = []\n        critical_index = 0\n        non_critical_index = 0\n\n        while non_critical_index < len(non_critical_nodes):\n            # Add non-critical nodes\n            if non_critical_index < len(non_critical_nodes):\n                new_tour.append(non_critical_nodes[non_critical_index])\n                non_critical_index += 1\n\n            # Add critical segments\n            if critical_index < len(critical_segments):\n                new_tour.extend(critical_segments[critical_index])\n                critical_index += 1\n\n        # Ensure all nodes are included\n        if len(new_tour) != n:\n            remaining = [node for node in new_solution if node not in new_tour]\n            new_tour.extend(remaining)\n\n        new_solution = np.array(new_tour)\n\n    # Additional local improvement with edge swaps\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{The new algorithm combines multi-objective path decomposition with adaptive segment inversion, where it intelligently identifies critical segments based on both objective spaces and performs targeted inversions that balance improvement in both objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective potential\n    archive_solutions = [sol for sol, (cost1, cost2) in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Identify critical segments based on both objectives\n    critical_segments = []\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Add segment if it's potentially improvable\n        if (cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2)):\n            critical_segments.append((i, i+segment_size))\n\n    # Perform targeted inversions on critical segments\n    for start, end in critical_segments:\n        if random.random() < 0.7:  # 70% chance to invert\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Additional refinement with inter-segment swaps\n    if len(critical_segments) > 1:\n        seg1, seg2 = random.sample(critical_segments, 2)\n        s1_start, s1_end = seg1\n        s2_start, s2_end = seg2\n\n        # Ensure segments don't overlap\n        if s1_end <= s2_start or s2_end <= s1_start:\n            seg1_nodes = new_solution[s1_start:s1_end]\n            seg2_nodes = new_solution[s2_start:s2_end]\n\n            new_solution[s1_start:s1_end] = seg2_nodes\n            new_solution[s2_start:s2_end] = seg1_nodes\n\n    return new_solution\n\n",
        "score": [
            -0.8780858212321944,
            0.13089817762374878
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective potential\n    archive_solutions = [sol for sol, (cost1, cost2) in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Identify critical segments based on both objectives\n    critical_segments = []\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment costs in both objectives\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Add segment if it's potentially improvable\n        if (cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2)):\n            critical_segments.append((i, i+segment_size))\n\n    # Perform targeted inversions on critical segments\n    for start, end in critical_segments:\n        if random.random() < 0.7:  # 70% chance to invert\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Additional refinement with inter-segment swaps\n    if len(critical_segments) > 1:\n        seg1, seg2 = random.sample(critical_segments, 2)\n        s1_start, s1_end = seg1\n        s2_start, s2_end = seg2\n\n        # Ensure segments don't overlap\n        if s1_end <= s2_start or s2_end <= s1_start:\n            seg1_nodes = new_solution[s1_start:s1_end]\n            seg2_nodes = new_solution[s2_start:s2_end]\n\n            new_solution[s1_start:s1_end] = seg2_nodes\n            new_solution[s2_start:s2_end] = seg1_nodes\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{An innovative hybrid local search strategy that combines multi-objective segment reshaping with adaptive node swapping, where high-performing segments from the archive are dynamically reshaped and recombined with strategically swapped nodes from a random solution, while evaluating the impact on both objectives and ensuring feasibility through careful node replacement and segment validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment reshaping\n    for _ in range(2):\n        # Select a segment from archive solution\n        seg_start = random.randint(0, n - 3)\n        seg_end = seg_start + random.randint(2, min(5, n - seg_start - 1))\n        segment = new_solution[seg_start:seg_end]\n\n        # Find corresponding nodes in random solution\n        random_nodes = [node for node in random_sol if node not in segment]\n\n        # Replace segment nodes with random nodes\n        if len(random_nodes) >= len(segment):\n            new_nodes = random.sample(random_nodes, len(segment))\n            new_solution[seg_start:seg_end] = new_nodes\n\n    # Adaptive node swapping\n    for _ in range(3):\n        # Select two nodes to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Evaluate potential swap\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept swap if it improves at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9510513260697524,
            0.6828076839447021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment reshaping\n    for _ in range(2):\n        # Select a segment from archive solution\n        seg_start = random.randint(0, n - 3)\n        seg_end = seg_start + random.randint(2, min(5, n - seg_start - 1))\n        segment = new_solution[seg_start:seg_end]\n\n        # Find corresponding nodes in random solution\n        random_nodes = [node for node in random_sol if node not in segment]\n\n        # Replace segment nodes with random nodes\n        if len(random_nodes) >= len(segment):\n            new_nodes = random.sample(random_nodes, len(segment))\n            new_solution[seg_start:seg_end] = new_nodes\n\n    # Adaptive node swapping\n    for _ in range(3):\n        # Select two nodes to swap\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Evaluate potential swap\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept swap if it improves at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions by intelligently inserting nodes and reversing segments while maintaining feasibility and balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8907474219633051,
            0.5001479387283325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment rearrangement with dynamic edge optimization to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):  # Perform multiple rearrangements\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Rearrange the segments by rotating\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        rotated_seg1 = np.roll(seg1, random.randint(1, segment_size - 1))\n        rotated_seg2 = np.roll(seg2, random.randint(1, segment_size - 1))\n\n        new_solution[seg1_start:seg1_end] = rotated_seg1\n        new_solution[seg2_start:seg2_end] = rotated_seg2\n\n    # Dynamic edge optimization\n    for _ in range(4):  # Perform multiple edge optimizations\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the optimization maintains feasibility\n        if (j - i) > 2:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            # Additional rotation for further optimization\n            new_solution[i:j] = np.roll(new_solution[i:j], random.randint(1, (j - i) - 1))\n\n    return new_solution\n\n",
        "score": [
            -0.8051481322985498,
            0.5294699668884277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):  # Perform multiple rearrangements\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Rearrange the segments by rotating\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        rotated_seg1 = np.roll(seg1, random.randint(1, segment_size - 1))\n        rotated_seg2 = np.roll(seg2, random.randint(1, segment_size - 1))\n\n        new_solution[seg1_start:seg1_end] = rotated_seg1\n        new_solution[seg2_start:seg2_end] = rotated_seg2\n\n    # Dynamic edge optimization\n    for _ in range(4):  # Perform multiple edge optimizations\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the optimization maintains feasibility\n        if (j - i) > 2:\n            new_solution[i:j] = new_solution[i:j][::-1]\n            # Additional rotation for further optimization\n            new_solution[i:j] = np.roll(new_solution[i:j], random.randint(1, (j - i) - 1))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{A novel local search strategy that combines multi-objective edge flipping with adaptive tour partitioning to generate high-quality neighbors by intelligently selecting and rearranging sub-tours while balancing improvements in both objective spaces through a weighted selection process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive tour partitioning\n    partition_points = sorted(random.sample(range(1, n), k=min(3, n-1)))\n    partitions = []\n    start = 0\n    for point in partition_points:\n        partitions.append(new_solution[start:point])\n        start = point\n    partitions.append(new_solution[start:])\n\n    # Shuffle partitions with probability based on their length\n    for i in range(len(partitions)-1):\n        if random.random() < 0.3 * (len(partitions[i]) / n):\n            partitions[i], partitions[i+1] = partitions[i+1], partitions[i]\n\n    # Reconstruct solution from shuffled partitions\n    new_solution = np.concatenate(partitions)\n\n    # Multi-objective edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate weighted improvement potential\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7702369939990645,
            0.6314771175384521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive tour partitioning\n    partition_points = sorted(random.sample(range(1, n), k=min(3, n-1)))\n    partitions = []\n    start = 0\n    for point in partition_points:\n        partitions.append(new_solution[start:point])\n        start = point\n    partitions.append(new_solution[start:])\n\n    # Shuffle partitions with probability based on their length\n    for i in range(len(partitions)-1):\n        if random.random() < 0.3 * (len(partitions[i]) / n):\n            partitions[i], partitions[i+1] = partitions[i+1], partitions[i]\n\n    # Reconstruct solution from shuffled partitions\n    new_solution = np.concatenate(partitions)\n\n    # Multi-objective edge flipping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate weighted improvement potential\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < old_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive segment reversal, where a high-performing solution from the archive is combined with a random solution by strategically reversing segments from the archive solution and inserting them into the random solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with segment reversal\n    for _ in range(3):\n        # Select a random segment from archive solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Find best insertion point in random solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            # Insert reversed segment at position i\n            candidate = np.concatenate([random_sol[:i], reversed_segment, random_sol[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best reversed segment\n        if best_pos != 0:\n            random_sol = np.concatenate([random_sol[:best_pos], reversed_segment, random_sol[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(random_sol)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if random_sol[i] in unique_nodes:\n                continue\n            random_sol[i] = missing_nodes.pop(0)\n\n    return random_sol\n\n",
        "score": [
            -0.8991801947303362,
            5.764580488204956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with segment reversal\n    for _ in range(3):\n        # Select a random segment from archive solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Reverse the segment\n        reversed_segment = segment[::-1]\n\n        # Find best insertion point in random solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            # Insert reversed segment at position i\n            candidate = np.concatenate([random_sol[:i], reversed_segment, random_sol[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best reversed segment\n        if best_pos != 0:\n            random_sol = np.concatenate([random_sol[:best_pos], reversed_segment, random_sol[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(random_sol)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if random_sol[i] in unique_nodes:\n                continue\n            random_sol[i] = missing_nodes.pop(0)\n\n    return random_sol\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive node insertion, where it identifies critical path segments from high-performing solutions and intelligently inserts nodes from random solutions while evaluating the trade-off between both objectives and ensuring feasibility through dynamic feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive insertion\n    for _ in range(2):\n        # Select a critical path segment from the archive solution\n        seg_start = random.randint(0, n - 4)\n        seg_end = seg_start + random.randint(2, min(4, n - seg_start))\n        segment = new_solution[seg_start:seg_end]\n\n        # Find best insertion point in random solution\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Create candidate solution\n            candidate = np.concatenate([random_sol[:i], segment, random_sol[i:]])\n\n            # Ensure feasibility\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate multi-objective score\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n\n            # Trade-off evaluation (can be adjusted)\n            score = 0.7 * cost1 + 0.3 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != seg_start:\n            random_sol = np.concatenate([random_sol[:best_pos], segment, random_sol[best_pos:]])\n\n    # Adaptive node insertion for further refinement\n    for _ in range(3):\n        # Select a node from random solution\n        node_pos = random.randint(0, n - 1)\n        node = random_sol[node_pos]\n\n        # Find best insertion position in new solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            if i == node_pos:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n            # Ensure feasibility\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at best position\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Final feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7667188758777519,
            14.834917604923248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive insertion\n    for _ in range(2):\n        # Select a critical path segment from the archive solution\n        seg_start = random.randint(0, n - 4)\n        seg_end = seg_start + random.randint(2, min(4, n - seg_start))\n        segment = new_solution[seg_start:seg_end]\n\n        # Find best insertion point in random solution\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Create candidate solution\n            candidate = np.concatenate([random_sol[:i], segment, random_sol[i:]])\n\n            # Ensure feasibility\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate multi-objective score\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n\n            # Trade-off evaluation (can be adjusted)\n            score = 0.7 * cost1 + 0.3 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != seg_start:\n            random_sol = np.concatenate([random_sol[:best_pos], segment, random_sol[best_pos:]])\n\n    # Adaptive node insertion for further refinement\n    for _ in range(3):\n        # Select a node from random solution\n        node_pos = random.randint(0, n - 1)\n        node = random_sol[node_pos]\n\n        # Find best insertion position in new solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            if i == node_pos:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n            # Ensure feasibility\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at best position\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Final feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel adaptive multi-segment crossover strategy that intelligently combines multiple high-performing segments from diverse archive solutions, while dynamically balancing the trade-off between objective improvements and solution feasibility through probabilistic segment selection and adaptive repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% solutions from the archive based on combined objective scores\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_solutions = [sol for sol, _ in sorted_archive[:max(1, len(archive) // 3)]]\n\n    # Select two distinct solutions from top performers\n    selected_sols = random.sample(top_solutions, min(2, len(top_solutions)))\n    base_sol = selected_sols[0].copy()\n    donor_sol = selected_sols[-1].copy()\n\n    n = len(base_sol)\n    new_solution = base_sol.copy()\n\n    # Adaptive multi-segment crossover\n    for _ in range(2):\n        # Select multiple random segments from donor solution\n        segment_lengths = random.sample(range(2, min(5, n//2)), 2)\n        segments = []\n        for length in segment_lengths:\n            start = random.randint(0, n - length)\n            segments.append(donor_sol[start:start+length])\n\n        # Evaluate and insert segments with probability based on their potential improvement\n        for segment in segments:\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n - len(segment) + 1):\n                candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n                if len(np.unique(candidate)) != n:\n                    continue\n\n                cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                total_cost = cost1 + cost2\n\n                # Probabilistic acceptance based on improvement potential\n                if total_cost < best_score or random.random() < 0.3:\n                    best_score = total_cost\n                    best_pos = i\n\n            if best_pos != 0:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            # Prefer nodes that are close in both objectives\n            candidate = min(missing_nodes, key=lambda x: distance_matrix_1[new_solution[i-1], x] + distance_matrix_2[new_solution[i-1], x])\n            new_solution[i] = candidate\n            missing_nodes.remove(candidate)\n\n    return new_solution\n\n",
        "score": [
            -0.8808872252376979,
            11.406338036060333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% solutions from the archive based on combined objective scores\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_solutions = [sol for sol, _ in sorted_archive[:max(1, len(archive) // 3)]]\n\n    # Select two distinct solutions from top performers\n    selected_sols = random.sample(top_solutions, min(2, len(top_solutions)))\n    base_sol = selected_sols[0].copy()\n    donor_sol = selected_sols[-1].copy()\n\n    n = len(base_sol)\n    new_solution = base_sol.copy()\n\n    # Adaptive multi-segment crossover\n    for _ in range(2):\n        # Select multiple random segments from donor solution\n        segment_lengths = random.sample(range(2, min(5, n//2)), 2)\n        segments = []\n        for length in segment_lengths:\n            start = random.randint(0, n - length)\n            segments.append(donor_sol[start:start+length])\n\n        # Evaluate and insert segments with probability based on their potential improvement\n        for segment in segments:\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n - len(segment) + 1):\n                candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n                if len(np.unique(candidate)) != n:\n                    continue\n\n                cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                total_cost = cost1 + cost2\n\n                # Probabilistic acceptance based on improvement potential\n                if total_cost < best_score or random.random() < 0.3:\n                    best_score = total_cost\n                    best_pos = i\n\n            if best_pos != 0:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            # Prefer nodes that are close in both objectives\n            candidate = min(missing_nodes, key=lambda x: distance_matrix_1[new_solution[i-1], x] + distance_matrix_2[new_solution[i-1], x])\n            new_solution[i] = candidate\n            missing_nodes.remove(candidate)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0315927370617872,
            4.081437826156616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0315927370617872,
            4.081437826156616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{An innovative hybrid local search strategy that combines multi-objective path decomposition with adaptive segment reconfiguration, where a high-performing solution from the archive is systematically broken down into critical path segments, and these segments are intelligently reconfigured and reassembled to explore diverse high-quality solutions while maintaining feasibility and balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Path decomposition: identify critical segments based on both objectives\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate cost for current and previous segment\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        total_cost = cost1 + cost2\n\n        # Calculate cost if we were to break here\n        if i < n - 1:\n            break_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            break_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            break_cost = break_cost1 + break_cost2\n        else:\n            break_cost = float('inf')\n\n        # Decide whether to continue current segment or start new one\n        if total_cost > break_cost * 1.2:  # Threshold for segment break\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    segments.append(current_segment)\n\n    # Adaptive segment reconfiguration\n    if len(segments) > 1:\n        # Randomly select two segments to reconfigure\n        seg1_idx, seg2_idx = random.sample(range(len(segments)), 2)\n        seg1 = segments[seg1_idx]\n        seg2 = segments[seg2_idx]\n\n        # Create new segments by combining parts\n        if len(seg1) > 1 and len(seg2) > 1:\n            # Split segments at random points\n            split1 = random.randint(1, len(seg1)-1)\n            split2 = random.randint(1, len(seg2)-1)\n\n            # Create new segments\n            new_seg1 = seg1[:split1] + seg2[split2:]\n            new_seg2 = seg2[:split2] + seg1[split1:]\n\n            # Update segments\n            segments[seg1_idx] = new_seg1\n            segments[seg2_idx] = new_seg2\n\n    # Reconstruct solution from segments\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8522867624153229,
            0.6379613280296326
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Path decomposition: identify critical segments based on both objectives\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate cost for current and previous segment\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        total_cost = cost1 + cost2\n\n        # Calculate cost if we were to break here\n        if i < n - 1:\n            break_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n            break_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n            break_cost = break_cost1 + break_cost2\n        else:\n            break_cost = float('inf')\n\n        # Decide whether to continue current segment or start new one\n        if total_cost > break_cost * 1.2:  # Threshold for segment break\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    segments.append(current_segment)\n\n    # Adaptive segment reconfiguration\n    if len(segments) > 1:\n        # Randomly select two segments to reconfigure\n        seg1_idx, seg2_idx = random.sample(range(len(segments)), 2)\n        seg1 = segments[seg1_idx]\n        seg2 = segments[seg2_idx]\n\n        # Create new segments by combining parts\n        if len(seg1) > 1 and len(seg2) > 1:\n            # Split segments at random points\n            split1 = random.randint(1, len(seg1)-1)\n            split2 = random.randint(1, len(seg2)-1)\n\n            # Create new segments\n            new_seg1 = seg1[:split1] + seg2[split2:]\n            new_seg2 = seg2[:split2] + seg1[split1:]\n\n            # Update segments\n            segments[seg1_idx] = new_seg1\n            segments[seg2_idx] = new_seg2\n\n    # Reconstruct solution from segments\n    new_solution = []\n    for seg in segments:\n        new_solution.extend(seg)\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{An innovative hybrid local search strategy that combines adaptive node reinsertion with dynamic segment rotation, where high-performing solutions are transformed by strategically reinserting nodes and rotating segments to simultaneously improve both objectives while maintaining feasibility and preserving structural diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Insert the node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Dynamic segment rotation\n    for _ in range(2):\n        # Select a random segment\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, n-1)\n        segment = new_solution[seg_start:seg_end]\n\n        # Rotate the segment\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n        # Apply the rotation\n        new_solution[seg_start:seg_end] = rotated_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8972638848398952,
            8.014725685119629
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Insert the node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Dynamic segment rotation\n    for _ in range(2):\n        # Select a random segment\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, n-1)\n        segment = new_solution[seg_start:seg_end]\n\n        # Rotate the segment\n        rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n\n        # Apply the rotation\n        new_solution[seg_start:seg_end] = rotated_segment\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel adaptive segment inversion with dynamic edge reversal strategy that intelligently selects and inverts alternating segments of the tour while strategically reversing edges in critical regions to balance exploration of both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    archive_solutions = [sol for sol, (obj1, obj2) in archive]\n    selected_sol = archive_solutions[np.argmax([obj1 + obj2 for _, (obj1, obj2) in archive])]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n\n    # Alternating segment inversion\n    for i in range(0, n, segment_size * 2):\n        start = i\n        end = min(i + segment_size, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic edge reversal in critical regions\n    for _ in range(3):\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 1, min(i + 2, n - 1))\n        if random.random() < 0.7:  # Higher chance for small reversals\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9559954227284462,
            0.5156056880950928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement potential\n    archive_solutions = [sol for sol, (obj1, obj2) in archive]\n    selected_sol = archive_solutions[np.argmax([obj1 + obj2 for _, (obj1, obj2) in archive])]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, n // 5)\n\n    # Alternating segment inversion\n    for i in range(0, n, segment_size * 2):\n        start = i\n        end = min(i + segment_size, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic edge reversal in critical regions\n    for _ in range(3):\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 1, min(i + 2, n - 1))\n        if random.random() < 0.7:  # Higher chance for small reversals\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{A novel adaptive segment rearrangement strategy that combines multi-objective path swapping with dynamic segment rotation, where a high-performing solution from the archive is modified by strategically rotating and rearranging segments while evaluating the impact on both objectives and ensuring feasibility through adaptive segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment rotation and rearrangement\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Rotate the segment\n        rotation = random.randint(0, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(rotated_segment)):\n            # Insert rotated segment at position i\n            candidate = np.concatenate([new_solution[:i], rotated_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best rotated segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], rotated_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9265505890292742,
            6.336004197597504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment rotation and rearrangement\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Rotate the segment\n        rotation = random.randint(0, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(rotated_segment)):\n            # Insert rotated segment at position i\n            candidate = np.concatenate([new_solution[:i], rotated_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best rotated segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], rotated_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive node swapping, where a high-performing solution from the archive is combined with a random solution by strategically relinking paths between nodes while adaptively swapping nodes based on their relative contributions to both objectives, ensuring feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for _ in range(3):\n        # Select a random node from random solution\n        node_pos = random.randint(0, n-1)\n        node = random_sol[node_pos]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best node\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Adaptive node swapping based on objective contributions\n    for _ in range(2):\n        # Calculate node contributions to each objective\n        contributions = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate contribution to each objective\n            contrib1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            contrib2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n            contributions.append((i, contrib1, contrib2))\n\n        # Sort nodes by their contribution to the less improved objective\n        contributions.sort(key=lambda x: x[1] - x[2])\n\n        # Select nodes to swap (from both ends of the sorted list)\n        swap_pos1 = contributions[0][0]\n        swap_pos2 = contributions[-1][0]\n\n        # Perform swap\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8884714860787375,
            9.431607186794281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking\n    for _ in range(3):\n        # Select a random node from random solution\n        node_pos = random.randint(0, n-1)\n        node = random_sol[node_pos]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best node\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Adaptive node swapping based on objective contributions\n    for _ in range(2):\n        # Calculate node contributions to each objective\n        contributions = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate contribution to each objective\n            contrib1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            contrib2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n\n            contributions.append((i, contrib1, contrib2))\n\n        # Sort nodes by their contribution to the less improved objective\n        contributions.sort(key=lambda x: x[1] - x[2])\n\n        # Select nodes to swap (from both ends of the sorted list)\n        swap_pos1 = contributions[0][0]\n        swap_pos2 = contributions[-1][0]\n\n        # Perform swap\n        new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{An adaptive local search strategy that combines guided segment inversion with multi-objective edge optimization to explore high-quality solutions by dynamically balancing segment rearrangement and edge-based refinement while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Guided segment inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment with a probability based on its potential improvement\n        if random.random() < 0.7:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept the swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9222371632139338,
            0.5833587646484375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Guided segment inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment with a probability based on its potential improvement\n        if random.random() < 0.7:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvement in both objectives\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept the swap if it improves at least one objective\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route partitioning with dynamic node insertion to explore high-quality solutions by intelligently partitioning the tour into segments, inserting nodes from one segment into another while preserving feasibility, and dynamically adjusting the insertion points based on the relative improvement in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    partition_size = max(2, min(5, n // 3))\n\n    # Adaptive route partitioning\n    for _ in range(2):\n        # Select two non-overlapping partitions\n        part1_start = random.randint(0, n - partition_size)\n        part1_end = part1_start + partition_size\n\n        part2_start = random.randint(0, n - partition_size)\n        part2_end = part2_start + partition_size\n\n        # Ensure partitions don't overlap\n        while (part1_start < part2_end and part1_end > part2_start):\n            part2_start = random.randint(0, n - partition_size)\n            part2_end = part2_start + partition_size\n\n        # Extract partitions\n        part1 = new_solution[part1_start:part1_end]\n        part2 = new_solution[part2_start:part2_end]\n\n        # Dynamic node insertion\n        for node in part1:\n            if node not in part2:\n                insert_pos = random.randint(part2_start, part2_end - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n                new_solution = np.delete(new_solution, part1_start)\n\n    # Dynamic adjustment based on objective improvements\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Calculate potential improvement in both objectives\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Revert if no improvement in either objective\n            if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8174350116598021,
            0.34406858682632446
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    partition_size = max(2, min(5, n // 3))\n\n    # Adaptive route partitioning\n    for _ in range(2):\n        # Select two non-overlapping partitions\n        part1_start = random.randint(0, n - partition_size)\n        part1_end = part1_start + partition_size\n\n        part2_start = random.randint(0, n - partition_size)\n        part2_end = part2_start + partition_size\n\n        # Ensure partitions don't overlap\n        while (part1_start < part2_end and part1_end > part2_start):\n            part2_start = random.randint(0, n - partition_size)\n            part2_end = part2_start + partition_size\n\n        # Extract partitions\n        part1 = new_solution[part1_start:part1_end]\n        part2 = new_solution[part2_start:part2_end]\n\n        # Dynamic node insertion\n        for node in part1:\n            if node not in part2:\n                insert_pos = random.randint(part2_start, part2_end - 1)\n                new_solution = np.insert(new_solution, insert_pos, node)\n                new_solution = np.delete(new_solution, part1_start)\n\n    # Dynamic adjustment based on objective improvements\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Calculate potential improvement in both objectives\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            # Revert if no improvement in either objective\n            if (new_cost1 >= original_cost1) and (new_cost2 >= original_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment reversal, where a high-performing solution from the archive is combined with a random solution by strategically reversing segments from the random solution and inserting them into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment reversal and insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n        reversed_segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            # Insert reversed segment at position i\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8880873592487674,
            6.0142881870269775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment reversal and insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n        reversed_segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            # Insert reversed segment at position i\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path decomposition with multi-objective edge insertion, where the solution is decomposed into critical and non-critical paths, then strategically inserts high-impact edges from the decomposed paths into the original solution while balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Decompose the tour into critical and non-critical paths\n    critical_edges = set()\n    for i in range(n):\n        node1 = new_solution[i]\n        node2 = new_solution[(i + 1) % n]\n        # Identify edges that are among the top 20% in either objective\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        if cost1 > np.percentile(distance_matrix_1, 80) or cost2 > np.percentile(distance_matrix_2, 80):\n            critical_edges.add((node1, node2))\n\n    # Create a set of all nodes in critical edges\n    critical_nodes = set()\n    for edge in critical_edges:\n        critical_nodes.update(edge)\n\n    # Adaptive path decomposition: split the tour at critical nodes\n    segments = []\n    current_segment = []\n    for i in range(n):\n        node = new_solution[i]\n        current_segment.append(node)\n        if node in critical_nodes:\n            segments.append(current_segment)\n            current_segment = []\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Reconstruct the solution by strategically inserting critical edges\n    if len(segments) > 1:\n        # Select a random segment to insert\n        insert_pos = random.randint(0, len(segments) - 1)\n        segment_to_insert = segments.pop(insert_pos)\n\n        # Find the best position to insert the segment\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment_to_insert)):\n            candidate = np.concatenate([new_solution[:i], segment_to_insert, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment_to_insert, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.910804943808438,
            13.319870412349701
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Decompose the tour into critical and non-critical paths\n    critical_edges = set()\n    for i in range(n):\n        node1 = new_solution[i]\n        node2 = new_solution[(i + 1) % n]\n        # Identify edges that are among the top 20% in either objective\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        if cost1 > np.percentile(distance_matrix_1, 80) or cost2 > np.percentile(distance_matrix_2, 80):\n            critical_edges.add((node1, node2))\n\n    # Create a set of all nodes in critical edges\n    critical_nodes = set()\n    for edge in critical_edges:\n        critical_nodes.update(edge)\n\n    # Adaptive path decomposition: split the tour at critical nodes\n    segments = []\n    current_segment = []\n    for i in range(n):\n        node = new_solution[i]\n        current_segment.append(node)\n        if node in critical_nodes:\n            segments.append(current_segment)\n            current_segment = []\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Reconstruct the solution by strategically inserting critical edges\n    if len(segments) > 1:\n        # Select a random segment to insert\n        insert_pos = random.randint(0, len(segments) - 1)\n        segment_to_insert = segments.pop(insert_pos)\n\n        # Find the best position to insert the segment\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment_to_insert)):\n            candidate = np.concatenate([new_solution[:i], segment_to_insert, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment_to_insert, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive node swapping, where a high-performing solution from the archive is combined with a random solution by strategically replacing nodes based on their dominance in both objective spaces, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive node swapping\n    for _ in range(3):\n        # Select a random node from random solution\n        node_idx = random.randint(0, n-1)\n        node = random_sol[node_idx]\n\n        # Find best position to insert the node in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Try inserting the node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best node\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9099067585662493,
            8.82309901714325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive node swapping\n    for _ in range(3):\n        # Select a random node from random solution\n        node_idx = random.randint(0, n-1)\n        node = random_sol[node_idx]\n\n        # Find best position to insert the node in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Try inserting the node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best node\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This novel local search strategy combines multi-objective segment rotation with adaptive segment merging, where a high-performing solution from the archive is modified by rotating segments in a circular fashion and merging non-overlapping segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    segment_size = max(2, min(5, n // 3))\n    rotation_steps = random.randint(1, 3)\n\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        rotated_segment = np.roll(segment, rotation_steps)\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], rotated_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], rotated_segment, new_solution[best_pos:]])\n\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        if a < c < b < d:\n            segment1 = new_solution[a:b]\n            segment2 = random_sol[c:d]\n\n            merged_segment = np.concatenate([segment1, segment2])\n            if len(np.unique(merged_segment)) == len(merged_segment):\n                candidate = np.concatenate([new_solution[:a], merged_segment, new_solution[b:]])\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8827085901992189,
            3.860006630420685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    segment_size = max(2, min(5, n // 3))\n    rotation_steps = random.randint(1, 3)\n\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        rotated_segment = np.roll(segment, rotation_steps)\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], rotated_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], rotated_segment, new_solution[best_pos:]])\n\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n\n        if a < c < b < d:\n            segment1 = new_solution[a:b]\n            segment2 = random_sol[c:d]\n\n            merged_segment = np.concatenate([segment1, segment2])\n            if len(np.unique(merged_segment)) == len(merged_segment):\n                candidate = np.concatenate([new_solution[:a], merged_segment, new_solution[b:]])\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive node reinsertion, where a high-performing solution from the archive is combined with a random solution by strategically reinserting nodes from the random solution into the archive solution's structure while evaluating the impact on both objectives and ensuring feasibility through dynamic feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node from random solution\n        node = random.choice(random_sol)\n\n        # Find best insertion position in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best node\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Dynamic feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7938392751161732,
            8.775086522102356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path relinking with adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node from random solution\n        node = random.choice(random_sol)\n\n        # Find best insertion position in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.concatenate([new_solution[:i], [node], new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best node\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Dynamic feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{An innovative hybrid local search strategy that combines adaptive sub-tour inversion with multi-objective edge reassignment to explore diverse solution spaces by dynamically balancing segment flips and edge swaps while maintaining feasibility and optimizing both objectives through guided probabilistic selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (biased towards better solutions)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    if len(solutions) > 1:\n        # Select top 30% solutions by combined objective value\n        sorted_idx = np.argsort([sum(obj) for obj in objectives])\n        selected_sol = random.choice([solutions[i] for i in sorted_idx[-max(1, len(solutions)//3):]])\n    else:\n        selected_sol = solutions[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive sub-tour inversion with dynamic segment size\n    segment_size = max(2, min(7, n // 3))\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge reassignment\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate potential improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6009305519594574,
            0.49733877182006836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (biased towards better solutions)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    if len(solutions) > 1:\n        # Select top 30% solutions by combined objective value\n        sorted_idx = np.argsort([sum(obj) for obj in objectives])\n        selected_sol = random.choice([solutions[i] for i in sorted_idx[-max(1, len(solutions)//3):]])\n    else:\n        selected_sol = solutions[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive sub-tour inversion with dynamic segment size\n    segment_size = max(2, min(7, n // 3))\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge reassignment\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Calculate potential improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions by intelligently reversing segments of the tour and inserting nodes at optimal positions while maintaining feasibility and balancing improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        if node != new_solution[pos]:\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.7983677365798731,
            0.48426997661590576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        if node != new_solution[pos]:\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{This algorithm enhances the hybrid local search by incorporating adaptive segment selection based on multi-objective dominance, followed by dynamic segment inversion and insertion with a novel dominance-aware cost evaluation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random solution from the archive\n    random_sol = random.choice([sol for sol, _ in archive])\n\n    # Adaptive segment selection based on multi-objective dominance\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Dynamic segment inversion based on objective dominance\n        if random.random() < 0.7:  # Higher inversion probability\n            segment = segment[::-1]\n\n        # Find best insertion point using dominance-aware cost\n        best_pos = 0\n        best_dominance = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate dominance-aware cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            dominance = max(cost1, cost2)  # Simple dominance metric\n\n            if dominance < best_dominance:\n                best_dominance = dominance\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8998330041253987,
            3.8482460975646973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random solution from the archive\n    random_sol = random.choice([sol for sol, _ in archive])\n\n    # Adaptive segment selection based on multi-objective dominance\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Dynamic segment inversion based on objective dominance\n        if random.random() < 0.7:  # Higher inversion probability\n            segment = segment[::-1]\n\n        # Find best insertion point using dominance-aware cost\n        best_pos = 0\n        best_dominance = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate dominance-aware cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            dominance = max(cost1, cost2)  # Simple dominance metric\n\n            if dominance < best_dominance:\n                best_dominance = dominance\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path fragmentation with adaptive node redistribution, where a high-performing solution from the archive is modified by strategically breaking and recombining segments based on their contribution to both objectives, while redistributing nodes to balance the tour's cost across objectives and ensuring feasibility through a dynamic node swapping mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Calculate edge contributions to both objectives\n    edge_contributions = []\n    for i in range(n):\n        node1 = new_solution[i]\n        node2 = new_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        edge_contributions.append((cost1, cost2))\n\n    # Identify edges with high contribution to either objective\n    threshold1 = np.percentile([c[0] for c in edge_contributions], 75)\n    threshold2 = np.percentile([c[1] for c in edge_contributions], 75)\n\n    # Fragment the tour at edges with high contribution\n    break_points = []\n    for i in range(n):\n        if edge_contributions[i][0] > threshold1 or edge_contributions[i][1] > threshold2:\n            break_points.append(i)\n\n    if not break_points:\n        # If no edges meet threshold, randomly select break points\n        break_points = random.sample(range(n), min(3, n // 2))\n\n    # Sort break points and ensure they are unique\n    break_points = sorted(list(set(break_points)))\n    segments = []\n\n    # Extract segments between break points\n    for i in range(len(break_points)):\n        start = break_points[i]\n        end = break_points[(i + 1) % len(break_points)]\n        if start < end:\n            segments.append(new_solution[start:end])\n        else:\n            segments.append(np.concatenate([new_solution[start:], new_solution[:end]]))\n\n    # Shuffle segments to create new order\n    random.shuffle(segments)\n\n    # Reconstruct the tour from shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive node redistribution to balance objectives\n    for _ in range(2):\n        # Select nodes to swap based on their position in both objectives\n        node1, node2 = random.sample(range(n), 2)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n\n        # Calculate cost change if nodes are swapped\n        prev1 = new_solution[pos1 - 1]\n        next1 = new_solution[(pos1 + 1) % n]\n        prev2 = new_solution[pos2 - 1]\n        next2 = new_solution[(pos2 + 1) % n]\n\n        old_cost1 = distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] + distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2]\n        old_cost2 = distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] + distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2]\n\n        new_cost1 = distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] + distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2]\n        new_cost2 = distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] + distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2]\n\n        # Accept swap if it improves both objectives\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n",
        "score": [
            -0.813113803403523,
            0.7069998383522034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Calculate edge contributions to both objectives\n    edge_contributions = []\n    for i in range(n):\n        node1 = new_solution[i]\n        node2 = new_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        edge_contributions.append((cost1, cost2))\n\n    # Identify edges with high contribution to either objective\n    threshold1 = np.percentile([c[0] for c in edge_contributions], 75)\n    threshold2 = np.percentile([c[1] for c in edge_contributions], 75)\n\n    # Fragment the tour at edges with high contribution\n    break_points = []\n    for i in range(n):\n        if edge_contributions[i][0] > threshold1 or edge_contributions[i][1] > threshold2:\n            break_points.append(i)\n\n    if not break_points:\n        # If no edges meet threshold, randomly select break points\n        break_points = random.sample(range(n), min(3, n // 2))\n\n    # Sort break points and ensure they are unique\n    break_points = sorted(list(set(break_points)))\n    segments = []\n\n    # Extract segments between break points\n    for i in range(len(break_points)):\n        start = break_points[i]\n        end = break_points[(i + 1) % len(break_points)]\n        if start < end:\n            segments.append(new_solution[start:end])\n        else:\n            segments.append(np.concatenate([new_solution[start:], new_solution[:end]]))\n\n    # Shuffle segments to create new order\n    random.shuffle(segments)\n\n    # Reconstruct the tour from shuffled segments\n    new_solution = np.concatenate(segments)\n\n    # Adaptive node redistribution to balance objectives\n    for _ in range(2):\n        # Select nodes to swap based on their position in both objectives\n        node1, node2 = random.sample(range(n), 2)\n        pos1 = np.where(new_solution == node1)[0][0]\n        pos2 = np.where(new_solution == node2)[0][0]\n\n        # Calculate cost change if nodes are swapped\n        prev1 = new_solution[pos1 - 1]\n        next1 = new_solution[(pos1 + 1) % n]\n        prev2 = new_solution[pos2 - 1]\n        next2 = new_solution[(pos2 + 1) % n]\n\n        old_cost1 = distance_matrix_1[prev1, node1] + distance_matrix_1[node1, next1] + distance_matrix_1[prev2, node2] + distance_matrix_1[node2, next2]\n        old_cost2 = distance_matrix_2[prev1, node1] + distance_matrix_2[node1, next1] + distance_matrix_2[prev2, node2] + distance_matrix_2[node2, next2]\n\n        new_cost1 = distance_matrix_1[prev1, node2] + distance_matrix_1[node2, next1] + distance_matrix_1[prev2, node1] + distance_matrix_1[node1, next2]\n        new_cost2 = distance_matrix_2[prev1, node2] + distance_matrix_2[node2, next1] + distance_matrix_2[prev2, node1] + distance_matrix_2[node1, next2]\n\n        # Accept swap if it improves both objectives\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{ A novel hybrid local search strategy that combines adaptive node clustering with multi-objective segment inversion, where a high-performing solution from the archive is modified by strategically clustering nodes based on their objective space distances and then inverting segments within these clusters to explore diverse high-quality solutions while maintaining feasibility. }",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Cluster nodes based on distance in both objective spaces\n    clusters = []\n    visited = set()\n\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(i + 1, n):\n                if j not in visited:\n                    # Check if nodes are close in both objective spaces\n                    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist1 < 5.0 and dist2 < 5.0:  # Threshold for clustering\n                        cluster.append(j)\n                        visited.add(j)\n            if len(cluster) > 1:\n                clusters.append(cluster)\n\n    # Invert segments within clusters\n    for cluster in clusters:\n        if len(cluster) > 2:  # Only invert if cluster has enough nodes\n            a, b = sorted(random.sample(cluster, 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by repairing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8140131397776197,
            0.4923557639122009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Cluster nodes based on distance in both objective spaces\n    clusters = []\n    visited = set()\n\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(i + 1, n):\n                if j not in visited:\n                    # Check if nodes are close in both objective spaces\n                    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n                    if dist1 < 5.0 and dist2 < 5.0:  # Threshold for clustering\n                        cluster.append(j)\n                        visited.add(j)\n            if len(cluster) > 1:\n                clusters.append(cluster)\n\n    # Invert segments within clusters\n    for cluster in clusters:\n        if len(cluster) > 2:  # Only invert if cluster has enough nodes\n            a, b = sorted(random.sample(cluster, 2))\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure feasibility by repairing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(3):  # Increased number of iterations\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment with higher probability\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost with weighted combination of objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = 0.6 * cost1 + 0.4 * cost2  # Weighted sum\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8617068259348901,
            5.929678797721863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(3):  # Increased number of iterations\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment with higher probability\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost with weighted combination of objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = 0.6 * cost1 + 0.4 * cost2  # Weighted sum\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment insertion, where a high-performing solution from the archive is combined with a random solution by strategically inserting segments from the random solution into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective crossover with segment insertion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective crossover with adaptive segment reversal, where a high-performing solution from the archive is combined with a random solution by strategically reversing segments from the random solution and inserting them into the archive solution, while evaluating the impact on both objectives and ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n        reversed_segment = segment[::-1]\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9561089863255692,
            5.778618216514587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n        reversed_segment = segment[::-1]\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(reversed_segment)):\n            candidate = np.concatenate([new_solution[:i], reversed_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], reversed_segment, new_solution[best_pos:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path fragmentation with adaptive node relinking, where a high-performing solution is systematically disassembled and reconstructed by selectively relinking nodes based on their combined objective space distances, while maintaining feasibility through a dynamic node reassignment mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path fragmentation\n    for _ in range(3):\n        # Randomly select a fragment size\n        fragment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - fragment_size)\n        fragment = new_solution[start:start+fragment_size]\n\n        # Remove the fragment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+fragment_size:]])\n\n        # Find best insertion point based on combined distance\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution) - len(fragment) + 1):\n            # Calculate combined cost of inserting fragment at position i\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, fragment[0]] + distance_matrix_1[fragment[-1], next_node]\n            cost2 = distance_matrix_2[prev_node, fragment[0]] + distance_matrix_2[fragment[-1], next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Insert the fragment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], fragment, new_solution[best_pos:]])\n\n    # Dynamic node reassignment for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Identify missing and duplicate nodes\n        missing = [i for i in range(n) if i not in unique_nodes]\n        duplicates = [i for i in range(n) if list(new_solution).count(i) > 1]\n\n        # Reassign duplicates to missing nodes\n        for d in duplicates:\n            if missing:\n                idx = np.where(new_solution == d)[0][0]\n                new_solution[idx] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7453462078985407,
            0.7970730662345886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path fragmentation\n    for _ in range(3):\n        # Randomly select a fragment size\n        fragment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - fragment_size)\n        fragment = new_solution[start:start+fragment_size]\n\n        # Remove the fragment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+fragment_size:]])\n\n        # Find best insertion point based on combined distance\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution) - len(fragment) + 1):\n            # Calculate combined cost of inserting fragment at position i\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, fragment[0]] + distance_matrix_1[fragment[-1], next_node]\n            cost2 = distance_matrix_2[prev_node, fragment[0]] + distance_matrix_2[fragment[-1], next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Insert the fragment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], fragment, new_solution[best_pos:]])\n\n    # Dynamic node reassignment for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Identify missing and duplicate nodes\n        missing = [i for i in range(n) if i not in unique_nodes]\n        duplicates = [i for i in range(n) if list(new_solution).count(i) > 1]\n\n        # Reassign duplicates to missing nodes\n        for d in duplicates:\n            if missing:\n                idx = np.where(new_solution == d)[0][0]\n                new_solution[idx] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective node swapping with dynamic path optimization, where a high-performing solution from the archive is modified by strategically swapping nodes based on their relative positions in both objective spaces, while dynamically optimizing the path segments between swapped nodes to improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on combined objectives\n    archive_solutions = [(sol, obj[0] + obj[1]) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: x[1])\n    base_solution = archive_solutions[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective node swapping with dynamic path optimization\n    for _ in range(3):\n        # Select two nodes to swap based on their relative positions in both spaces\n        i, j = random.sample(range(n), 2)\n\n        # Calculate the current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept the swap if it improves both objectives\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Dynamic path optimization between swapped nodes\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n\n        # Try to optimize the segment by reversing it\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n\n        if (reversed_cost1 < sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) and\n            reversed_cost2 < sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))):\n            new_solution[i:j+1] = reversed_segment\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.5456592422870791,
            0.7893385291099548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on combined objectives\n    archive_solutions = [(sol, obj[0] + obj[1]) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: x[1])\n    base_solution = archive_solutions[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective node swapping with dynamic path optimization\n    for _ in range(3):\n        # Select two nodes to swap based on their relative positions in both spaces\n        i, j = random.sample(range(n), 2)\n\n        # Calculate the current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept the swap if it improves both objectives\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Dynamic path optimization between swapped nodes\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n\n        # Try to optimize the segment by reversing it\n        reversed_segment = segment[::-1]\n        reversed_cost1 = sum(distance_matrix_1[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n        reversed_cost2 = sum(distance_matrix_2[reversed_segment[k-1], reversed_segment[k]] for k in range(1, len(reversed_segment)))\n\n        if (reversed_cost1 < sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment))) and\n            reversed_cost2 < sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))):\n            new_solution[i:j+1] = reversed_segment\n\n    # Ensure the solution remains feasible\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective node swapping with adaptive path inversion, where a high-performing solution from the archive is modified by strategically swapping nodes from a random solution and inverting paths between them, while evaluating the impact on both objectives and ensuring feasibility through a dynamic node reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective node swapping with path inversion\n    for _ in range(2):\n        # Select two random nodes from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        node_a = random_sol[a]\n        node_b = random_sol[b]\n\n        # Find positions of these nodes in new_solution\n        pos_a = np.where(new_solution == node_a)[0][0]\n        pos_b = np.where(new_solution == node_b)[0][0]\n\n        # Optionally invert the path between the nodes\n        if random.random() < 0.5:\n            if pos_a < pos_b:\n                new_solution[pos_a:pos_b+1] = new_solution[pos_a:pos_b+1][::-1]\n            else:\n                new_solution[pos_b:pos_a+1] = new_solution[pos_b:pos_a+1][::-1]\n\n        # Swap the nodes\n        new_solution[pos_a], new_solution[pos_b] = new_solution[pos_b], new_solution[pos_a]\n\n    # Dynamic node reinsertion mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for node in missing_nodes:\n            # Find best insertion point\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(n):\n                candidate = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7817226665671122,
            0.46703118085861206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective node swapping with path inversion\n    for _ in range(2):\n        # Select two random nodes from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        node_a = random_sol[a]\n        node_b = random_sol[b]\n\n        # Find positions of these nodes in new_solution\n        pos_a = np.where(new_solution == node_a)[0][0]\n        pos_b = np.where(new_solution == node_b)[0][0]\n\n        # Optionally invert the path between the nodes\n        if random.random() < 0.5:\n            if pos_a < pos_b:\n                new_solution[pos_a:pos_b+1] = new_solution[pos_a:pos_b+1][::-1]\n            else:\n                new_solution[pos_b:pos_a+1] = new_solution[pos_b:pos_a+1][::-1]\n\n        # Swap the nodes\n        new_solution[pos_a], new_solution[pos_b] = new_solution[pos_b], new_solution[pos_a]\n\n    # Dynamic node reinsertion mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by reinserting missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for node in missing_nodes:\n            # Find best insertion point\n            best_pos = 0\n            best_cost = float('inf')\n\n            for i in range(n):\n                candidate = np.insert(new_solution, i, node)\n                cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = i\n\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{This algorithm employs a multi-phase approach combining adaptive segment inversion with dynamic node reinsertion, where segments are selectively inverted and nodes are strategically repositioned based on their contribution to both objectives, while maintaining feasibility through careful validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment inversion\n    segment_size = max(2, min(5, n // 3))\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Dynamic node reinsertion\n    for _ in range(2):\n        pos1, pos2 = sorted(random.sample(range(n), 2))\n        node = new_solution[pos1]\n\n        # Calculate potential improvement in both objectives\n        if pos2 - pos1 > 1:\n            prev1 = new_solution[pos1 - 1] if pos1 > 0 else new_solution[-1]\n            next1 = new_solution[pos1 + 1] if pos1 < n - 1 else new_solution[0]\n            prev2 = new_solution[pos2 - 1] if pos2 > 0 else new_solution[-1]\n            next2 = new_solution[pos2] if pos2 < n else new_solution[0]\n\n            cost1 = (distance_matrix_1[prev1, node] + distance_matrix_1[node, next1] +\n                     distance_matrix_2[prev1, node] + distance_matrix_2[node, next1])\n            cost2 = (distance_matrix_1[prev1, next1] + distance_matrix_1[prev2, node] + distance_matrix_1[node, next2] +\n                     distance_matrix_2[prev1, next1] + distance_matrix_2[prev2, node] + distance_matrix_2[node, next2])\n\n            if cost2 < cost1:\n                # Perform the reinsertion\n                new_solution = np.concatenate([new_solution[:pos1], new_solution[pos1+1:pos2+1], [node], new_solution[pos2+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7570970730935029,
            0.44065147638320923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive segment inversion\n    segment_size = max(2, min(5, n // 3))\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Dynamic node reinsertion\n    for _ in range(2):\n        pos1, pos2 = sorted(random.sample(range(n), 2))\n        node = new_solution[pos1]\n\n        # Calculate potential improvement in both objectives\n        if pos2 - pos1 > 1:\n            prev1 = new_solution[pos1 - 1] if pos1 > 0 else new_solution[-1]\n            next1 = new_solution[pos1 + 1] if pos1 < n - 1 else new_solution[0]\n            prev2 = new_solution[pos2 - 1] if pos2 > 0 else new_solution[-1]\n            next2 = new_solution[pos2] if pos2 < n else new_solution[0]\n\n            cost1 = (distance_matrix_1[prev1, node] + distance_matrix_1[node, next1] +\n                     distance_matrix_2[prev1, node] + distance_matrix_2[node, next1])\n            cost2 = (distance_matrix_1[prev1, next1] + distance_matrix_1[prev2, node] + distance_matrix_1[node, next2] +\n                     distance_matrix_2[prev1, next1] + distance_matrix_2[prev2, node] + distance_matrix_2[node, next2])\n\n            if cost2 < cost1:\n                # Perform the reinsertion\n                new_solution = np.concatenate([new_solution[:pos1], new_solution[pos1+1:pos2+1], [node], new_solution[pos2+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{A novel adaptive segment crossover with multi-objective segment inversion that dynamically combines segments from multiple archive solutions while applying probabilistic inversion to balance exploration and exploitation, ensuring feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple high-performing solutions from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_indices = random.sample(range(len(archive_solutions)), min(3, len(archive_solutions)))\n    selected_sols = [archive_solutions[i] for i in selected_indices]\n\n    new_solution = archive_solutions[0].copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover with inversion\n    for _ in range(3):\n        # Select segments from random solutions\n        sol_idx = random.randint(0, len(selected_sols)-1)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = selected_sols[sol_idx][a:b]\n\n        # Probabilistic inversion based on segment quality\n        if random.random() < 0.3:\n            segment = segment[::-1]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Probabilistic repair mechanism\n    if random.random() < 0.2:\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] in unique_nodes:\n                    continue\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9706732528943028,
            5.940711975097656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple high-performing solutions from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_indices = random.sample(range(len(archive_solutions)), min(3, len(archive_solutions)))\n    selected_sols = [archive_solutions[i] for i in selected_indices]\n\n    new_solution = archive_solutions[0].copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover with inversion\n    for _ in range(3):\n        # Select segments from random solutions\n        sol_idx = random.randint(0, len(selected_sols)-1)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = selected_sols[sol_idx][a:b]\n\n        # Probabilistic inversion based on segment quality\n        if random.random() < 0.3:\n            segment = segment[::-1]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Probabilistic repair mechanism\n    if random.random() < 0.2:\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] in unique_nodes:\n                    continue\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This novel hybrid local search strategy combines multi-objective segment crossover with adaptive node reinsertion, where a promising solution from the archive is modified by strategically exchanging segments with a randomly selected solution while intelligently reinserting nodes to maintain feasibility and improve both objectives through dynamic cost evaluation and objective-aware segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment crossover\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best crossover point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Perform crossover\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Perform the best crossover\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        candidate = np.delete(new_solution, node_pos)\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Insert node at position i\n            temp = np.insert(candidate, i, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[j-1], temp[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[temp[j-1], temp[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Perform the best insertion\n        new_solution = np.insert(candidate, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8887388779743868,
            12.48525846004486
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment crossover\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Find best crossover point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Perform crossover\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Perform the best crossover\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node\n        candidate = np.delete(new_solution, node_pos)\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n-1):\n            # Insert node at position i\n            temp = np.insert(candidate, i, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[j-1], temp[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[temp[j-1], temp[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Perform the best insertion\n        new_solution = np.insert(candidate, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{A novel multi-objective adaptive segment exchange strategy that intelligently selects and combines segments from high-performing solutions while dynamically balancing the trade-off between objectives through a weighted cost evaluation and probabilistic segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive (top 20%)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_sol = random.choice(top_solutions)[0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    reference_sol = random.choice(archive)[0].copy()\n\n    # Adaptive segment exchange with weighted cost evaluation\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = reference_sol[a:b]\n\n        # Probabilistic segment selection based on objective weights\n        weight1, weight2 = random.random(), random.random()\n        weight_sum = weight1 + weight2\n        weight1 /= weight_sum\n        weight2 /= weight_sum\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            weighted_score = weight1 * cost1 + weight2 * cost2\n\n            if weighted_score < best_score:\n                best_score = weighted_score\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8178389573088217,
            5.996465861797333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive (top 20%)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_sol = random.choice(top_solutions)[0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    reference_sol = random.choice(archive)[0].copy()\n\n    # Adaptive segment exchange with weighted cost evaluation\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = reference_sol[a:b]\n\n        # Probabilistic segment selection based on objective weights\n        weight1, weight2 = random.random(), random.random()\n        weight_sum = weight1 + weight2\n        weight1 /= weight_sum\n        weight2 /= weight_sum\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            weighted_score = weight1 * cost1 + weight2 * cost2\n\n            if weighted_score < best_score:\n                best_score = weighted_score\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently inserting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):  # Perform multiple insertions\n        # Select a segment and a random insertion point\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        insert_pos = random.randint(0, n - segment_size)\n\n        # Ensure the segment is not inserted at its original position\n        while insert_pos == seg_start:\n            insert_pos = random.randint(0, n - segment_size)\n\n        # Extract and insert the segment\n        seg = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        new_solution = np.insert(new_solution, insert_pos, seg)\n\n    # Dynamic edge selection for further refinement\n    for _ in range(4):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9301591297591402,
            0.5390645265579224
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):  # Perform multiple insertions\n        # Select a segment and a random insertion point\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        insert_pos = random.randint(0, n - segment_size)\n\n        # Ensure the segment is not inserted at its original position\n        while insert_pos == seg_start:\n            insert_pos = random.randint(0, n - segment_size)\n\n        # Extract and insert the segment\n        seg = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        new_solution = np.insert(new_solution, insert_pos, seg)\n\n    # Dynamic edge selection for further refinement\n    for _ in range(4):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive k-segment partitioning with multi-objective edge insertion, where a solution is partitioned into k variable-length segments, and edges between segments are strategically inserted or removed based on their combined impact on both objectives while maintaining feasibility through a segment reordering mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = max(2, min(5, n // 3))  # Determine number of segments\n\n    # Adaptive k-segment partitioning\n    segment_breaks = sorted(random.sample(range(1, n), k-1))\n    segments = []\n    start = 0\n    for break_point in segment_breaks:\n        segments.append(new_solution[start:break_point])\n        start = break_point\n    segments.append(new_solution[start:])\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        # Select random segments\n        seg1_idx, seg2_idx = random.sample(range(len(segments)), 2)\n        seg1 = segments[seg1_idx]\n        seg2 = segments[seg2_idx]\n\n        # Try inserting edges between segments\n        for _ in range(3):\n            # Select random nodes from each segment\n            node1 = random.choice(seg1)\n            node2 = random.choice(seg2)\n\n            # Find positions in original solution\n            pos1 = np.where(new_solution == node1)[0][0]\n            pos2 = np.where(new_solution == node2)[0][0]\n\n            # Calculate potential cost change\n            original_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n            original_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n            new_cost1 = distance_matrix_1[new_solution[pos1-1], node2] + distance_matrix_1[node1, new_solution[pos2]]\n            new_cost2 = distance_matrix_2[new_solution[pos1-1], node2] + distance_matrix_2[node1, new_solution[pos2]]\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                # Perform the swap\n                new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Segment reordering to maintain feasibility\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    return new_solution\n\n",
        "score": [
            -0.7929218599085526,
            0.5134515166282654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = max(2, min(5, n // 3))  # Determine number of segments\n\n    # Adaptive k-segment partitioning\n    segment_breaks = sorted(random.sample(range(1, n), k-1))\n    segments = []\n    start = 0\n    for break_point in segment_breaks:\n        segments.append(new_solution[start:break_point])\n        start = break_point\n    segments.append(new_solution[start:])\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        # Select random segments\n        seg1_idx, seg2_idx = random.sample(range(len(segments)), 2)\n        seg1 = segments[seg1_idx]\n        seg2 = segments[seg2_idx]\n\n        # Try inserting edges between segments\n        for _ in range(3):\n            # Select random nodes from each segment\n            node1 = random.choice(seg1)\n            node2 = random.choice(seg2)\n\n            # Find positions in original solution\n            pos1 = np.where(new_solution == node1)[0][0]\n            pos2 = np.where(new_solution == node2)[0][0]\n\n            # Calculate potential cost change\n            original_cost1 = distance_matrix_1[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_1[new_solution[pos2-1], new_solution[pos2]]\n            original_cost2 = distance_matrix_2[new_solution[pos1-1], new_solution[pos1]] + distance_matrix_2[new_solution[pos2-1], new_solution[pos2]]\n\n            new_cost1 = distance_matrix_1[new_solution[pos1-1], node2] + distance_matrix_1[node1, new_solution[pos2]]\n            new_cost2 = distance_matrix_2[new_solution[pos1-1], node2] + distance_matrix_2[node1, new_solution[pos2]]\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                # Perform the swap\n                new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Segment reordering to maintain feasibility\n    random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This new algorithm implements a multi-objective segment exchange with adaptive inversion and dominance-based selection, where it selects a solution based on Pareto dominance and then applies a segment exchange operation from a random solution, optionally inverting segments, while evaluating the impact on both objectives and repairing any infeasibilities through a dominance-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment exchange with adaptive inversion\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        if random.random() < 0.3:\n            segment = segment[::-1]\n\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_cost1, best_cost2 = cost1, cost2\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dominance-preserving repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9367159621205857,
            5.958369791507721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment exchange with adaptive inversion\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        if random.random() < 0.3:\n            segment = segment[::-1]\n\n        best_pos = -1\n        best_cost1 = float('inf')\n        best_cost2 = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_cost1, best_cost2 = cost1, cost2\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dominance-preserving repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This novel algorithm combines hierarchical segment clustering with adaptive multi-objective inversion, where it first partitions the tour into clusters based on spatial proximity in both objective spaces, then selectively inverts segments within clusters to balance exploration of high-quality regions while maintaining feasibility through a cluster-based repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Hierarchical segment clustering based on spatial proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate distance in both spaces\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n\n        # Add to current cluster or start new cluster\n        if len(current_cluster) < segment_size and (dist1 + dist2) < 2 * np.mean(distance_matrix_1):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Adaptive multi-objective inversion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Determine inversion probability based on cluster quality\n        cluster_nodes = np.array(cluster)\n        cluster_cost1 = sum(distance_matrix_1[cluster_nodes[i-1], cluster_nodes[i]] for i in range(1, len(cluster_nodes)))\n        cluster_cost2 = sum(distance_matrix_2[cluster_nodes[i-1], cluster_nodes[i]] for i in range(1, len(cluster_nodes)))\n\n        # Higher probability for clusters with better balance between objectives\n        balance = abs(cluster_cost1 - cluster_cost2) / (cluster_cost1 + cluster_cost2)\n        invert_prob = 0.3 + 0.4 * (1 - balance)\n\n        if random.random() < invert_prob:\n            # Find cluster positions in solution\n            indices = [np.where(new_solution == node)[0][0] for node in cluster]\n            start, end = min(indices), max(indices)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Cluster-based repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Rebuild clusters and repair missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.5780191320904845,
            0.8606991767883301
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Hierarchical segment clustering based on spatial proximity\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate distance in both spaces\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n\n        # Add to current cluster or start new cluster\n        if len(current_cluster) < segment_size and (dist1 + dist2) < 2 * np.mean(distance_matrix_1):\n            current_cluster.append(node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Adaptive multi-objective inversion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Determine inversion probability based on cluster quality\n        cluster_nodes = np.array(cluster)\n        cluster_cost1 = sum(distance_matrix_1[cluster_nodes[i-1], cluster_nodes[i]] for i in range(1, len(cluster_nodes)))\n        cluster_cost2 = sum(distance_matrix_2[cluster_nodes[i-1], cluster_nodes[i]] for i in range(1, len(cluster_nodes)))\n\n        # Higher probability for clusters with better balance between objectives\n        balance = abs(cluster_cost1 - cluster_cost2) / (cluster_cost1 + cluster_cost2)\n        invert_prob = 0.3 + 0.4 * (1 - balance)\n\n        if random.random() < invert_prob:\n            # Find cluster positions in solution\n            indices = [np.where(new_solution == node)[0][0] for node in cluster]\n            start, end = min(indices), max(indices)\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Cluster-based repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Rebuild clusters and repair missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions by intelligently inserting nodes and reversing segments while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic path reversal with segment selection\n    for _ in range(3):\n        start = random.randint(0, n - 1)\n        end = random.randint(start + 1, min(start + 5, n))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.836609112553313,
            0.49856293201446533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Dynamic path reversal with segment selection\n    for _ in range(3):\n        start = random.randint(0, n - 1)\n        end = random.randint(start + 1, min(start + 5, n))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{An adaptive multi-objective local search strategy that combines dynamic segment decomposition with intelligent edge insertion, where high-performing solutions from the archive are modified by decomposing promising segments and strategically inserting them into different positions while evaluating their impact on both objectives through a multi-criteria acceptance mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on combined objective values\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol = min(archive_solutions, key=lambda x: sum(x[1]))[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment decomposition and insertion\n    for _ in range(3):\n        # Select a random segment size\n        segment_size = random.randint(2, min(5, n // 3))\n        seg_start = random.randint(0, n - segment_size)\n        segment = new_solution[seg_start:seg_start + segment_size]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + segment_size:]])\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_improvement = 0\n\n        for i in range(n - segment_size + 1):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Calculate cost difference\n            original_cost1 = sum(distance_matrix_1[selected_sol[j-1], selected_sol[j]] for j in range(1, n))\n            original_cost2 = sum(distance_matrix_2[selected_sol[j-1], selected_sol[j]] for j in range(1, n))\n\n            new_cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            new_cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n\n            improvement = (original_cost1 + original_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Intelligent edge insertion for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Consider inserting the edge between i and j in reverse\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n\n            # Calculate cost difference\n            original_cost1 = sum(distance_matrix_1[selected_sol[k-1], selected_sol[k]] for k in range(1, n))\n            original_cost2 = sum(distance_matrix_2[selected_sol[k-1], selected_sol[k]] for k in range(1, n))\n\n            new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, n))\n            new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, n))\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7387389953830921,
            14.816985070705414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on combined objective values\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol = min(archive_solutions, key=lambda x: sum(x[1]))[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment decomposition and insertion\n    for _ in range(3):\n        # Select a random segment size\n        segment_size = random.randint(2, min(5, n // 3))\n        seg_start = random.randint(0, n - segment_size)\n        segment = new_solution[seg_start:seg_start + segment_size]\n\n        # Remove the segment from the solution\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + segment_size:]])\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_improvement = 0\n\n        for i in range(n - segment_size + 1):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Calculate cost difference\n            original_cost1 = sum(distance_matrix_1[selected_sol[j-1], selected_sol[j]] for j in range(1, n))\n            original_cost2 = sum(distance_matrix_2[selected_sol[j-1], selected_sol[j]] for j in range(1, n))\n\n            new_cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            new_cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n\n            improvement = (original_cost1 + original_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Intelligent edge insertion for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Consider inserting the edge between i and j in reverse\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n\n            # Calculate cost difference\n            original_cost1 = sum(distance_matrix_1[selected_sol[k-1], selected_sol[k]] for k in range(1, n))\n            original_cost2 = sum(distance_matrix_2[selected_sol[k-1], selected_sol[k]] for k in range(1, n))\n\n            new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, n))\n            new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, n))\n\n            if (new_cost1 + new_cost2) < (original_cost1 + original_cost2):\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment reversal with dynamic node insertion to explore high-quality solutions by intelligently reversing segments of the tour and inserting nodes in positions that improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_to_move = random.choice(new_solution)\n        node_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8221965310912877,
            0.48119741678237915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment reversal\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_to_move = random.choice(new_solution)\n        node_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore high-quality solutions by intelligently inverting segments of the tour and strategically inserting nodes while maintaining feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(4):  # Perform multiple insertions\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != 0 and insert_pos != n - 1:\n            new_solution = np.concatenate((new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]))\n\n    # Ensure solution remains feasible by removing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        # If nodes are missing, add them randomly\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate((new_solution[:insert_pos], [node], new_solution[insert_pos:]))\n\n    return new_solution\n\n",
        "score": [
            -0.8936037180206633,
            0.052541255950927734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(4):  # Perform multiple insertions\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != 0 and insert_pos != n - 1:\n            new_solution = np.concatenate((new_solution[:insert_pos], [node_to_insert], new_solution[insert_pos:]))\n\n    # Ensure solution remains feasible by removing duplicates\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        # If nodes are missing, add them randomly\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.concatenate((new_solution[:insert_pos], [node], new_solution[insert_pos:]))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with multi-objective edge insertion to explore the solution space by dynamically adjusting tour segments and inserting high-quality edges from both objective spaces while maintaining feasibility and promoting diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        # Select a random edge to remove\n        i = random.randint(0, n - 2)\n        removed_node = new_solution[i+1]\n\n        # Find the best insertion point considering both objectives\n        best_pos = i\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == i or pos == i+1:\n                continue\n\n            # Calculate cost for both objectives\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[pos], removed_node]\n                cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[pos], removed_node]\n            elif pos == n-1:\n                cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[removed_node, new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[removed_node, new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[removed_node, new_solution[(pos+1)%n]]\n                cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[removed_node, new_solution[(pos+1)%n]]\n\n            # Combine costs using simple sum (could be replaced with more sophisticated weighting)\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the removed node at the best position\n        if best_pos > i:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:best_pos+1], [removed_node], new_solution[best_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [removed_node], new_solution[best_pos:i+1], new_solution[i+2:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9653861372800256,
            0.7015740871429443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        # Select a random edge to remove\n        i = random.randint(0, n - 2)\n        removed_node = new_solution[i+1]\n\n        # Find the best insertion point considering both objectives\n        best_pos = i\n        min_cost = float('inf')\n\n        for pos in range(n):\n            if pos == i or pos == i+1:\n                continue\n\n            # Calculate cost for both objectives\n            if pos == 0:\n                cost1 = distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_1[new_solution[pos], removed_node]\n                cost2 = distance_matrix_2[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[pos], removed_node]\n            elif pos == n-1:\n                cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[removed_node, new_solution[0]]\n                cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[removed_node, new_solution[0]]\n            else:\n                cost1 = distance_matrix_1[new_solution[pos-1], new_solution[pos]] + distance_matrix_1[removed_node, new_solution[(pos+1)%n]]\n                cost2 = distance_matrix_2[new_solution[pos-1], new_solution[pos]] + distance_matrix_2[removed_node, new_solution[(pos+1)%n]]\n\n            # Combine costs using simple sum (could be replaced with more sophisticated weighting)\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert the removed node at the best position\n        if best_pos > i:\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:best_pos+1], [removed_node], new_solution[best_pos+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [removed_node], new_solution[best_pos:i+1], new_solution[i+2:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{This novel algorithm combines multi-objective segment relocation with adaptive tour partitioning, where a promising solution from the archive is modified by strategically relocating segments between distinct partitions of the tour while considering both objectives and ensuring feasibility through a dynamic segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Determine number of partitions based on problem size\n    num_partitions = max(2, min(5, n // 3))\n    partition_size = n // num_partitions\n\n    # Create partitions\n    partitions = []\n    for i in range(num_partitions):\n        start = i * partition_size\n        end = start + partition_size if i < num_partitions - 1 else n\n        partitions.append(new_solution[start:end])\n\n    # Multi-objective segment relocation\n    for _ in range(3):\n        # Select random source and target partitions\n        src_idx, tgt_idx = random.sample(range(num_partitions), 2)\n        src_part = partitions[src_idx]\n        tgt_part = partitions[tgt_idx]\n\n        # Select segments from source partition\n        seg_size = max(2, min(5, len(src_part) // 2))\n        seg_start = random.randint(0, len(src_part) - seg_size)\n        segment = src_part[seg_start:seg_start+seg_size]\n\n        # Find best insertion point in target partition\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(tgt_part) - len(segment) + 1):\n            # Create candidate solution\n            candidate_part = np.concatenate([tgt_part[:i], segment, tgt_part[i:]])\n            candidate_sol = np.concatenate([part for j, part in enumerate(partitions) if j != tgt_idx] + [candidate_part])\n\n            # Ensure no duplicates\n            if len(np.unique(candidate_sol)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate_sol[j-1], candidate_sol[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate_sol[j-1], candidate_sol[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_part = np.concatenate([tgt_part[:best_pos], segment, tgt_part[best_pos:]])\n            partitions[tgt_idx] = new_part\n\n    # Reconstruct the solution from partitions\n    new_solution = np.concatenate(partitions)\n\n    # Dynamic segment validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9098650704121858,
            1.2291871905326843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Determine number of partitions based on problem size\n    num_partitions = max(2, min(5, n // 3))\n    partition_size = n // num_partitions\n\n    # Create partitions\n    partitions = []\n    for i in range(num_partitions):\n        start = i * partition_size\n        end = start + partition_size if i < num_partitions - 1 else n\n        partitions.append(new_solution[start:end])\n\n    # Multi-objective segment relocation\n    for _ in range(3):\n        # Select random source and target partitions\n        src_idx, tgt_idx = random.sample(range(num_partitions), 2)\n        src_part = partitions[src_idx]\n        tgt_part = partitions[tgt_idx]\n\n        # Select segments from source partition\n        seg_size = max(2, min(5, len(src_part) // 2))\n        seg_start = random.randint(0, len(src_part) - seg_size)\n        segment = src_part[seg_start:seg_start+seg_size]\n\n        # Find best insertion point in target partition\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(len(tgt_part) - len(segment) + 1):\n            # Create candidate solution\n            candidate_part = np.concatenate([tgt_part[:i], segment, tgt_part[i:]])\n            candidate_sol = np.concatenate([part for j, part in enumerate(partitions) if j != tgt_idx] + [candidate_part])\n\n            # Ensure no duplicates\n            if len(np.unique(candidate_sol)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate_sol[j-1], candidate_sol[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate_sol[j-1], candidate_sol[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_part = np.concatenate([tgt_part[:best_pos], segment, tgt_part[best_pos:]])\n            partitions[tgt_idx] = new_part\n\n    # Reconstruct the solution from partitions\n    new_solution = np.concatenate(partitions)\n\n    # Dynamic segment validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node clustering with multi-objective edge optimization, where nodes are first grouped based on their spatial proximity in both objective spaces, then edges are selectively optimized by considering the trade-off between the two objectives to generate high-quality, diverse solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster nodes based on spatial proximity in both objective spaces\n    n = len(instance)\n    clusters = []\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            cluster = [i]\n            visited[i] = True\n            for j in range(i + 1, n):\n                if not visited[j]:\n                    # Check proximity in both spaces\n                    dist1 = distance_matrix_1[i, j]\n                    dist2 = distance_matrix_2[i, j]\n                    if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                        cluster.append(j)\n                        visited[j] = True\n            clusters.append(cluster)\n\n    # Optimize edges by considering multi-objective trade-off\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Find the best edge to swap considering both objectives\n        best_improvement = 0\n        best_swap = None\n\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node_i = cluster[i]\n                node_j = cluster[j]\n\n                # Find positions in the tour\n                pos_i = np.where(new_solution == node_i)[0][0]\n                pos_j = np.where(new_solution == node_j)[0][0]\n\n                # Calculate current and potential costs\n                current_cost = (distance_matrix_1[new_solution[pos_i-1], new_solution[pos_i]] +\n                               distance_matrix_1[new_solution[pos_j-1], new_solution[pos_j]] +\n                               distance_matrix_2[new_solution[pos_i-1], new_solution[pos_i]] +\n                               distance_matrix_2[new_solution[pos_j-1], new_solution[pos_j]])\n\n                potential_cost = (distance_matrix_1[new_solution[pos_i-1], new_solution[pos_j]] +\n                                 distance_matrix_1[new_solution[pos_j-1], new_solution[pos_i]] +\n                                 distance_matrix_2[new_solution[pos_i-1], new_solution[pos_j]] +\n                                 distance_matrix_2[new_solution[pos_j-1], new_solution[pos_i]])\n\n                improvement = current_cost - potential_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (pos_i, pos_j)\n\n        if best_swap is not None:\n            pos_i, pos_j = best_swap\n            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n\n    return new_solution\n\n",
        "score": [
            -0.5543263521666696,
            7.792411029338837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Cluster nodes based on spatial proximity in both objective spaces\n    n = len(instance)\n    clusters = []\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            cluster = [i]\n            visited[i] = True\n            for j in range(i + 1, n):\n                if not visited[j]:\n                    # Check proximity in both spaces\n                    dist1 = distance_matrix_1[i, j]\n                    dist2 = distance_matrix_2[i, j]\n                    if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                        cluster.append(j)\n                        visited[j] = True\n            clusters.append(cluster)\n\n    # Optimize edges by considering multi-objective trade-off\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Find the best edge to swap considering both objectives\n        best_improvement = 0\n        best_swap = None\n\n        for i in range(len(cluster)):\n            for j in range(i + 1, len(cluster)):\n                node_i = cluster[i]\n                node_j = cluster[j]\n\n                # Find positions in the tour\n                pos_i = np.where(new_solution == node_i)[0][0]\n                pos_j = np.where(new_solution == node_j)[0][0]\n\n                # Calculate current and potential costs\n                current_cost = (distance_matrix_1[new_solution[pos_i-1], new_solution[pos_i]] +\n                               distance_matrix_1[new_solution[pos_j-1], new_solution[pos_j]] +\n                               distance_matrix_2[new_solution[pos_i-1], new_solution[pos_i]] +\n                               distance_matrix_2[new_solution[pos_j-1], new_solution[pos_j]])\n\n                potential_cost = (distance_matrix_1[new_solution[pos_i-1], new_solution[pos_j]] +\n                                 distance_matrix_1[new_solution[pos_j-1], new_solution[pos_i]] +\n                                 distance_matrix_2[new_solution[pos_i-1], new_solution[pos_j]] +\n                                 distance_matrix_2[new_solution[pos_j-1], new_solution[pos_i]])\n\n                improvement = current_cost - potential_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (pos_i, pos_j)\n\n        if best_swap is not None:\n            pos_i, pos_j = best_swap\n            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment rearrangement with dynamic edge optimization, using a weighted objective score to intelligently select segments and edges for improvement, while maintaining tour feasibility and balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on weighted objective score\n    def objective_score(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]\n\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: objective_score(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate segment improvement potential\n        seg = new_solution[seg_start:seg_end]\n        seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n\n        # Find a better segment position\n        best_pos = seg_start\n        best_score = objective_score((seg_cost1, seg_cost2))\n\n        for pos in range(n - segment_size + 1):\n            if pos == seg_start:\n                continue\n            temp_sol = new_solution.copy()\n            temp_sol[pos:pos+segment_size] = seg\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            temp_score = objective_score((temp_cost1, temp_cost2))\n\n            if temp_score < best_score:\n                best_score = temp_score\n                best_pos = pos\n\n        if best_pos != seg_start:\n            new_solution[best_pos:best_pos+segment_size] = seg\n\n    # Dynamic edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7594168840870628,
            6.785447716712952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on weighted objective score\n    def objective_score(obj):\n        return 0.7 * obj[0] + 0.3 * obj[1]\n\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: objective_score(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate segment improvement potential\n        seg = new_solution[seg_start:seg_end]\n        seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n        seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n\n        # Find a better segment position\n        best_pos = seg_start\n        best_score = objective_score((seg_cost1, seg_cost2))\n\n        for pos in range(n - segment_size + 1):\n            if pos == seg_start:\n                continue\n            temp_sol = new_solution.copy()\n            temp_sol[pos:pos+segment_size] = seg\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n))\n            temp_score = objective_score((temp_cost1, temp_cost2))\n\n            if temp_score < best_score:\n                best_score = temp_score\n                best_pos = pos\n\n        if best_pos != seg_start:\n            new_solution[best_pos:best_pos+segment_size] = seg\n\n    # Dynamic edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions by intelligently inverting segments of the tour and strategically inserting nodes while ensuring feasibility and maintaining balance between both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.8990197595111881,
            0.5476531982421875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive using Pareto dominance\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if not pareto_front:\n        selected_sol = random.choice([sol for sol, _ in archive])\n    else:\n        selected_sol = random.choice(pareto_front)\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment replacement with inversion\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Adaptive inversion based on segment length\n        if len(segment) > n // 3:\n            segment = segment[::-1]\n\n        # Find best insertion point with multi-objective evaluation\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            # Penalize solutions that are too similar to the original\n            similarity_penalty = sum(1 for x, y in zip(selected_sol, candidate) if x == y)\n            score = total_cost + 0.1 * similarity_penalty\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7234242714256249,
            6.82218998670578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive using Pareto dominance\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    if not pareto_front:\n        selected_sol = random.choice([sol for sol, _ in archive])\n    else:\n        selected_sol = random.choice(pareto_front)\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment replacement with inversion\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Adaptive inversion based on segment length\n        if len(segment) > n // 3:\n            segment = segment[::-1]\n\n        # Find best insertion point with multi-objective evaluation\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            # Penalize solutions that are too similar to the original\n            similarity_penalty = sum(1 for x, y in zip(selected_sol, candidate) if x == y)\n            score = total_cost + 0.1 * similarity_penalty\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path reshaping with adaptive node clustering, where a high-performing solution from the archive is modified by strategically reshaping paths based on node clusters identified in both objective spaces, while dynamically balancing the trade-off between objectives and ensuring feasibility through a cluster-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Cluster nodes based on their positions in both objective spaces\n    from sklearn.cluster import KMeans\n    k = max(2, min(5, n // 5))  # Determine number of clusters based on problem size\n\n    # Cluster in first objective space\n    coords1 = instance[:, :2]\n    kmeans1 = KMeans(n_clusters=k, random_state=42).fit(coords1)\n    clusters1 = kmeans1.labels_\n\n    # Cluster in second objective space\n    coords2 = instance[:, 2:]\n    kmeans2 = KMeans(n_clusters=k, random_state=42).fit(coords2)\n    clusters2 = kmeans2.labels_\n\n    # Create a combined cluster representation\n    combined_clusters = np.column_stack((clusters1, clusters2))\n\n    # Reshape paths based on clusters\n    for _ in range(3):\n        # Select a random cluster\n        cluster_idx = random.randint(0, k-1)\n        cluster_nodes = [i for i, (c1, c2) in enumerate(combined_clusters) if c1 == cluster_idx or c2 == cluster_idx]\n\n        if len(cluster_nodes) < 2:\n            continue\n\n        # Select two nodes from the cluster\n        node1, node2 = random.sample(cluster_nodes, 2)\n\n        # Find their positions in the solution\n        idx1 = np.where(new_solution == node1)[0][0]\n        idx2 = np.where(new_solution == node2)[0][0]\n\n        # Reshape the path between them\n        if idx1 < idx2:\n            new_solution[idx1:idx2] = new_solution[idx1:idx2][::-1]\n        else:\n            new_solution[idx2:idx1] = new_solution[idx2:idx1][::-1]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8098454261196495,
            7.209917426109314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Cluster nodes based on their positions in both objective spaces\n    from sklearn.cluster import KMeans\n    k = max(2, min(5, n // 5))  # Determine number of clusters based on problem size\n\n    # Cluster in first objective space\n    coords1 = instance[:, :2]\n    kmeans1 = KMeans(n_clusters=k, random_state=42).fit(coords1)\n    clusters1 = kmeans1.labels_\n\n    # Cluster in second objective space\n    coords2 = instance[:, 2:]\n    kmeans2 = KMeans(n_clusters=k, random_state=42).fit(coords2)\n    clusters2 = kmeans2.labels_\n\n    # Create a combined cluster representation\n    combined_clusters = np.column_stack((clusters1, clusters2))\n\n    # Reshape paths based on clusters\n    for _ in range(3):\n        # Select a random cluster\n        cluster_idx = random.randint(0, k-1)\n        cluster_nodes = [i for i, (c1, c2) in enumerate(combined_clusters) if c1 == cluster_idx or c2 == cluster_idx]\n\n        if len(cluster_nodes) < 2:\n            continue\n\n        # Select two nodes from the cluster\n        node1, node2 = random.sample(cluster_nodes, 2)\n\n        # Find their positions in the solution\n        idx1 = np.where(new_solution == node1)[0][0]\n        idx2 = np.where(new_solution == node2)[0][0]\n\n        # Reshape the path between them\n        if idx1 < idx2:\n            new_solution[idx1:idx2] = new_solution[idx1:idx2][::-1]\n        else:\n            new_solution[idx2:idx1] = new_solution[idx2:idx1][::-1]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment insertion with adaptive k-opt moves to explore the solution space by intelligently inserting and rearranging segments while dynamically adjusting the k-value based on the current solution's quality and diversity in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_sol = archive[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = random.randint(3, min(5, n // 2))  # Dynamic k-value\n\n    # Multi-objective segment insertion\n    for _ in range(2):\n        # Select a segment to insert\n        seg_start = random.randint(0, n - k)\n        seg_end = seg_start + k\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Calculate insertion positions based on both objectives\n        insertion_pos = random.randint(0, len(new_solution) - 1)\n\n        # Insert the segment\n        new_solution = np.concatenate([new_solution[:insertion_pos], segment, new_solution[insertion_pos:]])\n\n    # Adaptive k-opt move\n    for _ in range(3):\n        # Select k distinct positions\n        positions = sorted(random.sample(range(n), k))\n\n        # Create a new segment by reversing the selected nodes\n        segment = new_solution[positions[0]:positions[-1]+1][::-1]\n\n        # Replace the original segment\n        new_solution[positions[0]:positions[-1]+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.6781829596444684,
            0.4933367371559143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_sol = archive[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    k = random.randint(3, min(5, n // 2))  # Dynamic k-value\n\n    # Multi-objective segment insertion\n    for _ in range(2):\n        # Select a segment to insert\n        seg_start = random.randint(0, n - k)\n        seg_end = seg_start + k\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Calculate insertion positions based on both objectives\n        insertion_pos = random.randint(0, len(new_solution) - 1)\n\n        # Insert the segment\n        new_solution = np.concatenate([new_solution[:insertion_pos], segment, new_solution[insertion_pos:]])\n\n    # Adaptive k-opt move\n    for _ in range(3):\n        # Select k distinct positions\n        positions = sorted(random.sample(range(n), k))\n\n        # Create a new segment by reversing the selected nodes\n        segment = new_solution[positions[0]:positions[-1]+1][::-1]\n\n        # Replace the original segment\n        new_solution[positions[0]:positions[-1]+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{An adaptive multi-segment crossover operator that combines segments from two high-performing solutions while applying dynamic segment inversion and insertion based on their relative performance in both objectives, ensuring feasibility through a node-swapping repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 5 solutions from the archive based on combined objective scores\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = [sol for sol, _ in sorted_archive[:min(5, len(archive))]]\n\n    # Select two distinct solutions for crossover\n    if len(top_solutions) < 2:\n        parent1, parent2 = top_solutions[0], top_solutions[0]\n    else:\n        parent1, parent2 = random.sample(top_solutions, 2)\n\n    new_solution = parent1.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive inversion\n    for _ in range(3):\n        # Select segments from both parents\n        a1, b1 = sorted(random.sample(range(n), 2))\n        segment1 = parent1[a1:b1]\n\n        a2, b2 = sorted(random.sample(range(n), 2))\n        segment2 = parent2[a2:b2]\n\n        # Adaptively decide which segment to use based on their relative performance\n        cost1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(1, len(segment1))) if len(segment1) > 1 else 0\n        cost2 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(1, len(segment1))) if len(segment1) > 1 else 0\n        score1 = cost1 + cost2\n\n        cost1 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(1, len(segment2))) if len(segment2) > 1 else 0\n        cost2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(1, len(segment2))) if len(segment2) > 1 else 0\n        score2 = cost1 + cost2\n\n        selected_segment = segment1 if score1 < score2 else segment2\n\n        # Randomly invert the selected segment\n        if random.random() < 0.3:\n            selected_segment = selected_segment[::-1]\n\n        # Find best insertion point\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(selected_segment)):\n            candidate = np.concatenate([new_solution[:i], selected_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], selected_segment, new_solution[best_pos:]])\n\n    # Node-swapping repair for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9157191155909319,
            7.078939914703369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 5 solutions from the archive based on combined objective scores\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = [sol for sol, _ in sorted_archive[:min(5, len(archive))]]\n\n    # Select two distinct solutions for crossover\n    if len(top_solutions) < 2:\n        parent1, parent2 = top_solutions[0], top_solutions[0]\n    else:\n        parent1, parent2 = random.sample(top_solutions, 2)\n\n    new_solution = parent1.copy()\n    n = len(new_solution)\n\n    # Multi-segment crossover with adaptive inversion\n    for _ in range(3):\n        # Select segments from both parents\n        a1, b1 = sorted(random.sample(range(n), 2))\n        segment1 = parent1[a1:b1]\n\n        a2, b2 = sorted(random.sample(range(n), 2))\n        segment2 = parent2[a2:b2]\n\n        # Adaptively decide which segment to use based on their relative performance\n        cost1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(1, len(segment1))) if len(segment1) > 1 else 0\n        cost2 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(1, len(segment1))) if len(segment1) > 1 else 0\n        score1 = cost1 + cost2\n\n        cost1 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(1, len(segment2))) if len(segment2) > 1 else 0\n        cost2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(1, len(segment2))) if len(segment2) > 1 else 0\n        score2 = cost1 + cost2\n\n        selected_segment = segment1 if score1 < score2 else segment2\n\n        # Randomly invert the selected segment\n        if random.random() < 0.3:\n            selected_segment = selected_segment[::-1]\n\n        # Find best insertion point\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(selected_segment)):\n            candidate = np.concatenate([new_solution[:i], selected_segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], selected_segment, new_solution[best_pos:]])\n\n    # Node-swapping repair for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with objective-aware edge selection to explore high-quality solutions by intelligently inverting segments and selectively swapping edges based on their contribution to both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Objective-aware edge selection\n    for _ in range(4):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate cost improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8843890752511891,
            0.6512494087219238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Objective-aware edge selection\n    for _ in range(4):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate cost improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This novel hybrid local search strategy combines adaptive segment fusion with dynamic node rearrangement, where high-performing segments from multiple archive solutions are intelligently merged and rearranged while preserving feasibility through a multi-objective validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 3 solutions from the archive based on combined objective values\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))[:3]\n    selected_sol = random.choice(archive_solutions)[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment fusion\n    for _ in range(2):\n        # Select two random segments from different solutions\n        sol1, sol2 = random.sample(archive_solutions, 2)\n        seg_size = random.randint(2, n//3)\n\n        # Extract segments from both solutions\n        seg1_start = random.randint(0, n - seg_size)\n        seg1 = sol1[0][seg1_start:seg1_start + seg_size]\n\n        seg2_start = random.randint(0, n - seg_size)\n        seg2 = sol2[0][seg2_start:seg2_start + seg_size]\n\n        # Merge segments by alternating nodes\n        merged_seg = np.empty(seg_size, dtype=int)\n        for i in range(seg_size):\n            if i % 2 == 0:\n                merged_seg[i] = seg1[i//2]\n            else:\n                merged_seg[i] = seg2[i//2]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - seg_size):\n            candidate = np.concatenate([new_solution[:i], merged_seg, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], merged_seg, new_solution[best_pos:]])\n\n    # Dynamic node rearrangement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Rotate segment\n            k = random.randint(1, j - i - 1)\n            new_solution[i:j] = np.concatenate([new_solution[i+k:j], new_solution[i:i+k]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8386140661518554,
            5.717900514602661
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 3 solutions from the archive based on combined objective values\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))[:3]\n    selected_sol = random.choice(archive_solutions)[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment fusion\n    for _ in range(2):\n        # Select two random segments from different solutions\n        sol1, sol2 = random.sample(archive_solutions, 2)\n        seg_size = random.randint(2, n//3)\n\n        # Extract segments from both solutions\n        seg1_start = random.randint(0, n - seg_size)\n        seg1 = sol1[0][seg1_start:seg1_start + seg_size]\n\n        seg2_start = random.randint(0, n - seg_size)\n        seg2 = sol2[0][seg2_start:seg2_start + seg_size]\n\n        # Merge segments by alternating nodes\n        merged_seg = np.empty(seg_size, dtype=int)\n        for i in range(seg_size):\n            if i % 2 == 0:\n                merged_seg[i] = seg1[i//2]\n            else:\n                merged_seg[i] = seg2[i//2]\n\n        # Find best insertion point\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - seg_size):\n            candidate = np.concatenate([new_solution[:i], merged_seg, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], merged_seg, new_solution[best_pos:]])\n\n    # Dynamic node rearrangement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Rotate segment\n            k = random.randint(1, j - i - 1)\n            new_solution[i:j] = np.concatenate([new_solution[i+k:j], new_solution[i:i+k]])\n\n    # Ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive node swapping, where a high-performing solution from the archive is modified by strategically combining segments from another high-performing solution while adaptively swapping nodes based on their relative performance in both objectives, ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 10% solutions by combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    top_solutions = [sol for sol, _ in sorted_archive[:top_k]]\n\n    # Select two distinct solutions for path relinking\n    if len(top_solutions) < 2:\n        selected_sol = random.choice(top_solutions)\n        new_solution = selected_sol.copy()\n    else:\n        sol1, sol2 = random.sample(top_solutions, 2)\n        new_solution = sol1.copy()\n\n        # Path relinking with adaptive node swapping\n        for i in range(len(new_solution)):\n            if random.random() < 0.3:  # 30% chance to consider swapping\n                node1 = new_solution[i]\n                node2_pos = np.where(sol2 == node1)[0]\n                if len(node2_pos) > 0:\n                    node2_pos = node2_pos[0]\n                    # Adaptive decision based on objective differences\n                    cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                    cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n\n                    cost1_after = distance_matrix_1[new_solution[i-1], sol2[node2_pos]] + distance_matrix_1[sol2[node2_pos], new_solution[(i+1)%len(new_solution)]]\n                    cost2_after = distance_matrix_2[new_solution[i-1], sol2[node2_pos]] + distance_matrix_2[sol2[node2_pos], new_solution[(i+1)%len(new_solution)]]\n\n                    if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                        new_solution[i] = sol2[node2_pos]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    n = len(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8593113124898658,
            4.179679572582245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 10% solutions by combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 10)\n    top_solutions = [sol for sol, _ in sorted_archive[:top_k]]\n\n    # Select two distinct solutions for path relinking\n    if len(top_solutions) < 2:\n        selected_sol = random.choice(top_solutions)\n        new_solution = selected_sol.copy()\n    else:\n        sol1, sol2 = random.sample(top_solutions, 2)\n        new_solution = sol1.copy()\n\n        # Path relinking with adaptive node swapping\n        for i in range(len(new_solution)):\n            if random.random() < 0.3:  # 30% chance to consider swapping\n                node1 = new_solution[i]\n                node2_pos = np.where(sol2 == node1)[0]\n                if len(node2_pos) > 0:\n                    node2_pos = node2_pos[0]\n                    # Adaptive decision based on objective differences\n                    cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                    cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n\n                    cost1_after = distance_matrix_1[new_solution[i-1], sol2[node2_pos]] + distance_matrix_1[sol2[node2_pos], new_solution[(i+1)%len(new_solution)]]\n                    cost2_after = distance_matrix_2[new_solution[i-1], sol2[node2_pos]] + distance_matrix_2[sol2[node2_pos], new_solution[(i+1)%len(new_solution)]]\n\n                    if (cost1_after + cost2_after) < (cost1_before + cost2_before):\n                        new_solution[i] = sol2[node2_pos]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    n = len(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node clustering with multi-objective segment inversion, where solutions are first partitioned into clusters based on spatial proximity in both objective spaces, then segments from different clusters are strategically inverted and reassembled while evaluating their impact on both objectives through a dynamic evaluation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objective spaces\n    cluster_size = max(2, n // 5)\n    clusters = []\n\n    # Create initial clusters by grouping nearby nodes\n    remaining_nodes = set(range(n))\n    while remaining_nodes:\n        current_cluster = [next(iter(remaining_nodes))]\n        remaining_nodes.remove(current_cluster[0])\n\n        while len(current_cluster) < cluster_size and remaining_nodes:\n            # Find closest node to the cluster in both spaces\n            best_node = None\n            min_dist = float('inf')\n\n            for node in remaining_nodes:\n                # Calculate average distance to cluster nodes in both spaces\n                dist1 = sum(distance_matrix_1[current_cluster[i], node] for i in range(len(current_cluster))) / len(current_cluster)\n                dist2 = sum(distance_matrix_2[current_cluster[i], node] for i in range(len(current_cluster))) / len(current_cluster)\n                total_dist = dist1 + dist2\n\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    best_node = node\n\n            if best_node is not None:\n                current_cluster.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        clusters.append(current_cluster)\n\n    # Multi-objective segment inversion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select a random segment within the cluster\n        a, b = sorted(random.sample(range(len(cluster)), 2))\n        segment_indices = [cluster[i] for i in range(a, b)]\n\n        # Invert the segment\n        inverted_segment = [new_solution[i] for i in reversed(segment_indices)]\n\n        # Replace the original segment with the inverted one\n        for i, idx in enumerate(segment_indices):\n            new_solution[idx] = inverted_segment[i]\n\n    # Dynamic evaluation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.683428605588406,
            5.08851820230484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objective spaces\n    cluster_size = max(2, n // 5)\n    clusters = []\n\n    # Create initial clusters by grouping nearby nodes\n    remaining_nodes = set(range(n))\n    while remaining_nodes:\n        current_cluster = [next(iter(remaining_nodes))]\n        remaining_nodes.remove(current_cluster[0])\n\n        while len(current_cluster) < cluster_size and remaining_nodes:\n            # Find closest node to the cluster in both spaces\n            best_node = None\n            min_dist = float('inf')\n\n            for node in remaining_nodes:\n                # Calculate average distance to cluster nodes in both spaces\n                dist1 = sum(distance_matrix_1[current_cluster[i], node] for i in range(len(current_cluster))) / len(current_cluster)\n                dist2 = sum(distance_matrix_2[current_cluster[i], node] for i in range(len(current_cluster))) / len(current_cluster)\n                total_dist = dist1 + dist2\n\n                if total_dist < min_dist:\n                    min_dist = total_dist\n                    best_node = node\n\n            if best_node is not None:\n                current_cluster.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        clusters.append(current_cluster)\n\n    # Multi-objective segment inversion within clusters\n    for cluster in clusters:\n        if len(cluster) < 2:\n            continue\n\n        # Select a random segment within the cluster\n        a, b = sorted(random.sample(range(len(cluster)), 2))\n        segment_indices = [cluster[i] for i in range(a, b)]\n\n        # Invert the segment\n        inverted_segment = [new_solution[i] for i in reversed(segment_indices)]\n\n        # Replace the original segment with the inverted one\n        for i, idx in enumerate(segment_indices):\n            new_solution[idx] = inverted_segment[i]\n\n    # Dynamic evaluation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node reinsertion to explore high-quality solutions by intelligently inverting segments and reinserting nodes while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion\n    for _ in range(2):\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8160269298097707,
            0.6414763927459717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node reinsertion\n    for _ in range(2):\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with constrained edge insertion to explore high-quality solutions by intelligently inverting segments of the tour and strategically inserting edges while ensuring feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Constrained edge insertion\n    for _ in range(3):\n        # Select two distinct positions\n        pos1, pos2 = random.sample(range(n), 2)\n\n        # Ensure we're not inserting at the same position\n        if pos1 != pos2:\n            # Insert the node at pos1 after pos2\n            node = new_solution[pos1]\n            new_solution = np.delete(new_solution, pos1)\n            new_solution = np.insert(new_solution, (pos2 + 1) % n, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8149701982343172,
            0.5779670476913452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Constrained edge insertion\n    for _ in range(3):\n        # Select two distinct positions\n        pos1, pos2 = random.sample(range(n), 2)\n\n        # Ensure we're not inserting at the same position\n        if pos1 != pos2:\n            # Insert the node at pos1 after pos2\n            node = new_solution[pos1]\n            new_solution = np.delete(new_solution, pos1)\n            new_solution = np.insert(new_solution, (pos2 + 1) % n, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{An adaptive multi-objective local search strategy that combines Pareto-optimal segment swapping with dynamic objective-balanced inversion, where a selected solution from the archive is modified by exchanging segments with a reference solution while adaptively inverting segments based on the relative performance of each objective, and ensuring feasibility through a probabilistic repair mechanism that prioritizes nodes with higher marginal improvement in either objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and diversity\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Select a reference solution (could be a random non-dominated solution)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    selected_sol = archive_solutions[selected_idx]\n    ref_sol = random.choice([sol for sol in archive_solutions if sol is not selected_sol])\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Determine objective weights based on relative performance\n    obj1_avg = sum(obj[0] for obj in objectives) / len(objectives)\n    obj2_avg = sum(obj[1] for obj in objectives) / len(objectives)\n    weight1 = obj1_avg / (obj1_avg + obj2_avg)\n    weight2 = obj2_avg / (obj1_avg + obj2_avg)\n\n    # Pareto-optimal segment swapping with adaptive inversion\n    for _ in range(2):\n        # Select a random segment from reference solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = ref_sol[a:b]\n\n        # Adaptively invert based on objective weights\n        if random.random() < weight1:\n            # More likely to invert if first objective is relatively worse\n            segment = segment[::-1]\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate weighted cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            weighted_cost = weight1 * cost1 + weight2 * cost2\n\n            if weighted_cost < best_score:\n                best_score = weighted_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n\n            # Prioritize nodes with better marginal improvement\n            best_node = None\n            best_improvement = -float('inf')\n\n            for node in missing_nodes:\n                # Calculate potential improvement for each objective\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[(i+1)%n]\n\n                imp1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                imp2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                weighted_imp = weight1 * imp1 + weight2 * imp2\n\n                if weighted_imp > best_improvement:\n                    best_improvement = weighted_imp\n                    best_node = node\n\n            if best_node is not None:\n                new_solution[i] = best_node\n                missing_nodes.remove(best_node)\n\n    return new_solution\n\n",
        "score": [
            -0.9401064409229142,
            4.576526999473572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on Pareto dominance and diversity\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Select a reference solution (could be a random non-dominated solution)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    selected_sol = archive_solutions[selected_idx]\n    ref_sol = random.choice([sol for sol in archive_solutions if sol is not selected_sol])\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Determine objective weights based on relative performance\n    obj1_avg = sum(obj[0] for obj in objectives) / len(objectives)\n    obj2_avg = sum(obj[1] for obj in objectives) / len(objectives)\n    weight1 = obj1_avg / (obj1_avg + obj2_avg)\n    weight2 = obj2_avg / (obj1_avg + obj2_avg)\n\n    # Pareto-optimal segment swapping with adaptive inversion\n    for _ in range(2):\n        # Select a random segment from reference solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = ref_sol[a:b]\n\n        # Adaptively invert based on objective weights\n        if random.random() < weight1:\n            # More likely to invert if first objective is relatively worse\n            segment = segment[::-1]\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate weighted cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            weighted_cost = weight1 * cost1 + weight2 * cost2\n\n            if weighted_cost < best_score:\n                best_score = weighted_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n\n            # Prioritize nodes with better marginal improvement\n            best_node = None\n            best_improvement = -float('inf')\n\n            for node in missing_nodes:\n                # Calculate potential improvement for each objective\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[(i+1)%n]\n\n                imp1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                imp2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                weighted_imp = weight1 * imp1 + weight2 * imp2\n\n                if weighted_imp > best_improvement:\n                    best_improvement = weighted_imp\n                    best_node = node\n\n            if best_node is not None:\n                new_solution[i] = best_node\n                missing_nodes.remove(best_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with multi-objective edge flipping to explore high-quality solutions by dynamically selecting and inverting segments while considering both objective spaces to create balanced improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            if random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7840713634218834,
            0.4414014220237732
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            if random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{An adaptive hybrid local search algorithm that combines dynamic path reversal with objective-aware node insertion to explore the solution space by selectively reversing segments and inserting nodes based on their relative contributions to both objective functions, ensuring balanced improvement across both spaces while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    selected_sol = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Dynamic path reversal with objective awareness\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate the improvement potential in both objectives\n            before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            after_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            after_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Only reverse if it improves at least one objective\n            if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Select a node to insert\n        node = random.choice(new_solution)\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(1, n):\n            # Calculate insertion cost for both objectives\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Perform the insertion\n        new_solution = np.insert(new_solution, best_pos, node)\n        # Remove the original node (keeping the same length)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.6430719914610022,
            1.2505298852920532
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score\n    selected_sol = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Dynamic path reversal with objective awareness\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate the improvement potential in both objectives\n            before_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            before_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            after_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            after_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Only reverse if it improves at least one objective\n            if (after_cost1 < before_cost1) or (after_cost2 < before_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Select a node to insert\n        node = random.choice(new_solution)\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(1, n):\n            # Calculate insertion cost for both objectives\n            cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]] - distance_matrix_1[new_solution[pos-1], new_solution[pos]]\n            cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]] - distance_matrix_2[new_solution[pos-1], new_solution[pos]]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Perform the insertion\n        new_solution = np.insert(new_solution, best_pos, node)\n        # Remove the original node (keeping the same length)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic edge insertion to explore high-quality solutions by intelligently inverting segments and strategically inserting edges while maintaining feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Remove edge between i and i+1, insert between j and j+1\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7881612224889305,
            0.6810866594314575
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Remove edge between i and i+1, insert between j and j+1\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{A novel multi-objective local search strategy that combines adaptive path relinking with objective-aware node insertion, where a high-performing solution from the archive is modified by strategically inserting nodes from a reference solution while evaluating the impact on both objectives and ensuring feasibility through a dynamic reordering mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a reference solution (could be the best or a random one)\n    reference_sol = random.choice([sol for sol, _ in archive])\n    base_sol = archive[0][0].copy()\n\n    n = len(base_sol)\n    new_solution = base_sol.copy()\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Select a node from reference solution not in base solution\n        available_nodes = [node for node in reference_sol if node not in base_sol]\n        if not available_nodes:\n            break\n\n        selected_node = random.choice(available_nodes)\n\n        # Find best insertion position based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.insert(base_sol, i, selected_node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Insert the best node\n        base_sol = np.insert(base_sol, best_pos, selected_node)\n\n    # Dynamic reordering to ensure feasibility\n    unique_nodes = np.unique(base_sol)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by removing excess nodes\n        seen = set()\n        new_solution = []\n        for node in base_sol:\n            if node not in seen:\n                seen.add(node)\n                new_solution.append(node)\n        new_solution = np.array(new_solution)\n\n        # Add missing nodes\n        missing_nodes = [i for i in range(n) if i not in seen]\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n",
        "score": [
            -0.8800591107242823,
            0.9559659957885742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a reference solution (could be the best or a random one)\n    reference_sol = random.choice([sol for sol, _ in archive])\n    base_sol = archive[0][0].copy()\n\n    n = len(base_sol)\n    new_solution = base_sol.copy()\n\n    # Objective-aware node insertion\n    for _ in range(2):\n        # Select a node from reference solution not in base solution\n        available_nodes = [node for node in reference_sol if node not in base_sol]\n        if not available_nodes:\n            break\n\n        selected_node = random.choice(available_nodes)\n\n        # Find best insertion position based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.insert(base_sol, i, selected_node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Insert the best node\n        base_sol = np.insert(base_sol, best_pos, selected_node)\n\n    # Dynamic reordering to ensure feasibility\n    unique_nodes = np.unique(base_sol)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by removing excess nodes\n        seen = set()\n        new_solution = []\n        for node in base_sol:\n            if node not in seen:\n                seen.add(node)\n                new_solution.append(node)\n        new_solution = np.array(new_solution)\n\n        # Add missing nodes\n        missing_nodes = [i for i in range(n) if i not in seen]\n        new_solution = np.concatenate([new_solution, missing_nodes])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment inversion with dynamic edge flipping to explore the solution space, using a score function that balances improvement potential and solution diversity to guide the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% solutions by combined objective score\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = archive_solutions[:max(1, len(archive_solutions) // 5)]\n    selected_sol = random.choice(top_solutions)[0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge flipping with objective-aware selection\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if new_cost < old_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7214082581821679,
            0.7971469759941101
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% solutions by combined objective score\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = archive_solutions[:max(1, len(archive_solutions) // 5)]\n    selected_sol = random.choice(top_solutions)[0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge flipping with objective-aware selection\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            # Calculate potential improvement\n            old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]])\n\n            if new_cost < old_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion and dynamic segment swapping, where a high-performing solution from the archive is modified by strategically replacing, inverting, and swapping segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism with probabilistic segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive with probability based on Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choices(archive_solutions, weights=[1/(i+1) for i in range(len(archive_solutions))], k=1)[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion and swapping\n    for _ in range(3):\n        # Select a random segment from random solution with adaptive length\n        segment_length = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - segment_length)\n        segment = random_sol[a:a+segment_length]\n\n        # Optionally invert or swap the segment\n        if random.random() < 0.3:\n            segment = segment[::-1]\n        elif random.random() < 0.3:\n            segment = np.concatenate([segment[segment_length//2:], segment[:segment_length//2]])\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + 0.3*cost2  # Weighted sum for multi-objective\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism with probabilistic segment replacement\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if random.random() < 0.7:  # Higher probability of replacing with missing node\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8679076782527173,
            9.353515982627869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive with probability based on Pareto dominance\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choices(archive_solutions, weights=[1/(i+1) for i in range(len(archive_solutions))], k=1)[0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion and swapping\n    for _ in range(3):\n        # Select a random segment from random solution with adaptive length\n        segment_length = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - segment_length)\n        segment = random_sol[a:a+segment_length]\n\n        # Optionally invert or swap the segment\n        if random.random() < 0.3:\n            segment = segment[::-1]\n        elif random.random() < 0.3:\n            segment = np.concatenate([segment[segment_length//2:], segment[:segment_length//2]])\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + 0.3*cost2  # Weighted sum for multi-objective\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism with probabilistic segment replacement\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if random.random() < 0.7:  # Higher probability of replacing with missing node\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This novel hybrid local search strategy combines multi-objective segment reordering with adaptive node clustering, where a high-performing solution from the archive is modified by strategically reordering segments based on their spatial proximity in both objective spaces while dynamically clustering nodes to maintain solution quality and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objective spaces\n    clusters = []\n    for i in range(n):\n        node = new_solution[i]\n        coords1 = instance[node, :2]\n        coords2 = instance[node, 2:]\n\n        # Find nearest neighbor in both spaces\n        nearest1 = np.argmin(distance_matrix_1[node])\n        nearest2 = np.argmin(distance_matrix_2[node])\n\n        # Create cluster based on spatial proximity\n        cluster = {node, nearest1, nearest2}\n        clusters.append(cluster)\n\n    # Multi-objective segment reordering\n    for _ in range(2):\n        # Select a random cluster\n        cluster = random.choice(clusters)\n        cluster_indices = [i for i, node in enumerate(new_solution) if node in cluster]\n\n        if len(cluster_indices) < 2:\n            continue\n\n        # Select two random positions within the cluster\n        i, j = sorted(random.sample(cluster_indices, 2))\n\n        # Reorder the segment between these positions\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8931026754624506,
            3.8980789184570312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objective spaces\n    clusters = []\n    for i in range(n):\n        node = new_solution[i]\n        coords1 = instance[node, :2]\n        coords2 = instance[node, 2:]\n\n        # Find nearest neighbor in both spaces\n        nearest1 = np.argmin(distance_matrix_1[node])\n        nearest2 = np.argmin(distance_matrix_2[node])\n\n        # Create cluster based on spatial proximity\n        cluster = {node, nearest1, nearest2}\n        clusters.append(cluster)\n\n    # Multi-objective segment reordering\n    for _ in range(2):\n        # Select a random cluster\n        cluster = random.choice(clusters)\n        cluster_indices = [i for i, node in enumerate(new_solution) if node in cluster]\n\n        if len(cluster_indices) < 2:\n            continue\n\n        # Select two random positions within the cluster\n        i, j = sorted(random.sample(cluster_indices, 2))\n\n        # Reorder the segment between these positions\n        segment = new_solution[i:j]\n        new_solution[i:j] = segment[::-1]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective node swapping with adaptive path reconfiguration, where a high-performing solution is modified by strategically swapping segments of nodes and then reconfiguring paths based on the combined objectives, while ensuring feasibility through a dynamic node replacement mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective node swapping\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive path reconfiguration\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Decide whether to invert based on combined cost\n        if random.random() < 0.7 * (segment_cost1 + segment_cost2) / (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]):\n            segment = segment[::-1]\n\n        new_solution[a:b] = segment\n\n    # Dynamic node replacement\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8722884651315969,
            0.5503553152084351
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective node swapping\n    for _ in range(3):\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Adaptive path reconfiguration\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Decide whether to invert based on combined cost\n        if random.random() < 0.7 * (segment_cost1 + segment_cost2) / (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_2[segment[-1], segment[0]]):\n            segment = segment[::-1]\n\n        new_solution[a:b] = segment\n\n    # Dynamic node replacement\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm employs a novel multi-objective adaptive segment relocation strategy that combines segment displacement from a reference solution with dynamic segment inversion, where segments are strategically moved and inverted based on their potential to improve both objectives, while maintaining feasibility through an adaptive repair mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    reference_sol = np.random.permutation(new_solution)\n\n    # Multi-objective adaptive segment relocation\n    for _ in range(3):\n        # Select a segment from reference solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = reference_sol[a:b]\n\n        # Adaptive segment inversion based on objective improvements\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best relocation point considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by swapping with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0057333675591393,
            6.845346510410309
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    reference_sol = np.random.permutation(new_solution)\n\n    # Multi-objective adaptive segment relocation\n    for _ in range(3):\n        # Select a segment from reference solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = reference_sol[a:b]\n\n        # Adaptive segment inversion based on objective improvements\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best relocation point considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by swapping with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{An adaptive multi-objective tour fragmentation and reassembly strategy that combines dynamic segment decomposition with intelligent sub-sequence reinsertion, where a high-performing solution from the archive is disassembled into critical fragments based on their contribution to each objective, then selectively reassembled to create a new tour while maintaining feasibility through a constraint-aware insertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment decomposition based on objective contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate contribution to each objective\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        # Decide whether to add to current segment or start new segment\n        if random.random() < 0.3 or (current_cost1 + current_cost2) > 1.5 * np.mean(distance_matrix_1) + np.mean(distance_matrix_2):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Shuffle segments to create diversity\n    random.shuffle(segments)\n\n    # Intelligent sub-sequence reinsertion\n    new_solution = []\n    remaining_segments = segments.copy()\n\n    while remaining_segments:\n        # Select a segment to insert\n        seg = remaining_segments.pop(0)\n\n        if not new_solution:\n            new_solution = seg\n            continue\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution) + 1):\n            # Try inserting segment at position i\n            candidate = new_solution[:i] + seg + new_solution[i:]\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n\n            # Use weighted sum of objectives as score\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = new_solution[:best_pos] + seg + new_solution[best_pos:]\n\n    # Ensure all nodes are present (repair if necessary)\n    unique_nodes = set(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(len(new_solution)):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8508209299646168,
            11.66096580028534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Dynamic segment decomposition based on objective contribution\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate contribution to each objective\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        # Decide whether to add to current segment or start new segment\n        if random.random() < 0.3 or (current_cost1 + current_cost2) > 1.5 * np.mean(distance_matrix_1) + np.mean(distance_matrix_2):\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Shuffle segments to create diversity\n    random.shuffle(segments)\n\n    # Intelligent sub-sequence reinsertion\n    new_solution = []\n    remaining_segments = segments.copy()\n\n    while remaining_segments:\n        # Select a segment to insert\n        seg = remaining_segments.pop(0)\n\n        if not new_solution:\n            new_solution = seg\n            continue\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution) + 1):\n            # Try inserting segment at position i\n            candidate = new_solution[:i] + seg + new_solution[i:]\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n\n            # Use weighted sum of objectives as score\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = new_solution[:best_pos] + seg + new_solution[best_pos:]\n\n    # Ensure all nodes are present (repair if necessary)\n    unique_nodes = set(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(len(new_solution)):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently inverting segments of the tour and strategically inserting nodes while maintaining feasibility and promoting diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective (simple selection strategy)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = archive_sorted[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(2):\n        node_pos = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n        if node_pos != new_pos:\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7731612086211068,
            0.6356268525123596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective (simple selection strategy)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = archive_sorted[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(2):\n        node_pos = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n        if node_pos != new_pos:\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path reversal with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently reversing segments of the tour and inserting nodes in optimal positions while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path reversal\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_pos = random.randint(0, n - 1)\n        insert_pos = random.randint(0, n - 1)\n        if node_pos != insert_pos:\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7992742982976363,
            0.5763095021247864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path reversal\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_pos = random.randint(0, n - 1)\n        insert_pos = random.randint(0, n - 1)\n        if node_pos != insert_pos:\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore diverse solutions by intelligently inverting segments and inserting nodes while maintaining feasibility and balancing improvement in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i < j - 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8325223614078965,
            0.49976181983947754
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if i < j - 1:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive k-segment rearrangement with dynamic edge perturbation to explore high-quality solutions by intelligently selecting and rearranging multiple segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    k = max(2, min(4, n // 3))\n    segment_size = max(2, n // k)\n\n    # Adaptive k-segment rearrangement\n    segments = []\n    for _ in range(k):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        segments.append((start, end))\n\n    # Sort segments by start position\n    segments.sort()\n\n    # Create a new order for segments\n    new_order = list(range(k))\n    random.shuffle(new_order)\n\n    # Rearrange segments\n    temp_solution = np.zeros_like(new_solution)\n    pos = 0\n    for i in new_order:\n        start, end = segments[i]\n        temp_solution[pos:pos+(end-start)] = new_solution[start:end]\n        pos += (end-start)\n\n    new_solution = temp_solution\n\n    # Dynamic edge perturbation\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Randomly choose between reversal and rotation\n            if random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                shift = random.randint(1, j-i-1)\n                new_solution[i:j] = np.roll(new_solution[i:j], shift)\n\n    return new_solution\n\n",
        "score": [
            -0.9466918307743583,
            0.0542217493057251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    k = max(2, min(4, n // 3))\n    segment_size = max(2, n // k)\n\n    # Adaptive k-segment rearrangement\n    segments = []\n    for _ in range(k):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        segments.append((start, end))\n\n    # Sort segments by start position\n    segments.sort()\n\n    # Create a new order for segments\n    new_order = list(range(k))\n    random.shuffle(new_order)\n\n    # Rearrange segments\n    temp_solution = np.zeros_like(new_solution)\n    pos = 0\n    for i in new_order:\n        start, end = segments[i]\n        temp_solution[pos:pos+(end-start)] = new_solution[start:end]\n        pos += (end-start)\n\n    new_solution = temp_solution\n\n    # Dynamic edge perturbation\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Randomly choose between reversal and rotation\n            if random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                shift = random.randint(1, j-i-1)\n                new_solution[i:j] = np.roll(new_solution[i:j], shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment relocation with adaptive segment permutation, where a high-performing solution from the archive is modified by strategically relocating and permuting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment relocation with permutation\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally permute the segment\n        if random.random() < 0.7:\n            segment = np.random.permutation(segment)\n\n        # Find best relocation point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate segment to position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8986565826468926,
            7.091184616088867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment relocation with permutation\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally permute the segment\n        if random.random() < 0.7:\n            segment = np.random.permutation(segment)\n\n        # Find best relocation point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate segment to position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{An enhanced hybrid local search algorithm that uses adaptive segment reshuffling with dynamic edge refinement, incorporating objective-aware segment selection and diversity-preserving edge swaps to generate high-quality neighbors in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (lowest objective values)\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment reshuffling with objective-aware selection\n    for _ in range(3):\n        # Select segments based on both objective spaces\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure non-overlapping segments\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap segments with probability based on objective improvement potential\n        if random.random() < 0.7:\n            seg1 = new_solution[seg1_start:seg1_end]\n            seg2 = new_solution[seg2_start:seg2_end]\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge refinement with diversity preservation\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure valid swap that maintains tour feasibility\n        if (j - i) > 1:\n            # Reverse segment with probability based on objective improvement\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8454098680670352,
            0.06642377376556396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (lowest objective values)\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment reshuffling with objective-aware selection\n    for _ in range(3):\n        # Select segments based on both objective spaces\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure non-overlapping segments\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap segments with probability based on objective improvement potential\n        if random.random() < 0.7:\n            seg1 = new_solution[seg1_start:seg1_end]\n            seg2 = new_solution[seg2_start:seg2_end]\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge refinement with diversity preservation\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure valid swap that maintains tour feasibility\n        if (j - i) > 1:\n            # Reverse segment with probability based on objective improvement\n            if random.random() < 0.6:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{An adaptive multi-objective local search strategy that combines solution blending with dynamic segment permutation, where a high-performing solution from the archive is modified by blending segments from multiple solutions while adaptively permuting and evaluating segments based on their Pareto dominance in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 3 non-dominated solutions from the archive\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    selected_sol = random.choice(non_dominated)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Blend segments from multiple solutions\n    for _ in range(3):\n        other_sol = random.choice(non_dominated)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_sol[a:b]\n\n        # Adaptive permutation based on objective dominance\n        if random.random() < 0.7:  # Higher probability to preserve order\n            segment = segment[::-1] if random.random() < 0.3 else segment\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair with objective-aware swaps\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            # Find best swap considering both objectives\n            best_swap = None\n            best_swap_cost = float('inf')\n\n            for j in range(n):\n                if new_solution[j] in missing_nodes:\n                    # Temporarily swap\n                    temp_sol = new_solution.copy()\n                    temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                    cost1 = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(1, n+1))\n                    cost2 = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(1, n+1))\n                    total_cost = cost1 + cost2\n\n                    if total_cost < best_swap_cost:\n                        best_swap_cost = total_cost\n                        best_swap = j\n\n            if best_swap is not None:\n                new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n                missing_nodes.remove(new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.9156272522369127,
            9.472775876522064
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 3 non-dominated solutions from the archive\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    selected_sol = random.choice(non_dominated)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Blend segments from multiple solutions\n    for _ in range(3):\n        other_sol = random.choice(non_dominated)\n        a, b = sorted(random.sample(range(n), 2))\n        segment = other_sol[a:b]\n\n        # Adaptive permutation based on objective dominance\n        if random.random() < 0.7:  # Higher probability to preserve order\n            segment = segment[::-1] if random.random() < 0.3 else segment\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair with objective-aware swaps\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            # Find best swap considering both objectives\n            best_swap = None\n            best_swap_cost = float('inf')\n\n            for j in range(n):\n                if new_solution[j] in missing_nodes:\n                    # Temporarily swap\n                    temp_sol = new_solution.copy()\n                    temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n                    cost1 = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(1, n+1))\n                    cost2 = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(1, n+1))\n                    total_cost = cost1 + cost2\n\n                    if total_cost < best_swap_cost:\n                        best_swap_cost = total_cost\n                        best_swap = j\n\n            if best_swap is not None:\n                new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n                missing_nodes.remove(new_solution[i])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{A novel hybrid local search strategy that combines Pareto-optimal segment swapping with adaptive node reallocation, where a high-performing solution from the archive is modified by strategically swapping segments from non-dominated solutions and reallocating nodes to improve both objectives, while ensuring feasibility through a dynamic permutation repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Find non-dominated solutions in the archive\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(archive_solutions[i])\n\n    if non_dominated:\n        donor_sol = random.choice(non_dominated)\n    else:\n        donor_sol = random.choice(archive_solutions)\n\n    # Pareto-optimal segment swapping\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = donor_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive node reallocation\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic permutation repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0072892739387844,
            4.5396957993507385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Find non-dominated solutions in the archive\n    objectives = [obj for _, obj in archive]\n    non_dominated = []\n    for i, (obj1, obj2) in enumerate(objectives):\n        dominated = False\n        for j, (other_obj1, other_obj2) in enumerate(objectives):\n            if i != j and other_obj1 <= obj1 and other_obj2 <= obj2 and (other_obj1 < obj1 or other_obj2 < obj2):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(archive_solutions[i])\n\n    if non_dominated:\n        donor_sol = random.choice(non_dominated)\n    else:\n        donor_sol = random.choice(archive_solutions)\n\n    # Pareto-optimal segment swapping\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        segment = donor_sol[a:b]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive node reallocation\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic permutation repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective node swapping with adaptive path inversion, where a high-performing solution from the archive is modified by strategically swapping nodes based on their relative performance in both objectives and conditionally inverting entire paths to explore diverse neighborhoods while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    objectives = [obj for _, obj in archive]\n\n    # Multi-objective node swapping\n    for _ in range(3):\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                # Replace with a random missing node\n                missing_nodes = [node for node in range(n) if node not in new_solution]\n                if missing_nodes:\n                    new_solution[i] = random.choice(missing_nodes)\n\n    return new_solution\n\n",
        "score": [
            -0.9130604811941517,
            0.5509363412857056
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    objectives = [obj for _, obj in archive]\n\n    # Multi-objective node swapping\n    for _ in range(3):\n        # Select two nodes to swap\n        i, j = random.sample(range(n), 2)\n\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Adaptive path inversion\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        for i in range(n):\n            if new_solution[i] in new_solution[:i]:\n                # Replace with a random missing node\n                missing_nodes = [node for node in range(n) if node not in new_solution]\n                if missing_nodes:\n                    new_solution[i] = random.choice(missing_nodes)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path insertion with adaptive segment rotation, where a high-performing solution from the archive is modified by strategically inserting segments from a random solution while rotating segments to explore diverse configurations, with feasibility maintained through a dynamic repair mechanism and evaluated for both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Generate a random solution for segment insertion\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path insertion with segment rotation\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Rotate the segment to explore different configurations\n        rotation = random.randint(0, len(segment)-1)\n        segment = np.roll(segment, rotation)\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment) + 1):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8576226359117338,
            6.735371172428131
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Generate a random solution for segment insertion\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective path insertion with segment rotation\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Rotate the segment to explore different configurations\n        rotation = random.randint(0, len(segment)-1)\n        segment = np.roll(segment, rotation)\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment) + 1):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This novel hybrid local search strategy combines adaptive segment inversion with dynamic node insertion to explore high-quality solutions by intelligently inverting segments of the tour and inserting nodes at positions that improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.7221993048154073,
            0.4967532753944397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node reinsertion with dynamic path optimization to explore high-quality solutions by intelligently reinserting nodes and optimizing paths while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_sol = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_sol.copy()\n\n    # Determine the number of nodes to reinsert\n    n = len(new_solution)\n    num_reinsert = max(2, min(5, n // 3))\n\n    # Adaptive node reinsertion\n    for _ in range(2):\n        # Select a random segment to remove\n        seg_start = random.randint(0, n - num_reinsert)\n        seg_end = seg_start + num_reinsert\n        removed_nodes = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Reinsert nodes at a new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], removed_nodes, new_solution[insert_pos:]])\n\n    # Dynamic path optimization\n    for _ in range(3):\n        # Select a random path to optimize\n        path_start = random.randint(0, len(new_solution) - 3)\n        path_end = random.randint(path_start + 2, min(path_start + 5, len(new_solution) - 1))\n\n        # Reverse the path segment if it improves the combined cost\n        current_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + \\\n                       sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n        reversed_path = new_solution[path_start:path_end+1][::-1]\n        new_path = np.concatenate([new_solution[:path_start], reversed_path, new_solution[path_end+1:]])\n\n        new_cost = sum(distance_matrix_1[new_path[i-1], new_path[i]] for i in range(1, len(new_path))) + \\\n                   sum(distance_matrix_2[new_path[i-1], new_path[i]] for i in range(1, len(new_path)))\n\n        if new_cost < current_cost:\n            new_solution = new_path\n\n    return new_solution\n\n",
        "score": [
            -0.7212194975132799,
            0.7375022768974304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    selected_sol = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_sol.copy()\n\n    # Determine the number of nodes to reinsert\n    n = len(new_solution)\n    num_reinsert = max(2, min(5, n // 3))\n\n    # Adaptive node reinsertion\n    for _ in range(2):\n        # Select a random segment to remove\n        seg_start = random.randint(0, n - num_reinsert)\n        seg_end = seg_start + num_reinsert\n        removed_nodes = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Reinsert nodes at a new position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], removed_nodes, new_solution[insert_pos:]])\n\n    # Dynamic path optimization\n    for _ in range(3):\n        # Select a random path to optimize\n        path_start = random.randint(0, len(new_solution) - 3)\n        path_end = random.randint(path_start + 2, min(path_start + 5, len(new_solution) - 1))\n\n        # Reverse the path segment if it improves the combined cost\n        current_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution))) + \\\n                       sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, len(new_solution)))\n        reversed_path = new_solution[path_start:path_end+1][::-1]\n        new_path = np.concatenate([new_solution[:path_start], reversed_path, new_solution[path_end+1:]])\n\n        new_cost = sum(distance_matrix_1[new_path[i-1], new_path[i]] for i in range(1, len(new_path))) + \\\n                   sum(distance_matrix_2[new_path[i-1], new_path[i]] for i in range(1, len(new_path)))\n\n        if new_cost < current_cost:\n            new_solution = new_path\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with dynamic node relocation to explore high-quality solutions in both objective spaces by intelligently repositioning segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment insertion\n    for _ in range(2):\n        # Select a segment and a target position\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        target_pos = random.randint(0, n - segment_size)\n\n        # Extract and remove the segment\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert the segment at the target position\n        new_solution = np.concatenate([new_solution[:target_pos], segment, new_solution[target_pos:]])\n\n    # Dynamic node relocation for further refinement\n    for _ in range(3):\n        # Select a node and a new position\n        node_idx = random.randint(0, n - 1)\n        new_pos = random.randint(0, n - 1)\n\n        # Remove and reinsert the node\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7311531498064487,
            0.46774041652679443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment insertion\n    for _ in range(2):\n        # Select a segment and a target position\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        target_pos = random.randint(0, n - segment_size)\n\n        # Extract and remove the segment\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert the segment at the target position\n        new_solution = np.concatenate([new_solution[:target_pos], segment, new_solution[target_pos:]])\n\n    # Dynamic node relocation for further refinement\n    for _ in range(3):\n        # Select a node and a new position\n        node_idx = random.randint(0, n - 1)\n        new_pos = random.randint(0, n - 1)\n\n        # Remove and reinsert the node\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive route fragmentation with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently breaking and reassembling the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive route fragmentation\n    frag_size = max(2, n // 5)\n    frag_points = sorted(random.sample(range(1, n), 2))\n    frag_start, frag_end = frag_points\n\n    # Extract and remove a fragment\n    fragment = new_solution[frag_start:frag_end]\n    new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n\n    # Dynamic node insertion\n    for node in fragment:\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Local refinement with edge swaps\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8881950844408223,
            0.5829792022705078
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive route fragmentation\n    frag_size = max(2, n // 5)\n    frag_points = sorted(random.sample(range(1, n), 2))\n    frag_start, frag_end = frag_points\n\n    # Extract and remove a fragment\n    fragment = new_solution[frag_start:frag_end]\n    new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n\n    # Dynamic node insertion\n    for node in fragment:\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Local refinement with edge swaps\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment swapping with adaptive segment rotation, where a high-performing solution from the archive is modified by strategically swapping segments with a random solution and rotating segments based on their multi-objective performance, while ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment swapping with rotation\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Calculate segment's cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[random_sol[j-1], random_sol[j]] for j in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[random_sol[j-1], random_sol[j]] for j in range(a, b+1))\n        total_seg_cost = seg_cost1 + seg_cost2\n\n        # Decide rotation based on segment's performance\n        if seg_cost1 > seg_cost2:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8651865277577027,
            4.098311007022858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment swapping with rotation\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Calculate segment's cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[random_sol[j-1], random_sol[j]] for j in range(a, b+1))\n        seg_cost2 = sum(distance_matrix_2[random_sol[j-1], random_sol[j]] for j in range(a, b+1))\n        total_seg_cost = seg_cost1 + seg_cost2\n\n        # Decide rotation based on segment's performance\n        if seg_cost1 > seg_cost2:\n            segment = np.roll(segment, 1)\n        else:\n            segment = np.roll(segment, -1)\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{A novel adaptive segment exchange algorithm that intelligently selects segments from high-performing solutions and exchanges them with segments from randomly chosen solutions, while dynamically balancing the impact on both objectives through a weighted cost evaluation and ensuring feasibility through a segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment exchange with weighted cost evaluation\n    for _ in range(3):\n        # Select a segment from selected_sol\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find best matching segment in random_sol\n        best_segment = None\n        best_weighted_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate_segment = random_sol[i:i+len(segment)]\n            if len(np.unique(candidate_segment)) != len(segment):\n                continue\n\n            # Calculate weighted cost\n            cost1 = sum(distance_matrix_1[candidate_segment[j-1], candidate_segment[j]] for j in range(1, len(candidate_segment)))\n            cost2 = sum(distance_matrix_2[candidate_segment[j-1], candidate_segment[j]] for j in range(1, len(candidate_segment)))\n            weighted_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if weighted_cost < best_weighted_cost:\n                best_weighted_cost = weighted_cost\n                best_segment = candidate_segment\n\n        if best_segment is not None:\n            # Replace the segment in new_solution\n            new_solution[a:b] = best_segment\n\n    # Segment validation mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8960209177401992,
            2.1706092953681946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment exchange with weighted cost evaluation\n    for _ in range(3):\n        # Select a segment from selected_sol\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find best matching segment in random_sol\n        best_segment = None\n        best_weighted_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            candidate_segment = random_sol[i:i+len(segment)]\n            if len(np.unique(candidate_segment)) != len(segment):\n                continue\n\n            # Calculate weighted cost\n            cost1 = sum(distance_matrix_1[candidate_segment[j-1], candidate_segment[j]] for j in range(1, len(candidate_segment)))\n            cost2 = sum(distance_matrix_2[candidate_segment[j-1], candidate_segment[j]] for j in range(1, len(candidate_segment)))\n            weighted_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if weighted_cost < best_weighted_cost:\n                best_weighted_cost = weighted_cost\n                best_segment = candidate_segment\n\n        if best_segment is not None:\n            # Replace the segment in new_solution\n            new_solution[a:b] = best_segment\n\n    # Segment validation mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A novel adaptive multi-objective local search strategy that combines segment-based crossover with dynamic objective-aware inversion, where a high-performing solution is modified by strategically inserting and inverting segments from a diverse solution, while evaluating the impact on both objectives and ensuring feasibility through an adaptive repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment-based crossover with inversion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Objective-aware inversion\n        if random.random() < 0.7:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n            # Invert if it improves both objectives\n            if seg_cost1 > distance_matrix_1[segment[-1], segment[0]] and seg_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8175077192684403,
            6.032643020153046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment-based crossover with inversion\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Objective-aware inversion\n        if random.random() < 0.7:\n            # Calculate segment costs\n            seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n            # Invert if it improves both objectives\n            if seg_cost1 > distance_matrix_1[segment[-1], segment[0]] and seg_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n                segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Adaptive repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective path relinking with adaptive node swapping, where a high-performing solution from the archive is modified by strategically relinking segments from a random solution while adaptively swapping nodes based on their dominance in both objective spaces, ensuring feasibility through a dynamic repair mechanism and evaluating the impact on both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution in the archive based on the sum of objectives\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Create a random solution for path relinking\n    random_sol = np.random.permutation(best_solution)\n\n    # Initialize new solution\n    new_solution = best_solution.copy()\n\n    # Path relinking with adaptive node swapping\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            node_a = new_solution[i]\n            node_b = random_sol[i]\n\n            # Check dominance in both objectives\n            cost_a1 = distance_matrix_1[new_solution[i-1], node_a] + distance_matrix_1[node_a, new_solution[(i+1)%n]]\n            cost_a2 = distance_matrix_2[new_solution[i-1], node_a] + distance_matrix_2[node_a, new_solution[(i+1)%n]]\n            cost_b1 = distance_matrix_1[new_solution[i-1], node_b] + distance_matrix_1[node_b, new_solution[(i+1)%n]]\n            cost_b2 = distance_matrix_2[new_solution[i-1], node_b] + distance_matrix_2[node_b, new_solution[(i+1)%n]]\n\n            # Adaptive swapping based on dominance\n            if (cost_b1 < cost_a1 and cost_b2 < cost_a2) or (random.random() < 0.2):  # 20% chance to accept non-dominant swaps\n                # Perform the swap\n                idx_a = np.where(new_solution == node_a)[0][0]\n                idx_b = np.where(new_solution == node_b)[0][0]\n                new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8852114706251848,
            0.5468762516975403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution in the archive based on the sum of objectives\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(best_solution)\n\n    # Create a random solution for path relinking\n    random_sol = np.random.permutation(best_solution)\n\n    # Initialize new solution\n    new_solution = best_solution.copy()\n\n    # Path relinking with adaptive node swapping\n    for i in range(n):\n        if random.random() < 0.3:  # 30% chance to consider swapping\n            node_a = new_solution[i]\n            node_b = random_sol[i]\n\n            # Check dominance in both objectives\n            cost_a1 = distance_matrix_1[new_solution[i-1], node_a] + distance_matrix_1[node_a, new_solution[(i+1)%n]]\n            cost_a2 = distance_matrix_2[new_solution[i-1], node_a] + distance_matrix_2[node_a, new_solution[(i+1)%n]]\n            cost_b1 = distance_matrix_1[new_solution[i-1], node_b] + distance_matrix_1[node_b, new_solution[(i+1)%n]]\n            cost_b2 = distance_matrix_2[new_solution[i-1], node_b] + distance_matrix_2[node_b, new_solution[(i+1)%n]]\n\n            # Adaptive swapping based on dominance\n            if (cost_b1 < cost_a1 and cost_b2 < cost_a2) or (random.random() < 0.2):  # 20% chance to accept non-dominant swaps\n                # Perform the swap\n                idx_a = np.where(new_solution == node_a)[0][0]\n                idx_b = np.where(new_solution == node_b)[0][0]\n                new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion and weighted objective evaluation, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives with a weighted score function to balance improvement across objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion and weighted evaluation\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n\n            # Weighted score function (adjust weights as needed)\n            weight1 = 0.6\n            weight2 = 0.4\n            score = weight1 * cost1 + weight2 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9961392172320761,
            6.023372709751129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion and weighted evaluation\n    for _ in range(3):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n\n            # Weighted score function (adjust weights as needed)\n            weight1 = 0.6\n            weight2 = 0.4\n            score = weight1 * cost1 + weight2 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This novel algorithm combines adaptive segment reassembly with multi-objective edge reinforcement, where segments from a high-performing solution are strategically reassembled while dynamically reinforcing edges that show promise in both objective spaces, ensuring feasibility through a hybrid validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reassembly\n    segment_size = max(2, min(5, n // 3))\n    for _ in range(3):\n        # Select a segment and its new position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find best position for the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Temporarily insert segment\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective edge reinforcement\n    for _ in range(2):\n        # Select two edges to potentially reinforce\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]]\n\n        # Calculate potential new edges\n        new_edges = [(new_solution[i], new_solution[k]), (new_solution[j], new_solution[l])]\n        new_cost1 = distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]\n        new_cost2 = distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]\n\n        # Reinforce if better in both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n            # Swap the edges\n            temp = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n    # Hybrid validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9159227637179764,
            5.755742013454437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive segment reassembly\n    segment_size = max(2, min(5, n // 3))\n    for _ in range(3):\n        # Select a segment and its new position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Find best position for the segment\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Temporarily insert segment\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective edge reinforcement\n    for _ in range(2):\n        # Select two edges to potentially reinforce\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]]\n\n        # Calculate potential new edges\n        new_edges = [(new_solution[i], new_solution[k]), (new_solution[j], new_solution[l])]\n        new_cost1 = distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]\n        new_cost2 = distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]\n\n        # Reinforce if better in both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n            # Swap the edges\n            temp = new_solution[j]\n            new_solution[j] = new_solution[k]\n            new_solution[k] = temp\n\n    # Hybrid validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions by intelligently relocating nodes and reversing segments while balancing improvements in both objective spaces through adaptive selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower costs)\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path reversal with segment selection\n    for _ in range(2):\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8243210474148187,
            0.5055961012840271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower costs)\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path reversal with segment selection\n    for _ in range(2):\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This algorithm selects a solution from the archive, applies a dynamic segment inversion and edge optimization strategy to generate a neighbor solution while ensuring feasibility through adaptive segment size and non-overlapping constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    segment_size = max(3, n // 5)\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge optimization with feasibility check\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            if len(segment) > 2:\n                new_solution[i:j] = np.concatenate([segment[-1:], segment[1:-1], segment[:1]])\n\n    return new_solution\n\n",
        "score": [
            -0.7675286802799601,
            0.4850733280181885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    segment_size = max(3, n // 5)\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Edge optimization with feasibility check\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n            if len(segment) > 2:\n                new_solution[i:j] = np.concatenate([segment[-1:], segment[1:-1], segment[:1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive k-opt moves with multi-objective edge evaluation to explore the solution space by dynamically selecting and rearranging segments of the tour while considering both objectives and maintaining feasibility through constrained optimization techniques.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (lowest cost in either objective)\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: min(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move selection\n    k = random.randint(3, min(5, n // 2))\n    indices = sorted(random.sample(range(n), k))\n\n    # Create new segments by rotating the selected nodes\n    segment = new_solution[indices[0]:indices[-1]+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[indices[0]:indices[-1]+1] = rotated_segment\n\n    # Multi-objective edge evaluation and swap\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate edge quality based on both objectives\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.3755375621505652,
            0.4854586124420166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (lowest cost in either objective)\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: min(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move selection\n    k = random.randint(3, min(5, n // 2))\n    indices = sorted(random.sample(range(n), k))\n\n    # Create new segments by rotating the selected nodes\n    segment = new_solution[indices[0]:indices[-1]+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[indices[0]:indices[-1]+1] = rotated_segment\n\n    # Multi-objective edge evaluation and swap\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate edge quality based on both objectives\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < current_cost:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0655273414225888,
            0.8925878405570984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0655273414225888,
            0.8925878405570984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{A novel hybrid local search strategy that combines dynamic path decomposition with adaptive node insertion, where a high-performing solution is decomposed into multiple paths, strategically reinserted nodes from these paths into the tour while evaluating the impact on both objectives, and ensuring feasibility through a node replacement mechanism with cost-aware selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on combined objective cost\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol = min(archive_solutions, key=lambda x: sum(x[1]))[0]\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Dynamic path decomposition\n    num_paths = random.randint(2, min(5, n // 2))\n    path_lengths = sorted(random.sample(range(2, n - num_paths + 1), num_paths - 1))\n    path_lengths = [0] + path_lengths + [n]\n    paths = [new_solution[path_lengths[i]:path_lengths[i+1]] for i in range(num_paths)]\n\n    # Adaptive node insertion with cost-aware selection\n    for _ in range(3):\n        # Select a random path and a random node from it\n        path_idx = random.randint(0, num_paths - 1)\n        if len(paths[path_idx]) < 2:\n            continue\n        node_idx = random.randint(0, len(paths[path_idx]) - 1)\n        node = paths[path_idx][node_idx]\n\n        # Find best insertion position in the main tour\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.insert(new_solution, i, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Remove the node from its original path\n        paths[path_idx] = np.delete(paths[path_idx], node_idx)\n\n    # Node replacement mechanism to ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Replace duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7776781047521336,
            8.572396755218506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from the archive based on combined objective cost\n    archive_solutions = [(sol, obj) for sol, obj in archive]\n    selected_sol = min(archive_solutions, key=lambda x: sum(x[1]))[0]\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Dynamic path decomposition\n    num_paths = random.randint(2, min(5, n // 2))\n    path_lengths = sorted(random.sample(range(2, n - num_paths + 1), num_paths - 1))\n    path_lengths = [0] + path_lengths + [n]\n    paths = [new_solution[path_lengths[i]:path_lengths[i+1]] for i in range(num_paths)]\n\n    # Adaptive node insertion with cost-aware selection\n    for _ in range(3):\n        # Select a random path and a random node from it\n        path_idx = random.randint(0, num_paths - 1)\n        if len(paths[path_idx]) < 2:\n            continue\n        node_idx = random.randint(0, len(paths[path_idx]) - 1)\n        node = paths[path_idx][node_idx]\n\n        # Find best insertion position in the main tour\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n):\n            # Insert node at position i\n            candidate = np.insert(new_solution, i, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n        # Remove the node from its original path\n        paths[path_idx] = np.delete(paths[path_idx], node_idx)\n\n    # Node replacement mechanism to ensure feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Replace duplicates with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently reversing segments of the tour and inserting nodes while maintaining feasibility and diversity through adaptive segment selection and dynamic edge adjustments.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.852851288133603,
            0.476839542388916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment relocation with multi-objective segment inversion, where a high-performing solution from the archive is modified by strategically relocating and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism with probabilistic segment swapping.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment relocation with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best relocation point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate segment to position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism with probabilistic swapping\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by swapping with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    # Probabilistic segment swap for further improvement\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9079567749062025,
            3.8876572251319885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment relocation with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best relocation point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Relocate segment to position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Relocate the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism with probabilistic swapping\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by swapping with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            if missing_nodes:\n                new_solution[i] = missing_nodes.pop(0)\n\n    # Probabilistic segment swap for further improvement\n    if random.random() < 0.3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{A new algorithm that employs dynamic segment inversion with adaptive segment size and probabilistic edge reversal to explore diverse neighborhoods while balancing exploration and exploitation by leveraging both objective spaces' distance matrices for informed local search operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistic edge reversal\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            if i != j and abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8529113184354534,
            0.4876389503479004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistic edge reversal\n    for i in range(n):\n        if random.random() < 0.3:\n            j = random.randint(0, n-1)\n            if i != j and abs(i - j) > 1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This algorithm employs a novel multi-objective crossover-based local search that dynamically combines segments from two high-performing solutions using a Pareto-inspired selection criterion, followed by a probabilistic segment rotation operator to explore diverse neighborhoods while maintaining feasibility through a node-constraint repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two high-performing solutions from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) < 2:\n        selected_sols = [random.choice(archive_solutions), random.choice(archive_solutions)]\n    else:\n        selected_sols = random.sample(archive_solutions, 2)\n\n    sol1, sol2 = selected_sols\n    n = len(sol1)\n\n    # Pareto-inspired crossover\n    crossover_point = random.randint(1, n-1)\n    new_solution = np.concatenate([sol1[:crossover_point], sol2[crossover_point:]])\n\n    # Probabilistic segment rotation\n    if random.random() < 0.7:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Node-constraint repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8814938211586023,
            0.43164128065109253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two high-performing solutions from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) < 2:\n        selected_sols = [random.choice(archive_solutions), random.choice(archive_solutions)]\n    else:\n        selected_sols = random.sample(archive_solutions, 2)\n\n    sol1, sol2 = selected_sols\n    n = len(sol1)\n\n    # Pareto-inspired crossover\n    crossover_point = random.randint(1, n-1)\n    new_solution = np.concatenate([sol1[:crossover_point], sol2[crossover_point:]])\n\n    # Probabilistic segment rotation\n    if random.random() < 0.7:\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        rotated_segment = np.roll(segment, random.randint(1, segment_length-1))\n        new_solution[start:start+segment_length] = rotated_segment\n\n    # Node-constraint repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path inversion with dynamic segment rotation, intelligently inverts segments of the tour based on their combined objective impact while strategically rotating segments to explore diverse neighborhood structures, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive multi-objective path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment with probability based on its impact\n        if random.random() < (1 / (1 + seg_total)):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic segment rotation\n    for _ in range(2):\n        # Select a segment to rotate\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Rotate the segment by a random amount\n        rotation = random.randint(1, len(segment)-1)\n        new_segment = np.roll(segment, rotation)\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8295402547738985,
            0.5227487683296204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive multi-objective path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment with probability based on its impact\n        if random.random() < (1 / (1 + seg_total)):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic segment rotation\n    for _ in range(2):\n        # Select a segment to rotate\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Rotate the segment by a random amount\n        rotation = random.randint(1, len(segment)-1)\n        new_segment = np.roll(segment, rotation)\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with objective-aware edge replacement to explore high-quality solutions by intelligently reversing segments and replacing edges based on their contribution to both objectives, while maintaining feasibility and promoting diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion based on objective contributions\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate objective contributions of the segment\n            seg = new_solution[i:j]\n            cost1 = sum(distance_matrix_1[seg[k], seg[k+1]] for k in range(len(seg)-1)) + distance_matrix_1[seg[-1], seg[0]]\n            cost2 = sum(distance_matrix_2[seg[k], seg[k+1]] for k in range(len(seg)-1)) + distance_matrix_2[seg[-1], seg[0]]\n\n            # Invert segment if it improves at least one objective\n            if random.random() < 0.7 or cost1 > distance_matrix_1[seg[-1], seg[0]] or cost2 > distance_matrix_2[seg[-1], seg[0]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge replacement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i - j) > 1:\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Replace edges if it improves at least one objective\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7892234155622682,
            0.5089179277420044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion based on objective contributions\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate objective contributions of the segment\n            seg = new_solution[i:j]\n            cost1 = sum(distance_matrix_1[seg[k], seg[k+1]] for k in range(len(seg)-1)) + distance_matrix_1[seg[-1], seg[0]]\n            cost2 = sum(distance_matrix_2[seg[k], seg[k+1]] for k in range(len(seg)-1)) + distance_matrix_2[seg[-1], seg[0]]\n\n            # Invert segment if it improves at least one objective\n            if random.random() < 0.7 or cost1 > distance_matrix_1[seg[-1], seg[0]] or cost2 > distance_matrix_2[seg[-1], seg[0]]:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge replacement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and abs(i - j) > 1:\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Replace edges if it improves at least one objective\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism, with a focus on balancing exploration and exploitation through adaptive segment selection and inversion probabilities.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment replacement with inversion\n    for _ in range(3):\n        # Select a random segment from random solution with adaptive size\n        segment_size = min(n // 2, max(2, int(np.random.normal(n // 3, n // 6))))\n        a = random.randint(0, n - segment_size)\n        segment = random_sol[a:a+segment_size]\n\n        # Adaptively invert the segment\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost with weighted objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8915323733559536,
            6.294519424438477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Adaptive segment replacement with inversion\n    for _ in range(3):\n        # Select a random segment from random solution with adaptive size\n        segment_size = min(n // 2, max(2, int(np.random.normal(n // 3, n // 6))))\n        a = random.randint(0, n - segment_size)\n        segment = random_sol[a:a+segment_size]\n\n        # Adaptively invert the segment\n        if random.random() < 0.7:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost with weighted objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment rearrangement with dynamic edge optimization, using a weighted objective score to prioritize segments that show potential for improvement in both objective spaces while ensuring feasibility through constrained segment selection and edge flipping.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on weighted objective score\n    def objective_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]\n\n    archive_solutions = [(sol, objective_score(obj)) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: x[1])\n    selected_sol = archive_solutions[0][0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate potential improvement in both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try reversing the segment\n        temp_sol = new_solution.copy()\n        temp_sol[seg_start:seg_end] = temp_sol[seg_start:seg_end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n        new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n        if objective_score((new_cost1, new_cost2)) < objective_score((current_cost1, current_cost2)):\n            new_solution = temp_sol\n\n    # Dynamic edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            new_cost1 = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            if objective_score((new_cost1, new_cost2)) < objective_score((current_cost1, current_cost2)):\n                new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.6011994143949768,
            1.5437209010124207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on weighted objective score\n    def objective_score(obj):\n        return 0.6 * obj[0] + 0.4 * obj[1]\n\n    archive_solutions = [(sol, objective_score(obj)) for sol, obj in archive]\n    archive_solutions.sort(key=lambda x: x[1])\n    selected_sol = archive_solutions[0][0]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate potential improvement in both objectives\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try reversing the segment\n        temp_sol = new_solution.copy()\n        temp_sol[seg_start:seg_end] = temp_sol[seg_start:seg_end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n        new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n        if objective_score((new_cost1, new_cost2)) < objective_score((current_cost1, current_cost2)):\n            new_solution = temp_sol\n\n    # Dynamic edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = temp_sol[i:j][::-1]\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            current_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            new_cost1 = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            if objective_score((new_cost1, new_cost2)) < objective_score((current_cost1, current_cost2)):\n                new_solution = temp_sol\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{An adaptive multi-objective segment relocation strategy that combines dynamic segment extraction with objective-aware insertion, using a hybrid of Pareto-based selection and segment inversion to explore the solution space while maintaining feasibility through a probabilistic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Dynamic segment extraction and objective-aware insertion\n    for _ in range(3):\n        # Extract a random segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Optionally invert the segment\n        if random.random() < 0.4:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        temp_sol = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Find best insertion point based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([temp_sol[:i], segment, temp_sol[i:]])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n\n            # Use weighted sum of normalized costs\n            norm_cost1 = cost1 / distance_matrix_1.max()\n            norm_cost2 = cost2 / distance_matrix_2.max()\n            total_score = norm_cost1 + norm_cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = i\n\n        # Insert the best segment\n        new_solution = np.concatenate([temp_sol[:best_pos], segment, temp_sol[best_pos:]])\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # With 80% probability, repair the solution\n        if random.random() < 0.8:\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] in unique_nodes:\n                    continue\n                if missing_nodes:\n                    new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8878732997109157,
            8.089574933052063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Dynamic segment extraction and objective-aware insertion\n    for _ in range(3):\n        # Extract a random segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Optionally invert the segment\n        if random.random() < 0.4:\n            segment = segment[::-1]\n\n        # Remove the segment from the solution\n        temp_sol = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Find best insertion point based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([temp_sol[:i], segment, temp_sol[i:]])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n\n            # Use weighted sum of normalized costs\n            norm_cost1 = cost1 / distance_matrix_1.max()\n            norm_cost2 = cost2 / distance_matrix_2.max()\n            total_score = norm_cost1 + norm_cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = i\n\n        # Insert the best segment\n        new_solution = np.concatenate([temp_sol[:best_pos], segment, temp_sol[best_pos:]])\n\n    # Probabilistic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # With 80% probability, repair the solution\n        if random.random() < 0.8:\n            missing_nodes = [i for i in range(n) if i not in unique_nodes]\n            for i in range(n):\n                if new_solution[i] in unique_nodes:\n                    continue\n                if missing_nodes:\n                    new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with multi-objective edge insertion, where it intelligently inverts segments of the tour based on their combined objective impact and strategically inserts new edges to improve both objectives while maintaining feasibility through a dynamic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Calculate potential improvement if inverted\n        inv_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_end-1))\n        inv_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_end-1))\n        inv_total = inv_cost1 + inv_cost2\n\n        # Invert the segment if it improves both objectives\n        if inv_total < seg_total:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        # Select two random nodes\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential edge costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        current_total = current_cost1 + current_cost2\n\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        potential_total = potential_cost1 + potential_cost2\n\n        # Insert the edge if it improves both objectives\n        if potential_total < current_total:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8541194772251195,
            0.48369407653808594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Calculate potential improvement if inverted\n        inv_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_end-1))\n        inv_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_end-1))\n        inv_total = inv_cost1 + inv_cost2\n\n        # Invert the segment if it improves both objectives\n        if inv_total < seg_total:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        # Select two random nodes\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate current and potential edge costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        current_total = current_cost1 + current_cost2\n\n        potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n        potential_total = potential_cost1 + potential_cost2\n\n        # Insert the edge if it improves both objectives\n        if potential_total < current_total:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node reinsertion with multi-objective edge evaluation to explore diverse solutions by strategically repositioning nodes and selecting edges that show promise in both objective spaces while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node to remove\n        remove_idx = random.randint(0, n-1)\n        removed_node = new_solution[remove_idx]\n\n        # Create a temporary solution without the removed node\n        temp_solution = np.delete(new_solution, remove_idx)\n\n        # Evaluate potential insertion points\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n-1):\n            # Insert the removed node at position i\n            candidate = np.insert(temp_solution, i, removed_node)\n\n            # Calculate the total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n))\n\n            # Use a weighted sum of both objectives as the score\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(temp_solution, best_pos, removed_node)\n\n    # Multi-objective edge evaluation\n    for _ in range(2):\n        # Select two random edges to consider for swapping\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Evaluate the current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        new_edge1 = distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_edge2 = distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate the improvement potential\n        improvement1 = (current_edge1 + current_edge2) - (new_edge1 + new_edge2)\n\n        # If improvement is positive, perform the swap\n        if improvement1 > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8667407927127648,
            9.357065916061401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node reinsertion\n    for _ in range(3):\n        # Select a random node to remove\n        remove_idx = random.randint(0, n-1)\n        removed_node = new_solution[remove_idx]\n\n        # Create a temporary solution without the removed node\n        temp_solution = np.delete(new_solution, remove_idx)\n\n        # Evaluate potential insertion points\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n-1):\n            # Insert the removed node at position i\n            candidate = np.insert(temp_solution, i, removed_node)\n\n            # Calculate the total cost in both objective spaces\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(n))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(n))\n\n            # Use a weighted sum of both objectives as the score\n            score = 0.5 * cost1 + 0.5 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(temp_solution, best_pos, removed_node)\n\n    # Multi-objective edge evaluation\n    for _ in range(2):\n        # Select two random edges to consider for swapping\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Evaluate the current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n\n        new_edge1 = distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_edge2 = distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Calculate the improvement potential\n        improvement1 = (current_edge1 + current_edge2) - (new_edge1 + new_edge2)\n\n        # If improvement is positive, perform the swap\n        if improvement1 > 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive route fragmentation with dynamic node insertion to explore high-quality solutions by intelligently breaking and reinserting segments of the tour while maintaining feasibility and balancing improvements across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    fragment_size = max(2, min(4, n // 5))\n\n    # Adaptive route fragmentation\n    for _ in range(3):\n        frag_start = random.randint(0, n - fragment_size)\n        frag_end = frag_start + fragment_size\n        fragment = new_solution[frag_start:frag_end]\n\n        # Remove fragment and reinsert at a different position\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], fragment, new_solution[insert_pos:]])\n\n    # Dynamic node insertion for refinement\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6940551497229116,
            0.45395171642303467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    fragment_size = max(2, min(4, n // 5))\n\n    # Adaptive route fragmentation\n    for _ in range(3):\n        frag_start = random.randint(0, n - fragment_size)\n        frag_end = frag_start + fragment_size\n        fragment = new_solution[frag_start:frag_end]\n\n        # Remove fragment and reinsert at a different position\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], fragment, new_solution[insert_pos:]])\n\n    # Dynamic node insertion for refinement\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with objective-aware segment insertion to explore high-quality solutions by intelligently reversing and reinserting segments of the tour while dynamically balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        i = random.randint(0, n - segment_size)\n        j = i + segment_size\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware segment insertion\n    for _ in range(2):\n        i = random.randint(0, n - segment_size)\n        j = i + segment_size\n        segment = new_solution[i:j]\n\n        # Calculate potential insertion points based on both objectives\n        insertion_points = []\n        for k in range(n):\n            if k < i or k >= j:\n                cost1 = distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[k]]\n                cost2 = distance_matrix_2[new_solution[k-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[k]]\n                insertion_points.append((cost1 + cost2, k))\n\n        if insertion_points:\n            _, best_k = min(insertion_points)\n            new_solution = np.concatenate([new_solution[:best_k], segment, new_solution[best_k:]])\n            new_solution = np.delete(new_solution, np.arange(i, j))\n\n    return new_solution\n\n",
        "score": [
            -0.9146905579193052,
            0.32435595989227295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        i = random.randint(0, n - segment_size)\n        j = i + segment_size\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware segment insertion\n    for _ in range(2):\n        i = random.randint(0, n - segment_size)\n        j = i + segment_size\n        segment = new_solution[i:j]\n\n        # Calculate potential insertion points based on both objectives\n        insertion_points = []\n        for k in range(n):\n            if k < i or k >= j:\n                cost1 = distance_matrix_1[new_solution[k-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[k]]\n                cost2 = distance_matrix_2[new_solution[k-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[k]]\n                insertion_points.append((cost1 + cost2, k))\n\n        if insertion_points:\n            _, best_k = min(insertion_points)\n            new_solution = np.concatenate([new_solution[:best_k], segment, new_solution[best_k:]])\n            new_solution = np.delete(new_solution, np.arange(i, j))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective aware node insertion with adaptive path reversal to explore the solution space by intelligently inserting nodes from one tour into another while dynamically reversing path segments to balance improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective aware node insertion\n    for _ in range(3):\n        # Select a random node to remove\n        remove_pos = random.randint(0, n-1)\n        removed_node = new_solution[remove_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == remove_pos or i == remove_pos - 1:\n                continue\n\n            # Calculate score considering both objectives\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            score = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node]) + \\\n                    (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node])\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node at the best position\n        if best_pos > remove_pos:\n            new_solution = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:best_pos], [removed_node], new_solution[best_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [removed_node], new_solution[best_pos:remove_pos], new_solution[remove_pos+1:]])\n\n    # Adaptive path reversal\n    for _ in range(2):\n        # Select a random segment to reverse\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, n-1)\n\n        # Calculate the change in both objectives\n        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n        next_node = new_solution[seg_end] if seg_end < n-1 else new_solution[0]\n\n        original_cost1 = distance_matrix_1[prev_node, new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end], next_node]\n        reversed_cost1 = distance_matrix_1[prev_node, new_solution[seg_end]] + distance_matrix_1[new_solution[seg_start], next_node]\n\n        original_cost2 = distance_matrix_2[prev_node, new_solution[seg_start]] + distance_matrix_2[new_solution[seg_end], next_node]\n        reversed_cost2 = distance_matrix_2[prev_node, new_solution[seg_end]] + distance_matrix_2[new_solution[seg_start], next_node]\n\n        # Only reverse if it improves at least one objective\n        if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6685459150139097,
            1.1993943452835083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective aware node insertion\n    for _ in range(3):\n        # Select a random node to remove\n        remove_pos = random.randint(0, n-1)\n        removed_node = new_solution[remove_pos]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == remove_pos or i == remove_pos - 1:\n                continue\n\n            # Calculate score considering both objectives\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n            score = (distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] -\n                    distance_matrix_1[prev_node, next_node]) + \\\n                    (distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] -\n                    distance_matrix_2[prev_node, next_node])\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node at the best position\n        if best_pos > remove_pos:\n            new_solution = np.concatenate([new_solution[:remove_pos], new_solution[remove_pos+1:best_pos], [removed_node], new_solution[best_pos:]])\n        else:\n            new_solution = np.concatenate([new_solution[:best_pos], [removed_node], new_solution[best_pos:remove_pos], new_solution[remove_pos+1:]])\n\n    # Adaptive path reversal\n    for _ in range(2):\n        # Select a random segment to reverse\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, n-1)\n\n        # Calculate the change in both objectives\n        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n        next_node = new_solution[seg_end] if seg_end < n-1 else new_solution[0]\n\n        original_cost1 = distance_matrix_1[prev_node, new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end], next_node]\n        reversed_cost1 = distance_matrix_1[prev_node, new_solution[seg_end]] + distance_matrix_1[new_solution[seg_start], next_node]\n\n        original_cost2 = distance_matrix_2[prev_node, new_solution[seg_start]] + distance_matrix_2[new_solution[seg_end], next_node]\n        reversed_cost2 = distance_matrix_2[prev_node, new_solution[seg_end]] + distance_matrix_2[new_solution[seg_start], next_node]\n\n        # Only reverse if it improves at least one objective\n        if (reversed_cost1 < original_cost1) or (reversed_cost2 < original_cost2):\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This novel algorithm combines adaptive multi-objective tour partitioning with dynamic node reinsertion, where it intelligently divides the tour into high-impact segments based on their combined objective costs, then strategically reinserts nodes from these segments into optimal positions while maintaining feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective tour partitioning\n    for _ in range(2):\n        # Select a segment to analyze\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Remove the segment from the tour\n        remaining_tour = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Find optimal positions to reinsert nodes\n        for node in segment:\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(len(remaining_tour)):\n                prev_node = remaining_tour[i-1] if i > 0 else remaining_tour[-1]\n                next_node = remaining_tour[i] if i < len(remaining_tour) else remaining_tour[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the node at the best position\n            remaining_tour = np.insert(remaining_tour, best_pos, node)\n\n        new_solution = remaining_tour\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Remove the node from its current position\n        remaining_tour = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find the best position to reinsert the node\n        best_pos = 0\n        best_score = float('inf')\n\n        for j in range(len(remaining_tour)):\n            prev_node = remaining_tour[j-1] if j > 0 else remaining_tour[-1]\n            next_node = remaining_tour[j] if j < len(remaining_tour) else remaining_tour[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = j\n\n        # Insert the node at the best position\n        new_solution = np.insert(remaining_tour, best_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8265465416778918,
            1.945747196674347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective tour partitioning\n    for _ in range(2):\n        # Select a segment to analyze\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Remove the segment from the tour\n        remaining_tour = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Find optimal positions to reinsert nodes\n        for node in segment:\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(len(remaining_tour)):\n                prev_node = remaining_tour[i-1] if i > 0 else remaining_tour[-1]\n                next_node = remaining_tour[i] if i < len(remaining_tour) else remaining_tour[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the node at the best position\n            remaining_tour = np.insert(remaining_tour, best_pos, node)\n\n        new_solution = remaining_tour\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n\n        # Remove the node from its current position\n        remaining_tour = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find the best position to reinsert the node\n        best_pos = 0\n        best_score = float('inf')\n\n        for j in range(len(remaining_tour)):\n            prev_node = remaining_tour[j-1] if j > 0 else remaining_tour[-1]\n            next_node = remaining_tour[j] if j < len(remaining_tour) else remaining_tour[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = j\n\n        # Insert the node at the best position\n        new_solution = np.insert(remaining_tour, best_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment inversion with probabilistic node exchange, where it dynamically selects and inverts segments based on their combined objective impact while strategically exchanging nodes with a probability inversely proportional to their position-based impact, ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective score\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(4):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment with probability based on impact\n        if random.random() < (1 / (1 + seg_total)):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Probabilistic node exchange\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Exchange nodes with probability inversely proportional to their position-based impact\n            pos_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            pos_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            pos_total = pos_cost1 + pos_cost2\n\n            if random.random() < (1 / (1 + pos_total)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7960265425348558,
            0.515242338180542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective score\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(4):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment with probability based on impact\n        if random.random() < (1 / (1 + seg_total)):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Probabilistic node exchange\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Exchange nodes with probability inversely proportional to their position-based impact\n            pos_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            pos_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            pos_total = pos_cost1 + pos_cost2\n\n            if random.random() < (1 / (1 + pos_total)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This novel algorithm employs a hybrid approach combining adaptive segment inversion with dynamic objective-aware node insertion, where it intelligently inverts segments of high-impact nodes while strategically inserting nodes based on their combined objective contributions, ensuring feasibility through a multi-phase validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate new segment impact\n        new_seg_cost1 = sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n        new_seg_cost2 = sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n        new_seg_total = new_seg_cost1 + new_seg_cost2\n\n        # Accept inversion if it improves combined objective\n        if new_seg_total < seg_total:\n            new_solution[seg_start:seg_end] = inverted_segment\n\n    # Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to remove and reinsert\n        remove_pos = random.randint(0, n-1)\n        node = new_solution[remove_pos]\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n-1):\n            if pos == remove_pos or pos == remove_pos - 1:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the node\n            new_solution = np.delete(new_solution, remove_pos)\n            # Insert at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8658385527569747,
            0.6802244782447815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Calculate new segment impact\n        new_seg_cost1 = sum(distance_matrix_1[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n        new_seg_cost2 = sum(distance_matrix_2[inverted_segment[i-1], inverted_segment[i]] for i in range(1, len(inverted_segment)))\n        new_seg_total = new_seg_cost1 + new_seg_cost2\n\n        # Accept inversion if it improves combined objective\n        if new_seg_total < seg_total:\n            new_solution[seg_start:seg_end] = inverted_segment\n\n    # Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to remove and reinsert\n        remove_pos = random.randint(0, n-1)\n        node = new_solution[remove_pos]\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n-1):\n            if pos == remove_pos or pos == remove_pos - 1:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n-1 else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Remove the node\n            new_solution = np.delete(new_solution, remove_pos)\n            # Insert at best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{An adaptive multi-segment rearrangement with dynamic edge refinement that combines intelligent segment selection based on both objective spaces with a novel edge-swapping mechanism that considers the combined impact of both distance matrices to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution from the archive\n    solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_sizes = [max(2, min(3, n // 5)), max(3, min(5, n // 3))]\n\n    # Multi-segment rearrangement\n    for seg_size in segment_sizes:\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Evaluate segment quality based on both distance matrices\n        current_cost = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                       distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                       distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end%n]] +\n                       distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end%n]])\n\n        # Try different segment orientations\n        for _ in range(2):\n            candidate = new_solution.copy()\n            candidate[seg_start:seg_end] = candidate[seg_start:seg_end][::-1]\n\n            new_cost = (distance_matrix_1[candidate[seg_start-1], candidate[seg_start]] +\n                        distance_matrix_2[candidate[seg_start-1], candidate[seg_start]] +\n                        distance_matrix_1[candidate[seg_end-1], candidate[seg_end%n]] +\n                        distance_matrix_2[candidate[seg_end-1], candidate[seg_end%n]])\n\n            if new_cost < current_cost:\n                new_solution = candidate\n                current_cost = new_cost\n\n    # Dynamic edge refinement\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate edge swap based on both distance matrices\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n\n            new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                       distance_matrix_2[candidate[i-1], candidate[i]] +\n                       distance_matrix_1[candidate[j-1], candidate[j]] +\n                       distance_matrix_2[candidate[j-1], candidate[j]])\n\n            if new_cost < original_cost:\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.9318535331614048,
            0.6843785643577576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution from the archive\n    solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_sizes = [max(2, min(3, n // 5)), max(3, min(5, n // 3))]\n\n    # Multi-segment rearrangement\n    for seg_size in segment_sizes:\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Evaluate segment quality based on both distance matrices\n        current_cost = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                       distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                       distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end%n]] +\n                       distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end%n]])\n\n        # Try different segment orientations\n        for _ in range(2):\n            candidate = new_solution.copy()\n            candidate[seg_start:seg_end] = candidate[seg_start:seg_end][::-1]\n\n            new_cost = (distance_matrix_1[candidate[seg_start-1], candidate[seg_start]] +\n                        distance_matrix_2[candidate[seg_start-1], candidate[seg_start]] +\n                        distance_matrix_1[candidate[seg_end-1], candidate[seg_end%n]] +\n                        distance_matrix_2[candidate[seg_end-1], candidate[seg_end%n]])\n\n            if new_cost < current_cost:\n                new_solution = candidate\n                current_cost = new_cost\n\n    # Dynamic edge refinement\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Evaluate edge swap based on both distance matrices\n            original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n            candidate = new_solution.copy()\n            candidate[i:j] = candidate[i:j][::-1]\n\n            new_cost = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                       distance_matrix_2[candidate[i-1], candidate[i]] +\n                       distance_matrix_1[candidate[j-1], candidate[j]] +\n                       distance_matrix_2[candidate[j-1], candidate[j]])\n\n            if new_cost < original_cost:\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic sub-tour reversal to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging sub-tours while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to relocate\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new random position\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic sub-tour reversal\n    for _ in range(2):\n        # Select a random sub-tour segment\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n\n        # Reverse the selected sub-tour\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.8750907754566014,
            0.48390471935272217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to relocate\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new random position\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic sub-tour reversal\n    for _ in range(2):\n        # Select a random sub-tour segment\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n\n        # Reverse the selected sub-tour\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path reversal with dynamic node insertion to explore high-quality solutions by intelligently reversing segments of the tour and strategically inserting nodes while maintaining feasibility and balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize solutions with better combined objective)\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path reversal\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates and adjusting length\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    for node in unique_nodes[counts > 1]:\n        indices = np.where(new_solution == node)[0][1:]\n        new_solution = np.delete(new_solution, indices)\n\n    # Trim or pad to maintain original length\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, np.random.choice(list(missing), size=n - len(new_solution), replace=False)])\n\n    return new_solution\n\n",
        "score": [
            -0.7377766713853554,
            0.6301419734954834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize solutions with better combined objective)\n    archive_solutions = sorted(archive, key=lambda x: sum(x[1]))\n    selected_sol = archive_solutions[0][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path reversal\n    for _ in range(2):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node_to_insert = random.choice(new_solution)\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n\n    # Ensure feasibility by removing duplicates and adjusting length\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    for node in unique_nodes[counts > 1]:\n        indices = np.where(new_solution == node)[0][1:]\n        new_solution = np.delete(new_solution, indices)\n\n    # Trim or pad to maintain original length\n    if len(new_solution) > n:\n        new_solution = new_solution[:n]\n    elif len(new_solution) < n:\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, np.random.choice(list(missing), size=n - len(new_solution), replace=False)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive path segmentation with multi-objective node swapping, where it first identifies critical path segments based on their combined objective impact and then strategically swaps nodes within these segments to improve both objectives, while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Identify critical segments based on combined objective impact\n    segment_size = max(3, min(6, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) > 1:\n            cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            segments.append((cost1 + cost2, i, segment))\n\n    # Sort segments by combined cost (higher cost = more critical)\n    segments.sort(reverse=True, key=lambda x: x[0])\n\n    # Perform multi-objective node swapping in critical segments\n    for cost, start, segment in segments[:2]:  # Focus on top 2 critical segments\n        for _ in range(2):  # Perform 2 swaps per segment\n            i, j = random.sample(range(len(segment)), 2)\n            if i != j:\n                # Check if swap maintains feasibility\n                if (i == 0 and j == len(segment)-1) or (i == len(segment)-1 and j == 0):\n                    continue  # Avoid connecting segment endpoints directly\n\n                # Perform the swap\n                segment[i], segment[j] = segment[j], segment[i]\n\n                # Update the solution\n                new_solution[start:start+len(segment)] = segment\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reconstruct the solution if nodes are missing\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8520606064467587,
            0.556913435459137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Identify critical segments based on combined objective impact\n    segment_size = max(3, min(6, n // 4))\n    segments = []\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) > 1:\n            cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            segments.append((cost1 + cost2, i, segment))\n\n    # Sort segments by combined cost (higher cost = more critical)\n    segments.sort(reverse=True, key=lambda x: x[0])\n\n    # Perform multi-objective node swapping in critical segments\n    for cost, start, segment in segments[:2]:  # Focus on top 2 critical segments\n        for _ in range(2):  # Perform 2 swaps per segment\n            i, j = random.sample(range(len(segment)), 2)\n            if i != j:\n                # Check if swap maintains feasibility\n                if (i == 0 and j == len(segment)-1) or (i == len(segment)-1 and j == 0):\n                    continue  # Avoid connecting segment endpoints directly\n\n                # Perform the swap\n                segment[i], segment[j] = segment[j], segment[i]\n\n                # Update the solution\n                new_solution[start:start+len(segment)] = segment\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reconstruct the solution if nodes are missing\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This novel algorithm employs adaptive multi-objective path rebalancing with dynamic node prioritization, where it selectively alters high-impact path segments while strategically reordering nodes based on their normalized objective contributions, ensuring feasibility through a probabilistic segment repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined normalized objective performance\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(o[0] for o in objectives)\n    max_obj2 = max(o[1] for o in objectives)\n    normalized = [(o[0]/max_obj1 + o[1]/max_obj2) for o in objectives]\n    selected_idx = np.argmax(normalized)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    # Adaptive path rebalancing\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        norm_cost1 = seg_cost1 / max_obj1 if max_obj1 > 0 else 0\n        norm_cost2 = seg_cost2 / max_obj2 if max_obj2 > 0 else 0\n\n        # Reconstruct segment with prioritization\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            candidates = random.sample(remaining_nodes, min(2, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = (cost1 / max_obj1 if max_obj1 > 0 else 0) + (cost2 / max_obj2 if max_obj2 > 0 else 0)\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            if best_node is not None:\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        if len(new_segment) == len(segment):\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap with probability based on normalized impact\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            norm_cost = (cost1 / max_obj1 if max_obj1 > 0 else 0) + (cost2 / max_obj2 if max_obj2 > 0 else 0)\n\n            if random.random() < 0.7 / (1 + norm_cost):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes and missing:\n                if random.random() < 0.6:\n                    new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8525063695512746,
            0.891862690448761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined normalized objective performance\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(o[0] for o in objectives)\n    max_obj2 = max(o[1] for o in objectives)\n    normalized = [(o[0]/max_obj1 + o[1]/max_obj2) for o in objectives]\n    selected_idx = np.argmax(normalized)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    # Adaptive path rebalancing\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        norm_cost1 = seg_cost1 / max_obj1 if max_obj1 > 0 else 0\n        norm_cost2 = seg_cost2 / max_obj2 if max_obj2 > 0 else 0\n\n        # Reconstruct segment with prioritization\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            candidates = random.sample(remaining_nodes, min(2, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = (cost1 / max_obj1 if max_obj1 > 0 else 0) + (cost2 / max_obj2 if max_obj2 > 0 else 0)\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            if best_node is not None:\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        if len(new_segment) == len(segment):\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap with probability based on normalized impact\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            norm_cost = (cost1 / max_obj1 if max_obj1 > 0 else 0) + (cost2 / max_obj2 if max_obj2 > 0 else 0)\n\n            if random.random() < 0.7 / (1 + norm_cost):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes and missing:\n                if random.random() < 0.6:\n                    new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This novel algorithm combines adaptive node clustering with dynamic segment inversion, where it first groups nodes based on their combined objective impact and then inverts segments of the tour while strategically preserving the relative ordering of clusters to maintain solution quality and feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on combined objective impact\n    clusters = []\n    current_cluster = [new_solution[0]]\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate combined impact of adding current node to current cluster\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        combined_cost = cost1 + cost2\n\n        # Calculate average combined cost in current cluster\n        avg_cost = sum(distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]]\n                      for j in range(len(current_cluster))) / len(current_cluster)\n\n        if combined_cost <= avg_cost * 1.2:  # Threshold for cluster formation\n            current_cluster.append(current_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [current_node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Dynamic segment inversion while preserving cluster ordering\n    for _ in range(3):\n        if len(clusters) < 2:\n            break\n\n        # Select two non-consecutive clusters to invert\n        i, j = sorted(random.sample(range(len(clusters)), 2))\n        if i == j or (i + 1 == j and j + 1 < len(clusters)):\n            continue\n\n        # Invert the middle segment between the two clusters\n        start = sum(len(cluster) for cluster in clusters[:i]) + len(clusters[i])\n        end = sum(len(cluster) for cluster in clusters[:j])\n\n        if end > start:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5439907989251189,
            0.8878419399261475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on combined objective impact\n    clusters = []\n    current_cluster = [new_solution[0]]\n\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n\n        # Calculate combined impact of adding current node to current cluster\n        cost1 = distance_matrix_1[prev_node, current_node]\n        cost2 = distance_matrix_2[prev_node, current_node]\n        combined_cost = cost1 + cost2\n\n        # Calculate average combined cost in current cluster\n        avg_cost = sum(distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j-1], new_solution[j]]\n                      for j in range(len(current_cluster))) / len(current_cluster)\n\n        if combined_cost <= avg_cost * 1.2:  # Threshold for cluster formation\n            current_cluster.append(current_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [current_node]\n\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Dynamic segment inversion while preserving cluster ordering\n    for _ in range(3):\n        if len(clusters) < 2:\n            break\n\n        # Select two non-consecutive clusters to invert\n        i, j = sorted(random.sample(range(len(clusters)), 2))\n        if i == j or (i + 1 == j and j + 1 < len(clusters)):\n            continue\n\n        # Invert the middle segment between the two clusters\n        start = sum(len(cluster) for cluster in clusters[:i]) + len(clusters[i])\n        end = sum(len(cluster) for cluster in clusters[:j])\n\n        if end > start:\n            segment = new_solution[start:end]\n            new_solution[start:end] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This novel algorithm combines adaptive objective-weighted segment optimization with dynamic node reinsertion, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reinserting nodes based on their weighted objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Objective-weighted segment optimization\n    for _ in range(2):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weight = 0.7  # Higher weight for first objective\n        seg_score = seg_weight * seg_cost1 + (1 - seg_weight) * seg_cost2\n\n        # Reconstruct the segment by reinserting nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            if not remaining_nodes:\n                break\n\n            # Select next node based on weighted objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = seg_weight * cost1 + (1 - seg_weight) * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            if best_node is not None:\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        if new_segment:\n            new_solution[seg_start:seg_start+len(new_segment)] = new_segment\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Reinsert node at a different position\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8143845256224398,
            0.8536710143089294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Objective-weighted segment optimization\n    for _ in range(2):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weight = 0.7  # Higher weight for first objective\n        seg_score = seg_weight * seg_cost1 + (1 - seg_weight) * seg_cost2\n\n        # Reconstruct the segment by reinserting nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            if not remaining_nodes:\n                break\n\n            # Select next node based on weighted objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = seg_weight * cost1 + (1 - seg_weight) * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            if best_node is not None:\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        if new_segment:\n            new_solution[seg_start:seg_start+len(new_segment)] = new_segment\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Reinsert node at a different position\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This novel algorithm employs adaptive multi-objective path optimization with dynamic segment reconfiguration, where it intelligently selects and reconfigures paths based on their combined objective impact, using a weighted scoring mechanism that balances the two objectives while ensuring feasibility through a novel path validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive multi-objective path optimization\n    for _ in range(4):\n        # Select a segment to reconfigure\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted scoring\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        weight = 0.6  # Higher weight for first objective\n        seg_score = weight * seg_cost1 + (1 - weight) * seg_cost2\n\n        # Reconfigure the segment\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on weighted combined objective impact\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = weight * cost1 + (1 - weight) * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic segment reconfiguration for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9604049072610856,
            1.2742193341255188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive multi-objective path optimization\n    for _ in range(4):\n        # Select a segment to reconfigure\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted scoring\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        weight = 0.6  # Higher weight for first objective\n        seg_score = weight * seg_cost1 + (1 - weight) * seg_cost2\n\n        # Reconfigure the segment\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on weighted combined objective impact\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = weight * cost1 + (1 - weight) * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic segment reconfiguration for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{This algorithm combines adaptive cluster-based segment inversion with multi-objective edge optimization, where it first partitions the tour into clusters based on geographic proximity in both objective spaces, then inverts segments within clusters to disrupt local optima while preserving segment connectivity, followed by an edge optimization step that selectively reorders edges based on their combined objective impact, ensuring feasibility through a dynamic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Cluster-based segment inversion\n    for _ in range(2):\n        # Randomly select a cluster size\n        cluster_size = max(2, min(5, n // 5))\n\n        # Create clusters by grouping nearby nodes in both spaces\n        clusters = []\n        remaining = list(range(n))\n        while remaining:\n            cluster = [remaining.pop(0)]\n            for _ in range(cluster_size - 1):\n                if not remaining:\n                    break\n                # Find closest node in both spaces\n                last_node = cluster[-1]\n                closest = min(remaining, key=lambda x: (distance_matrix_1[new_solution[last_node], new_solution[x]] +\n                                                      distance_matrix_2[new_solution[last_node], new_solution[x]]))\n                cluster.append(closest)\n                remaining.remove(closest)\n            clusters.append(cluster)\n\n        # Invert segments within clusters\n        for cluster in clusters:\n            if len(cluster) > 1:\n                start, end = random.sample(cluster, 2)\n                start, end = sorted([start, end])\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate current and potential costs\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                             distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if potential_cost < current_cost:\n                # Perform the swap if it improves both objectives\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7551129073618441,
            2.4576752185821533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Cluster-based segment inversion\n    for _ in range(2):\n        # Randomly select a cluster size\n        cluster_size = max(2, min(5, n // 5))\n\n        # Create clusters by grouping nearby nodes in both spaces\n        clusters = []\n        remaining = list(range(n))\n        while remaining:\n            cluster = [remaining.pop(0)]\n            for _ in range(cluster_size - 1):\n                if not remaining:\n                    break\n                # Find closest node in both spaces\n                last_node = cluster[-1]\n                closest = min(remaining, key=lambda x: (distance_matrix_1[new_solution[last_node], new_solution[x]] +\n                                                      distance_matrix_2[new_solution[last_node], new_solution[x]]))\n                cluster.append(closest)\n                remaining.remove(closest)\n            clusters.append(cluster)\n\n        # Invert segments within clusters\n        for cluster in clusters:\n            if len(cluster) > 1:\n                start, end = random.sample(cluster, 2)\n                start, end = sorted([start, end])\n                new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate current and potential costs\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                             distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                             distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if potential_cost < current_cost:\n                # Perform the swap if it improves both objectives\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This novel hybrid algorithm combines objective-aware path decomposition with adaptive node insertion, where it first partitions the tour into high-potential segments based on combined objective gradients, then reconstructs each segment by strategically inserting nodes that optimize both objectives while maintaining feasibility through a dynamic path validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Objective-aware path decomposition\n    segment_starts = []\n    for i in range(0, n, segment_size):\n        segment_starts.append(i)\n\n    for seg_start in segment_starts:\n        seg_end = min(seg_start + segment_size, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment gradient in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct segment with adaptive node insertion\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for i in range(len(segment)):\n            # Select insertion point based on combined objective impact\n            if not new_segment:\n                prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n            else:\n                prev_node = new_segment[-1]\n                next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n            # Evaluate potential insertions\n            best_node = None\n            best_score = float('inf')\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n\n            for node in candidates:\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            if best_node is not None:\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        if len(new_segment) == len(segment):\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9488143658461552,
            2.3057494163513184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Objective-aware path decomposition\n    segment_starts = []\n    for i in range(0, n, segment_size):\n        segment_starts.append(i)\n\n    for seg_start in segment_starts:\n        seg_end = min(seg_start + segment_size, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment gradient in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct segment with adaptive node insertion\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for i in range(len(segment)):\n            # Select insertion point based on combined objective impact\n            if not new_segment:\n                prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n            else:\n                prev_node = new_segment[-1]\n                next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n            # Evaluate potential insertions\n            best_node = None\n            best_score = float('inf')\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n\n            for node in candidates:\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            if best_node is not None:\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        if len(new_segment) == len(segment):\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{An adaptive segment insertion heuristic that combines dynamic segment extraction with multi-objective edge optimization to explore high-quality solutions by intelligently inserting and rearranging segments while balancing improvements in both objective spaces through a novel segment insertion and edge flipping strategy.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Dynamic segment extraction and insertion\n    for _ in range(3):\n        # Extract a segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Multi-objective edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate cost improvement in both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.850437071894435,
            0.511996865272522
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Dynamic segment extraction and insertion\n    for _ in range(3):\n        # Extract a segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Multi-objective edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate cost improvement in both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path inversion with dynamic node reinsertion, where it intelligently selects and inverts segments of the tour while strategically reinserting nodes based on their combined objective impact, ensuring feasibility through a novel path validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n        # Dynamic node reinsertion for further refinement\n        for _ in range(2):\n            # Select a node to reinsert\n            pos = random.randint(seg_start, seg_end - 1)\n            node = new_solution[pos]\n\n            # Remove the node\n            new_solution = np.delete(new_solution, pos)\n\n            # Find best insertion position based on combined objective impact\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n - 1):\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8791468193557797,
            0.9294952750205994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = segment[::-1]\n\n        # Dynamic node reinsertion for further refinement\n        for _ in range(2):\n            # Select a node to reinsert\n            pos = random.randint(seg_start, seg_end - 1)\n            node = new_solution[pos]\n\n            # Remove the node\n            new_solution = np.delete(new_solution, pos)\n\n            # Find best insertion position based on combined objective impact\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n - 1):\n                cost1 = distance_matrix_1[new_solution[i-1], node] + distance_matrix_1[node, new_solution[i]]\n                cost2 = distance_matrix_2[new_solution[i-1], node] + distance_matrix_2[node, new_solution[i]]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the node at the best position\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This algorithm combines adaptive path decomposition with multi-objective node insertion, where it dynamically partitions the tour into segments, optimizes each segment's node sequence based on combined objective impact, and strategically inserts nodes back into the tour using a hybrid of greedy and probabilistic selection to balance exploration and exploitation while maintaining feasibility through a novel path validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 2))\n\n    # Adaptive path decomposition\n    for _ in range(2):\n        # Select a segment to optimize\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Optimize segment node sequence\n        optimized_segment = []\n        remaining_nodes = list(segment)\n\n        while remaining_nodes:\n            if not optimized_segment:\n                # Start with best node for first position\n                best_node = min(remaining_nodes, key=lambda node: (\n                    distance_matrix_1[new_solution[seg_start-1] if seg_start > 0 else new_solution[-1], node] +\n                    distance_matrix_2[new_solution[seg_start-1] if seg_start > 0 else new_solution[-1], node]\n                ))\n            else:\n                # Select next node based on combined objective impact\n                candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n                best_node = min(candidates, key=lambda node: (\n                    distance_matrix_1[optimized_segment[-1], node] +\n                    distance_matrix_2[optimized_segment[-1], node]\n                ))\n\n            optimized_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = optimized_segment\n\n    # Multi-objective node insertion\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find best insertion position\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7643602228662594,
            0.828372061252594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 2))\n\n    # Adaptive path decomposition\n    for _ in range(2):\n        # Select a segment to optimize\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Optimize segment node sequence\n        optimized_segment = []\n        remaining_nodes = list(segment)\n\n        while remaining_nodes:\n            if not optimized_segment:\n                # Start with best node for first position\n                best_node = min(remaining_nodes, key=lambda node: (\n                    distance_matrix_1[new_solution[seg_start-1] if seg_start > 0 else new_solution[-1], node] +\n                    distance_matrix_2[new_solution[seg_start-1] if seg_start > 0 else new_solution[-1], node]\n                ))\n            else:\n                # Select next node based on combined objective impact\n                candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n                best_node = min(candidates, key=lambda node: (\n                    distance_matrix_1[optimized_segment[-1], node] +\n                    distance_matrix_2[optimized_segment[-1], node]\n                ))\n\n            optimized_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = optimized_segment\n\n    # Multi-objective node insertion\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find best insertion position\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{A novel hybrid local search strategy that combines multi-segment inversion with adaptive segment relocation to explore diverse regions of the solution space by dynamically adjusting segment sizes and positions while maintaining feasibility and balancing improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment sizes based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Multi-segment inversion with dynamic segment sizes\n    for _ in range(3):\n        # Randomly select a segment to invert\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adjust segment size dynamically\n        segment_size = max(2, min(segment_size + random.randint(-1, 1), n // 2))\n\n    # Adaptive segment relocation\n    for _ in range(2):\n        # Select a segment to relocate\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert the segment at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Adjust segment size dynamically\n        segment_size = max(2, min(segment_size + random.randint(-1, 1), n // 3))\n\n    return new_solution\n\n",
        "score": [
            -0.940466601860273,
            0.46050775051116943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment sizes based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Multi-segment inversion with dynamic segment sizes\n    for _ in range(3):\n        # Randomly select a segment to invert\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adjust segment size dynamically\n        segment_size = max(2, min(segment_size + random.randint(-1, 1), n // 2))\n\n    # Adaptive segment relocation\n    for _ in range(2):\n        # Select a segment to relocate\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Insert the segment at a new random position\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Adjust segment size dynamically\n        segment_size = max(2, min(segment_size + random.randint(-1, 1), n // 3))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node reinsertion to explore high-quality solutions in both objective spaces by intelligently inverting segments of the tour and reinserting nodes while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(2):  # Perform multiple reinsertions\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8277530927034111,
            0.48386019468307495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(2):  # Perform multiple reinsertions\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node reallocation to explore high-quality solutions by intelligently inverting segments of the tour and strategically relocating nodes while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node reallocation\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8635568183623596,
            0.45268863439559937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node reallocation\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This novel algorithm employs a hierarchical clustering-based tour reconstruction approach that first partitions the solution into clusters based on spatial proximity in both objective spaces, then intelligently reorders these clusters while preserving feasibility through a dynamic node reinsertion mechanism, ensuring balanced exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Hierarchical clustering based on combined spatial proximity\n    cluster_size = max(2, min(5, n // 4))\n    clusters = []\n\n    # Create initial clusters\n    current_cluster = []\n    for i in range(n):\n        if len(current_cluster) < cluster_size:\n            current_cluster.append(new_solution[i])\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Shuffle clusters to create diversity\n    random.shuffle(clusters)\n\n    # Reconstruct solution from clusters\n    new_solution = []\n    for cluster in clusters:\n        # Insert cluster nodes at optimal positions\n        if not new_solution:\n            new_solution.extend(cluster)\n        else:\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(len(new_solution) + 1):\n                # Try inserting cluster at this position\n                temp_sol = new_solution.copy()\n                temp_sol[pos:pos] = cluster\n\n                # Calculate cost in both objectives\n                cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n                cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution[best_pos:best_pos] = cluster\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        # Select a random node and reinsert it at the best position\n        node_pos = random.randint(0, n-1)\n        node = new_solution.pop(node_pos)\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            temp_sol = new_solution.copy()\n            temp_sol.insert(pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution.insert(best_pos, node)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.8920723509108797,
            10.964368045330048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Hierarchical clustering based on combined spatial proximity\n    cluster_size = max(2, min(5, n // 4))\n    clusters = []\n\n    # Create initial clusters\n    current_cluster = []\n    for i in range(n):\n        if len(current_cluster) < cluster_size:\n            current_cluster.append(new_solution[i])\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Shuffle clusters to create diversity\n    random.shuffle(clusters)\n\n    # Reconstruct solution from clusters\n    new_solution = []\n    for cluster in clusters:\n        # Insert cluster nodes at optimal positions\n        if not new_solution:\n            new_solution.extend(cluster)\n        else:\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(len(new_solution) + 1):\n                # Try inserting cluster at this position\n                temp_sol = new_solution.copy()\n                temp_sol[pos:pos] = cluster\n\n                # Calculate cost in both objectives\n                cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n                cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            new_solution[best_pos:best_pos] = cluster\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        # Select a random node and reinsert it at the best position\n        node_pos = random.randint(0, n-1)\n        node = new_solution.pop(node_pos)\n\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution) + 1):\n            temp_sol = new_solution.copy()\n            temp_sol.insert(pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution.insert(best_pos, node)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with multi-objective edge optimization to explore high-quality solutions by intelligently reinserting segments of the tour and selectively optimizing edges based on their contribution to both objectives while maintaining feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment insertion\n    for _ in range(2):\n        # Select a segment to remove\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Select a new position to insert the segment\n        insert_pos = random.randint(0, len(new_solution))\n\n        # Insert the segment back\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        # Select a random edge\n        i = random.randint(0, len(new_solution) - 1)\n        j = (i + 1) % len(new_solution)\n\n        # Calculate edge costs in both objectives\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best node to insert between i and j\n        best_node = None\n        best_improvement = 0\n\n        for node in new_solution:\n            if node in [new_solution[i], new_solution[j]]:\n                continue\n\n            # Calculate potential improvement\n            new_cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[j]]\n\n            improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_node = node\n\n        # Perform the insertion if it improves both objectives\n        if best_node is not None and best_improvement > 0:\n            # Find the position of the best node\n            pos = np.where(new_solution == best_node)[0][0]\n\n            # Remove the best node from its current position\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n\n            # Insert it between i and j\n            new_solution = np.concatenate([new_solution[:j], [best_node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8538835149996796,
            0.7830639481544495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment insertion\n    for _ in range(2):\n        # Select a segment to remove\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n        # Select a new position to insert the segment\n        insert_pos = random.randint(0, len(new_solution))\n\n        # Insert the segment back\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Multi-objective edge optimization\n    for _ in range(3):\n        # Select a random edge\n        i = random.randint(0, len(new_solution) - 1)\n        j = (i + 1) % len(new_solution)\n\n        # Calculate edge costs in both objectives\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best node to insert between i and j\n        best_node = None\n        best_improvement = 0\n\n        for node in new_solution:\n            if node in [new_solution[i], new_solution[j]]:\n                continue\n\n            # Calculate potential improvement\n            new_cost1 = distance_matrix_1[new_solution[i], node] + distance_matrix_1[node, new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], node] + distance_matrix_2[node, new_solution[j]]\n\n            improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_node = node\n\n        # Perform the insertion if it improves both objectives\n        if best_node is not None and best_improvement > 0:\n            # Find the position of the best node\n            pos = np.where(new_solution == best_node)[0][0]\n\n            # Remove the best node from its current position\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+1:]])\n\n            # Insert it between i and j\n            new_solution = np.concatenate([new_solution[:j], [best_node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm employs a novel adaptive multi-segment inversion strategy that dynamically selects and inverts segments of varying sizes based on their combined objective impact, while maintaining feasibility through a probabilistic segment validation and repair mechanism that prioritizes high-impact nodes in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    max_segment_size = min(8, n // 2)\n\n    # Adaptive multi-segment inversion\n    for _ in range(3):\n        # Select segment size based on problem size and randomness\n        segment_size = random.randint(2, max_segment_size)\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment with probability based on impact\n        if random.random() < (1 / (1 + seg_total / (distance_matrix_1.max() + distance_matrix_2.max()))):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Probabilistic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                # Replace missing node with a high-impact candidate\n                candidates = random.sample(missing, min(3, len(missing)))\n                best_node = min(candidates, key=lambda x: distance_matrix_1[new_solution[i-1], x] + distance_matrix_2[new_solution[i-1], x])\n                new_solution[i] = best_node\n                missing.remove(best_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8281639913356569,
            0.5560287237167358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    max_segment_size = min(8, n // 2)\n\n    # Adaptive multi-segment inversion\n    for _ in range(3):\n        # Select segment size based on problem size and randomness\n        segment_size = random.randint(2, max_segment_size)\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment with probability based on impact\n        if random.random() < (1 / (1 + seg_total / (distance_matrix_1.max() + distance_matrix_2.max()))):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Probabilistic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                # Replace missing node with a high-impact candidate\n                candidates = random.sample(missing, min(3, len(missing)))\n                best_node = min(candidates, key=lambda x: distance_matrix_1[new_solution[i-1], x] + distance_matrix_2[new_solution[i-1], x])\n                new_solution[i] = best_node\n                missing.remove(best_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with multi-objective edge insertion, where it dynamically selects high-impact path segments to invert while strategically inserting edges based on their combined objective improvement potential, ensuring feasibility through a novel path validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive path inversion with multi-objective edge insertion\n    for _ in range(3):\n        # Select a path segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate segment cost before inversion\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        total_cost = seg_cost1 + seg_cost2\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Calculate segment cost after inversion\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_total_cost = new_seg_cost1 + new_seg_cost2\n\n        # If inversion worsened the solution, revert it\n        if new_total_cost > total_cost:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Multi-objective edge insertion\n        for _ in range(2):\n            # Select two edges to potentially insert\n            edge1 = random.randint(0, n-1)\n            edge2 = random.randint(0, n-1)\n\n            # Calculate potential insertion cost\n            node_a = new_solution[edge1]\n            node_b = new_solution[(edge1+1)%n]\n            node_c = new_solution[edge2]\n            node_d = new_solution[(edge2+1)%n]\n\n            old_cost1 = distance_matrix_1[node_a, node_b] + distance_matrix_1[node_c, node_d]\n            old_cost2 = distance_matrix_2[node_a, node_b] + distance_matrix_2[node_c, node_d]\n\n            new_cost1 = distance_matrix_1[node_a, node_c] + distance_matrix_1[node_b, node_d]\n            new_cost2 = distance_matrix_2[node_a, node_c] + distance_matrix_2[node_b, node_d]\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                # Perform the edge insertion if it improves the solution\n                if edge1 < edge2:\n                    new_solution[edge1+1:edge2+1] = np.roll(new_solution[edge1+1:edge2+1], -1)\n                else:\n                    new_solution[edge2+1:edge1+1] = np.roll(new_solution[edge2+1:edge1+1], 1)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9096740224493113,
            0.600071907043457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive path inversion with multi-objective edge insertion\n    for _ in range(3):\n        # Select a path segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate segment cost before inversion\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        total_cost = seg_cost1 + seg_cost2\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Calculate segment cost after inversion\n        new_seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_total_cost = new_seg_cost1 + new_seg_cost2\n\n        # If inversion worsened the solution, revert it\n        if new_total_cost > total_cost:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Multi-objective edge insertion\n        for _ in range(2):\n            # Select two edges to potentially insert\n            edge1 = random.randint(0, n-1)\n            edge2 = random.randint(0, n-1)\n\n            # Calculate potential insertion cost\n            node_a = new_solution[edge1]\n            node_b = new_solution[(edge1+1)%n]\n            node_c = new_solution[edge2]\n            node_d = new_solution[(edge2+1)%n]\n\n            old_cost1 = distance_matrix_1[node_a, node_b] + distance_matrix_1[node_c, node_d]\n            old_cost2 = distance_matrix_2[node_a, node_b] + distance_matrix_2[node_c, node_d]\n\n            new_cost1 = distance_matrix_1[node_a, node_c] + distance_matrix_1[node_b, node_d]\n            new_cost2 = distance_matrix_2[node_a, node_c] + distance_matrix_2[node_b, node_d]\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                # Perform the edge insertion if it improves the solution\n                if edge1 < edge2:\n                    new_solution[edge1+1:edge2+1] = np.roll(new_solution[edge1+1:edge2+1], -1)\n                else:\n                    new_solution[edge2+1:edge1+1] = np.roll(new_solution[edge2+1:edge1+1], 1)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This novel algorithm combines adaptive objective-balanced path segmentation with dynamic hub-based node relocation, where it intelligently partitions the tour into high-impact segments based on their combined objective contributions, then strategically reallocates nodes to dynamically identified hubs while maintaining feasibility through a novel path connectivity validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive objective-balanced path segmentation\n    segment_starts = []\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        segment_starts.append(seg_start)\n\n    # Identify hub nodes based on combined objective impact\n    hub_candidates = []\n    for i in range(n):\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n        cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n        cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n        hub_score = cost1 + cost2\n        hub_candidates.append((hub_score, i))\n\n    hub_candidates.sort()\n    hub_indices = [idx for (score, idx) in hub_candidates[:min(3, n)]]\n\n    # Dynamic hub-based node relocation\n    for hub in hub_indices:\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            if i != hub and new_solution[i] != new_solution[hub]:\n                # Relocate node to hub position\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, hub, node)\n\n    # Path connectivity validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        for i in range(n):\n            if new_solution[i] in duplicates:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9254272732314462,
            0.6768497228622437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive objective-balanced path segmentation\n    segment_starts = []\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        segment_starts.append(seg_start)\n\n    # Identify hub nodes based on combined objective impact\n    hub_candidates = []\n    for i in range(n):\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n        cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n        cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n        hub_score = cost1 + cost2\n        hub_candidates.append((hub_score, i))\n\n    hub_candidates.sort()\n    hub_indices = [idx for (score, idx) in hub_candidates[:min(3, n)]]\n\n    # Dynamic hub-based node relocation\n    for hub in hub_indices:\n        for _ in range(2):\n            i = random.randint(0, n-1)\n            if i != hub and new_solution[i] != new_solution[hub]:\n                # Relocate node to hub position\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, hub, node)\n\n    # Path connectivity validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        for i in range(n):\n            if new_solution[i] in duplicates:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic node insertion to explore high-quality solutions by intelligently inverting segments of the tour and strategically inserting nodes while balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(2):\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8838468113813318,
            0.5035750865936279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(2):\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This novel algorithm combines adaptive multi-objective node clustering with dynamic segment inversion, where it first groups nodes based on their combined objective impact and then strategically inverts segments within these clusters to explore diverse solutions while maintaining feasibility through a novel cluster boundary preservation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on combined objective impact\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        cost1 = distance_matrix_1[prev_node, curr_node]\n        cost2 = distance_matrix_2[prev_node, curr_node]\n        combined_cost = cost1 + cost2\n\n        # Cluster nodes with similar combined costs\n        if combined_cost < (distance_matrix_1.mean() + distance_matrix_2.mean()) * 0.7:\n            current_cluster.append(curr_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [curr_node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Dynamic segment inversion within clusters\n    for cluster in clusters:\n        if len(cluster) > 2:\n            # Select a segment within the cluster to invert\n            seg_start = random.randint(0, len(cluster) - 2)\n            seg_end = random.randint(seg_start + 1, len(cluster) - 1)\n\n            # Find the positions of these nodes in the solution\n            indices = [i for i, node in enumerate(new_solution) if node in cluster[seg_start:seg_end+1]]\n            if len(indices) > 1:\n                # Invert the segment\n                new_solution[indices] = new_solution[indices[::-1]]\n\n    # Cluster boundary preservation\n    for i in range(1, n):\n        if i < n-1 and new_solution[i] in clusters[0] and new_solution[i+1] not in clusters[0]:\n            # Ensure smooth transition between clusters\n            j = random.randint(0, len(clusters[0])-1)\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7337728756363168,
            1.1480284929275513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node clustering based on combined objective impact\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        cost1 = distance_matrix_1[prev_node, curr_node]\n        cost2 = distance_matrix_2[prev_node, curr_node]\n        combined_cost = cost1 + cost2\n\n        # Cluster nodes with similar combined costs\n        if combined_cost < (distance_matrix_1.mean() + distance_matrix_2.mean()) * 0.7:\n            current_cluster.append(curr_node)\n        else:\n            clusters.append(current_cluster)\n            current_cluster = [curr_node]\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Dynamic segment inversion within clusters\n    for cluster in clusters:\n        if len(cluster) > 2:\n            # Select a segment within the cluster to invert\n            seg_start = random.randint(0, len(cluster) - 2)\n            seg_end = random.randint(seg_start + 1, len(cluster) - 1)\n\n            # Find the positions of these nodes in the solution\n            indices = [i for i, node in enumerate(new_solution) if node in cluster[seg_start:seg_end+1]]\n            if len(indices) > 1:\n                # Invert the segment\n                new_solution[indices] = new_solution[indices[::-1]]\n\n    # Cluster boundary preservation\n    for i in range(1, n):\n        if i < n-1 and new_solution[i] in clusters[0] and new_solution[i+1] not in clusters[0]:\n            # Ensure smooth transition between clusters\n            j = random.randint(0, len(clusters[0])-1)\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{This novel algorithm employs a multi-phase approach that combines adaptive segment inversion with dynamic objective-aware node insertion, where it first identifies high-potential segments based on their combined objective impact, inverts them to explore new configurations, and then strategically inserts nodes from other segments to maintain feasibility while improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n        new_solution[seg_start:seg_end] = inverted_segment\n\n        # Objective-aware node insertion\n        remaining_nodes = [node for node in new_solution if node not in inverted_segment]\n        for i in range(seg_start, seg_end):\n            if random.random() < 0.3:\n                candidates = random.sample(remaining_nodes, min(2, len(remaining_nodes)))\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                    next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                if best_node is not None:\n                    new_solution[i] = best_node\n                    remaining_nodes.remove(best_node)\n\n    # Final validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9030675232417288,
            0.9532782435417175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n        new_solution[seg_start:seg_end] = inverted_segment\n\n        # Objective-aware node insertion\n        remaining_nodes = [node for node in new_solution if node not in inverted_segment]\n        for i in range(seg_start, seg_end):\n            if random.random() < 0.3:\n                candidates = random.sample(remaining_nodes, min(2, len(remaining_nodes)))\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                    next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                if best_node is not None:\n                    new_solution[i] = best_node\n                    remaining_nodes.remove(best_node)\n\n    # Final validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{A novel adaptive local search strategy that combines dynamic segment inversion with probabilistic edge reinsertion to explore diverse high-quality solutions by selectively inverting segments and probabilistically reinserting edges based on their contribution to both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistic edge reinsertion\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7 and (j - i) > 1:\n            edge = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n    return new_solution\n\n",
        "score": [
            -0.8289137807393585,
            0.5457065105438232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Dynamic segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Probabilistic edge reinsertion\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.7 and (j - i) > 1:\n            edge = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This novel algorithm employs a multi-objective cluster-based perturbation approach that intelligently reorders nodes within high-performing clusters while maintaining feasibility through a dynamic boundary adjustment mechanism, balancing the trade-off between exploration and exploitation by adaptively adjusting cluster sizes based on their objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Determine cluster sizes based on node distances\n    cluster_sizes = []\n    for i in range(n):\n        # Calculate average distance to neighbors in both objectives\n        neighbors = [j for j in range(n) if j != i]\n        avg_dist1 = sum(distance_matrix_1[i, j] for j in neighbors) / len(neighbors)\n        avg_dist2 = sum(distance_matrix_2[i, j] for j in neighbors) / len(neighbors)\n        # Cluster size inversely proportional to average distance\n        cluster_size = max(2, min(5, int(10 / (avg_dist1 + avg_dist2 + 1))))\n        cluster_sizes.append(cluster_size)\n\n    # Apply cluster-based perturbations\n    for _ in range(3):\n        # Select a cluster to perturb\n        cluster_start = random.randint(0, n - 1)\n        cluster_size = cluster_sizes[cluster_start]\n        cluster_end = min(cluster_start + cluster_size, n)\n\n        # Extract cluster and remaining nodes\n        cluster = new_solution[cluster_start:cluster_end]\n        remaining_nodes = [node for node in new_solution if node not in cluster]\n\n        # Reorder cluster nodes based on combined objective impact\n        new_cluster = []\n        for _ in range(len(cluster)):\n            if not new_cluster:\n                # For first node in cluster\n                prev_node = new_solution[cluster_start - 1] if cluster_start > 0 else new_solution[-1]\n                next_node = new_solution[cluster_end] if cluster_end < n else new_solution[0]\n            else:\n                prev_node = new_cluster[-1]\n                next_node = new_solution[cluster_end] if cluster_end < n else new_solution[0]\n\n            # Select best node based on combined objective impact\n            best_node = None\n            best_score = float('inf')\n            for node in remaining_nodes:\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_cluster.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the cluster\n        new_solution[cluster_start:cluster_end] = new_cluster\n\n    # Dynamic boundary adjustment for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9663746717716173,
            3.0062689781188965
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Determine cluster sizes based on node distances\n    cluster_sizes = []\n    for i in range(n):\n        # Calculate average distance to neighbors in both objectives\n        neighbors = [j for j in range(n) if j != i]\n        avg_dist1 = sum(distance_matrix_1[i, j] for j in neighbors) / len(neighbors)\n        avg_dist2 = sum(distance_matrix_2[i, j] for j in neighbors) / len(neighbors)\n        # Cluster size inversely proportional to average distance\n        cluster_size = max(2, min(5, int(10 / (avg_dist1 + avg_dist2 + 1))))\n        cluster_sizes.append(cluster_size)\n\n    # Apply cluster-based perturbations\n    for _ in range(3):\n        # Select a cluster to perturb\n        cluster_start = random.randint(0, n - 1)\n        cluster_size = cluster_sizes[cluster_start]\n        cluster_end = min(cluster_start + cluster_size, n)\n\n        # Extract cluster and remaining nodes\n        cluster = new_solution[cluster_start:cluster_end]\n        remaining_nodes = [node for node in new_solution if node not in cluster]\n\n        # Reorder cluster nodes based on combined objective impact\n        new_cluster = []\n        for _ in range(len(cluster)):\n            if not new_cluster:\n                # For first node in cluster\n                prev_node = new_solution[cluster_start - 1] if cluster_start > 0 else new_solution[-1]\n                next_node = new_solution[cluster_end] if cluster_end < n else new_solution[0]\n            else:\n                prev_node = new_cluster[-1]\n                next_node = new_solution[cluster_end] if cluster_end < n else new_solution[0]\n\n            # Select best node based on combined objective impact\n            best_node = None\n            best_score = float('inf')\n            for node in remaining_nodes:\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_cluster.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the cluster\n        new_solution[cluster_start:cluster_end] = new_cluster\n\n    # Dynamic boundary adjustment for feasibility\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment rearrangement with dynamic edge optimization, using a weighted score function to prioritize segments that show potential for improvement in both objective spaces while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted score of improvement potential\n    scores = []\n    for sol, obj in archive:\n        # Calculate potential improvement score (higher is better)\n        total_dist_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_dist_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        score = (total_dist_1 + total_dist_2) / (obj[0] + obj[1] + 1e-8)  # Normalized by current objective\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    selected_sol = archive[selected_idx][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        # Select segments based on edge quality\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Calculate segment quality scores\n        seg1_score = (sum(distance_matrix_1[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg1_start, seg1_end)) +\n                     sum(distance_matrix_2[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg1_start, seg1_end)))\n        seg2_score = (sum(distance_matrix_1[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg2_start, seg2_end)) +\n                     sum(distance_matrix_2[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg2_start, seg2_end)))\n\n        # Swap segments if they show potential improvement\n        if seg1_score > seg2_score:\n            seg1 = new_solution[seg1_start:seg1_end]\n            seg2 = new_solution[seg2_start:seg2_end]\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate potential gain\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < current_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7886614097217304,
            5.950298488140106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a weighted score of improvement potential\n    scores = []\n    for sol, obj in archive:\n        # Calculate potential improvement score (higher is better)\n        total_dist_1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_dist_2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        score = (total_dist_1 + total_dist_2) / (obj[0] + obj[1] + 1e-8)  # Normalized by current objective\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    selected_sol = archive[selected_idx][0].copy()\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rearrangement\n    for _ in range(3):\n        # Select segments based on edge quality\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Calculate segment quality scores\n        seg1_score = (sum(distance_matrix_1[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg1_start, seg1_end)) +\n                     sum(distance_matrix_2[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg1_start, seg1_end)))\n        seg2_score = (sum(distance_matrix_1[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg2_start, seg2_end)) +\n                     sum(distance_matrix_2[selected_sol[i], selected_sol[(i+1)%n]] for i in range(seg2_start, seg2_end)))\n\n        # Swap segments if they show potential improvement\n        if seg1_score > seg2_score:\n            seg1 = new_solution[seg1_start:seg1_end]\n            seg2 = new_solution[seg2_start:seg2_end]\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge optimization\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Calculate potential gain\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if new_cost < current_cost:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment rotation with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently rotating segments of the tour and strategically inserting nodes while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rotation\n    for _ in range(3):  # Perform multiple rotations\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Rotate the segment by a random amount\n        rotation = random.randint(1, segment_size - 1)\n        seg = new_solution[seg_start:seg_end]\n        rotated_seg = np.roll(seg, rotation)\n        new_solution[seg_start:seg_end] = rotated_seg\n\n    # Dynamic node insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6879869685424682,
            0.544678270816803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment rotation\n    for _ in range(3):  # Perform multiple rotations\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Rotate the segment by a random amount\n        rotation = random.randint(1, segment_size - 1)\n        seg = new_solution[seg_start:seg_end]\n        rotated_seg = np.roll(seg, rotation)\n        new_solution[seg_start:seg_end] = rotated_seg\n\n    # Dynamic node insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective edge insertion with adaptive path reversal to explore high-quality solutions by dynamically selecting and rearranging paths while balancing improvement in both objective spaces through a weighted selection mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Weighted selection of nodes to modify\n    weights = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        weights[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                     distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n    weights = weights / np.sum(weights)\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        # Select a node to remove\n        node_to_remove = np.random.choice(n, p=weights)\n\n        # Find the best position to reinsert\n        min_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n):\n            if pos == node_to_remove or pos == (node_to_remove-1)%n:\n                continue\n\n            # Calculate cost of inserting after pos\n            prev = new_solution[pos]\n            next_node = new_solution[(pos+1)%n]\n\n            cost = (distance_matrix_1[prev, node_to_remove] + distance_matrix_2[prev, node_to_remove] +\n                    distance_matrix_1[node_to_remove, next_node] + distance_matrix_2[node_to_remove, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        # Perform the insertion\n        if best_pos != -1:\n            node = new_solution[node_to_remove]\n            new_solution = np.delete(new_solution, node_to_remove)\n            new_solution = np.insert(new_solution, (best_pos+1)%(n-1), node)\n\n    # Adaptive path reversal\n    for _ in range(2):\n        # Select a path to reverse\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n//2))\n\n        end = (start + length) % n\n\n        if start > end:\n            # Wrap around the end\n            new_solution[start:] = new_solution[start:][::-1]\n            new_solution[:end] = new_solution[:end][::-1]\n        else:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8438155689127607,
            0.8179607391357422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Weighted selection of nodes to modify\n    weights = np.zeros(n)\n    for i in range(n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        weights[i] = (distance_matrix_1[prev, curr] + distance_matrix_2[prev, curr] +\n                     distance_matrix_1[curr, next_node] + distance_matrix_2[curr, next_node])\n\n    weights = weights / np.sum(weights)\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        # Select a node to remove\n        node_to_remove = np.random.choice(n, p=weights)\n\n        # Find the best position to reinsert\n        min_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n):\n            if pos == node_to_remove or pos == (node_to_remove-1)%n:\n                continue\n\n            # Calculate cost of inserting after pos\n            prev = new_solution[pos]\n            next_node = new_solution[(pos+1)%n]\n\n            cost = (distance_matrix_1[prev, node_to_remove] + distance_matrix_2[prev, node_to_remove] +\n                    distance_matrix_1[node_to_remove, next_node] + distance_matrix_2[node_to_remove, next_node])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        # Perform the insertion\n        if best_pos != -1:\n            node = new_solution[node_to_remove]\n            new_solution = np.delete(new_solution, node_to_remove)\n            new_solution = np.insert(new_solution, (best_pos+1)%(n-1), node)\n\n    # Adaptive path reversal\n    for _ in range(2):\n        # Select a path to reverse\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n//2))\n\n        end = (start + length) % n\n\n        if start > end:\n            # Wrap around the end\n            new_solution[start:] = new_solution[start:][::-1]\n            new_solution[:end] = new_solution[:end][::-1]\n        else:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective aware path relinking with adaptive node insertion to explore the solution space by intelligently combining high-quality segments from different solutions while dynamically inserting nodes to maintain feasibility and diversity, leveraging the bi-objective nature of the problem to guide the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two diverse solutions from the archive\n    sol1, _ = random.choice(archive)\n    sol2, _ = random.choice(archive)\n    while np.array_equal(sol1, sol2):\n        sol2, _ = random.choice(archive)\n\n    n = len(sol1)\n    new_solution = np.zeros_like(sol1)\n\n    # Determine the number of segments to take from each solution\n    num_segments = random.randint(2, 5)\n    segment_length = max(1, n // num_segments)\n\n    # Create a mask to track which nodes have been added\n    added_nodes = set()\n\n    # Alternate between solutions to create a new path\n    for i in range(0, n, segment_length):\n        if i // segment_length % 2 == 0:\n            current_sol = sol1\n        else:\n            current_sol = sol2\n\n        # Find the next segment to add\n        for node in current_sol[i:i+segment_length]:\n            if node not in added_nodes:\n                new_solution[i] = node\n                added_nodes.add(node)\n                break\n\n    # Fill remaining positions with nodes not yet added\n    remaining_nodes = [node for node in sol1 if node not in added_nodes]\n    remaining_nodes += [node for node in sol2 if node not in added_nodes]\n    remaining_nodes = list(set(remaining_nodes))\n\n    idx = segment_length * num_segments\n    for node in remaining_nodes:\n        if idx < n:\n            new_solution[idx] = node\n            idx += 1\n\n    # Perform adaptive node insertion to improve the solution\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.94988187683715,
            0.05481475591659546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select two diverse solutions from the archive\n    sol1, _ = random.choice(archive)\n    sol2, _ = random.choice(archive)\n    while np.array_equal(sol1, sol2):\n        sol2, _ = random.choice(archive)\n\n    n = len(sol1)\n    new_solution = np.zeros_like(sol1)\n\n    # Determine the number of segments to take from each solution\n    num_segments = random.randint(2, 5)\n    segment_length = max(1, n // num_segments)\n\n    # Create a mask to track which nodes have been added\n    added_nodes = set()\n\n    # Alternate between solutions to create a new path\n    for i in range(0, n, segment_length):\n        if i // segment_length % 2 == 0:\n            current_sol = sol1\n        else:\n            current_sol = sol2\n\n        # Find the next segment to add\n        for node in current_sol[i:i+segment_length]:\n            if node not in added_nodes:\n                new_solution[i] = node\n                added_nodes.add(node)\n                break\n\n    # Fill remaining positions with nodes not yet added\n    remaining_nodes = [node for node in sol1 if node not in added_nodes]\n    remaining_nodes += [node for node in sol2 if node not in added_nodes]\n    remaining_nodes = list(set(remaining_nodes))\n\n    idx = segment_length * num_segments\n    for node in remaining_nodes:\n        if idx < n:\n            new_solution[idx] = node\n            idx += 1\n\n    # Perform adaptive node insertion to improve the solution\n    for _ in range(3):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm employs adaptive segment decomposition with weighted objective-aware node insertion, where it intelligently decomposes high-performing segments and strategically reinserts nodes based on their normalized combined objective impact, ensuring feasibility through a multi-phase validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment decomposition with weighted objective-aware node insertion\n    for _ in range(4):\n        # Select a segment to decompose\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        total_cost = seg_cost1 + seg_cost2\n\n        if total_cost == 0:\n            continue\n\n        # Decompose the segment by removing nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        # Calculate weights for objective balancing\n        weight1 = seg_cost1 / total_cost\n        weight2 = seg_cost2 / total_cost\n\n        # Reinsert nodes based on weighted objective impact\n        for _ in range(len(segment)):\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Fix duplicates\n        for i in range(n):\n            if np.count_nonzero(new_solution == new_solution[i]) > 1:\n                missing = [node for node in range(n) if node not in new_solution]\n                if missing:\n                    new_solution[i] = missing[0]\n\n        # Phase 2: Ensure all nodes are present\n        missing_nodes = [node for node in range(n) if node not in new_solution]\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.7444243779752839,
            4.085451304912567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment decomposition with weighted objective-aware node insertion\n    for _ in range(4):\n        # Select a segment to decompose\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        total_cost = seg_cost1 + seg_cost2\n\n        if total_cost == 0:\n            continue\n\n        # Decompose the segment by removing nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        # Calculate weights for objective balancing\n        weight1 = seg_cost1 / total_cost\n        weight2 = seg_cost2 / total_cost\n\n        # Reinsert nodes based on weighted objective impact\n        for _ in range(len(segment)):\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Phase 1: Fix duplicates\n        for i in range(n):\n            if np.count_nonzero(new_solution == new_solution[i]) > 1:\n                missing = [node for node in range(n) if node not in new_solution]\n                if missing:\n                    new_solution[i] = missing[0]\n\n        # Phase 2: Ensure all nodes are present\n        missing_nodes = [node for node in range(n) if node not in new_solution]\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with multi-objective edge insertion, where it intelligently selects and inverts segments of the tour while strategically inserting edges based on their combined objective impact, ensuring feasibility through a dynamic validation and repair mechanism to maintain tour validity across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        # Select two random nodes\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the combined cost of inserting edge i-j\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Calculate the cost of removing edge i-(i+1)\n        cost1_remove = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2_remove = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        # If insertion improves both objectives, perform it\n        if (cost1 < cost1_remove and cost2 < cost2_remove):\n            # Insert edge i-j and remove edge i-(i+1)\n            new_solution[i:(i+1)] = new_solution[j]\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8689029335459337,
            0.45987677574157715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Invert the segment\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        # Select two random nodes\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the combined cost of inserting edge i-j\n        cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Calculate the cost of removing edge i-(i+1)\n        cost1_remove = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        cost2_remove = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        # If insertion improves both objectives, perform it\n        if (cost1 < cost1_remove and cost2 < cost2_remove):\n            # Insert edge i-j and remove edge i-(i+1)\n            new_solution[i:(i+1)] = new_solution[j]\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path decomposition with dynamic node insertion, where it intelligently decomposes the solution into high-impact sub-paths, optimizes each sub-path independently based on combined objective criteria, and strategically inserts nodes from other sub-paths to create a cohesive and improved solution while maintaining feasibility through a novel path validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    subpath_size = max(2, min(4, n // 4))\n\n    # Adaptive multi-objective path decomposition and optimization\n    for _ in range(2):\n        # Randomly decompose into sub-paths\n        subpaths = []\n        current_pos = 0\n        while current_pos < n:\n            end_pos = min(current_pos + subpath_size, n)\n            subpaths.append(new_solution[current_pos:end_pos])\n            current_pos = end_pos\n\n        # Optimize each sub-path independently\n        for i in range(len(subpaths)):\n            subpath = subpaths[i]\n            if len(subpath) < 2:\n                continue\n\n            # Evaluate current subpath cost\n            current_cost1 = sum(distance_matrix_1[subpath[j-1], subpath[j]] for j in range(1, len(subpath)))\n            current_cost2 = sum(distance_matrix_2[subpath[j-1], subpath[j]] for j in range(1, len(subpath)))\n            current_total = current_cost1 + current_cost2\n\n            # Try to improve the subpath\n            for _ in range(2):\n                # Randomly select two positions in the subpath\n                a, b = sorted(random.sample(range(len(subpath)), 2))\n                if a == b:\n                    continue\n\n                # Create a new subpath by reversing the segment\n                new_subpath = subpath.copy()\n                new_subpath[a:b+1] = new_subpath[a:b+1][::-1]\n\n                # Evaluate new subpath cost\n                new_cost1 = sum(distance_matrix_1[new_subpath[j-1], new_subpath[j]] for j in range(1, len(new_subpath)))\n                new_cost2 = sum(distance_matrix_2[new_subpath[j-1], new_subpath[j]] for j in range(1, len(new_subpath)))\n                new_total = new_cost1 + new_cost2\n\n                # Accept if improvement\n                if new_total < current_total:\n                    subpaths[i] = new_subpath\n                    current_total = new_total\n\n        # Reconstruct the solution from optimized subpaths\n        new_solution = np.concatenate(subpaths)\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Find a good position to insert this node\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos or (pos > 0 and new_solution[pos-1] == node) or (pos < n-1 and new_solution[pos+1] == node):\n                continue\n\n            # Calculate cost if we insert at this position\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Perform the insertion\n        if best_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            if best_pos > node_pos:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.725638208440216,
            1.45089453458786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    subpath_size = max(2, min(4, n // 4))\n\n    # Adaptive multi-objective path decomposition and optimization\n    for _ in range(2):\n        # Randomly decompose into sub-paths\n        subpaths = []\n        current_pos = 0\n        while current_pos < n:\n            end_pos = min(current_pos + subpath_size, n)\n            subpaths.append(new_solution[current_pos:end_pos])\n            current_pos = end_pos\n\n        # Optimize each sub-path independently\n        for i in range(len(subpaths)):\n            subpath = subpaths[i]\n            if len(subpath) < 2:\n                continue\n\n            # Evaluate current subpath cost\n            current_cost1 = sum(distance_matrix_1[subpath[j-1], subpath[j]] for j in range(1, len(subpath)))\n            current_cost2 = sum(distance_matrix_2[subpath[j-1], subpath[j]] for j in range(1, len(subpath)))\n            current_total = current_cost1 + current_cost2\n\n            # Try to improve the subpath\n            for _ in range(2):\n                # Randomly select two positions in the subpath\n                a, b = sorted(random.sample(range(len(subpath)), 2))\n                if a == b:\n                    continue\n\n                # Create a new subpath by reversing the segment\n                new_subpath = subpath.copy()\n                new_subpath[a:b+1] = new_subpath[a:b+1][::-1]\n\n                # Evaluate new subpath cost\n                new_cost1 = sum(distance_matrix_1[new_subpath[j-1], new_subpath[j]] for j in range(1, len(new_subpath)))\n                new_cost2 = sum(distance_matrix_2[new_subpath[j-1], new_subpath[j]] for j in range(1, len(new_subpath)))\n                new_total = new_cost1 + new_cost2\n\n                # Accept if improvement\n                if new_total < current_total:\n                    subpaths[i] = new_subpath\n                    current_total = new_total\n\n        # Reconstruct the solution from optimized subpaths\n        new_solution = np.concatenate(subpaths)\n\n    # Dynamic node insertion for further refinement\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Find a good position to insert this node\n        best_pos = node_pos\n        best_cost = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos or (pos > 0 and new_solution[pos-1] == node) or (pos < n-1 and new_solution[pos+1] == node):\n                continue\n\n            # Calculate cost if we insert at this position\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        # Perform the insertion\n        if best_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            if best_pos > node_pos:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This novel algorithm employs a dynamic multi-objective path evolution strategy that combines adaptive node insertion with selective path reversal, where it intelligently identifies critical path segments based on their combined objective impact and performs targeted reversals while strategically inserting nodes to maintain feasibility and explore diverse solution spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Identify critical path segments based on combined objective impact\n    segment_size = max(2, min(5, n // 5))\n    critical_segments = []\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        critical_segments.append((i, i+segment_size, seg_cost1 + seg_cost2))\n\n    # Sort segments by impact (descending)\n    critical_segments.sort(key=lambda x: -x[2])\n\n    # Select top segments for reversal\n    for seg_start, seg_end, _ in critical_segments[:2]:\n        if seg_end - seg_start > 1:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Selective node insertion for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Extract a sub-segment and insert it elsewhere\n            sub_segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], sub_segment])\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8620310426387019,
            0.555087685585022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Identify critical path segments based on combined objective impact\n    segment_size = max(2, min(5, n // 5))\n    critical_segments = []\n\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n        critical_segments.append((i, i+segment_size, seg_cost1 + seg_cost2))\n\n    # Sort segments by impact (descending)\n    critical_segments.sort(key=lambda x: -x[2])\n\n    # Select top segments for reversal\n    for seg_start, seg_end, _ in critical_segments[:2]:\n        if seg_end - seg_start > 1:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Selective node insertion for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Extract a sub-segment and insert it elsewhere\n            sub_segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], sub_segment])\n\n    # Ensure feasibility by checking for missing nodes\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore high-quality solutions in both objective spaces by intelligently reinserting nodes and reversing segments while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node and remove it\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8148412050652076,
            0.5069732666015625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node and remove it\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at a new random position\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic path reversal\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This novel algorithm combines hierarchical segment decomposition with adaptive node clustering, where it systematically partitions the tour into hierarchical segments, clusters nodes based on their multi-objective impact, and performs targeted reconstruction while maintaining feasibility through a dynamic segment merging and validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Hierarchical segment decomposition\n    levels = 3\n    segment_sizes = [max(2, n // (2**i)) for i in range(levels)]\n\n    for size in segment_sizes:\n        for _ in range(2):\n            # Randomly select a segment\n            seg_start = random.randint(0, n - size)\n            seg_end = seg_start + size\n            segment = new_solution[seg_start:seg_end]\n\n            # Cluster nodes in the segment based on multi-objective impact\n            nodes = list(segment)\n            clusters = []\n            while nodes:\n                # Select a random node as cluster center\n                center = random.choice(nodes)\n                cluster = [center]\n                nodes.remove(center)\n\n                # Add nearby nodes to the cluster\n                for node in list(nodes):\n                    # Calculate distance to center in both objectives\n                    dist1 = distance_matrix_1[center, node]\n                    dist2 = distance_matrix_2[center, node]\n                    if (dist1 + dist2) < (distance_matrix_1[0,0] + distance_matrix_2[0,0]) * 0.5:\n                        cluster.append(node)\n                        nodes.remove(node)\n\n                clusters.append(cluster)\n\n            # Reconstruct the segment by ordering clusters\n            new_segment = []\n            for cluster in clusters:\n                # Order nodes within the cluster based on combined distance to neighbors\n                ordered_cluster = []\n                while cluster:\n                    if not ordered_cluster:\n                        # Start with the node closest to the segment's start\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        best_node = min(cluster, key=lambda x: distance_matrix_1[prev_node, x] + distance_matrix_2[prev_node, x])\n                    else:\n                        # Add the node that minimizes the combined distance to previous and next\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                        best_node = min(cluster, key=lambda x: (distance_matrix_1[ordered_cluster[-1], x] +\n                                                               distance_matrix_2[ordered_cluster[-1], x] +\n                                                               distance_matrix_1[x, next_node] +\n                                                               distance_matrix_2[x, next_node]))\n                    ordered_cluster.append(best_node)\n                    cluster.remove(best_node)\n\n                new_segment.extend(ordered_cluster)\n\n            # Replace the segment\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic segment merging for further refinement\n    for _ in range(2):\n        if n > 5:\n            merge_size = random.randint(2, min(5, n // 4))\n            merge_start = random.randint(0, n - merge_size)\n            merge_end = merge_start + merge_size\n\n            # Try to merge the segment by reordering nodes\n            segment = new_solution[merge_start:merge_end]\n            shuffled = list(segment)\n            random.shuffle(shuffled)\n\n            # Evaluate the shuffled segment\n            prev_node = new_solution[merge_start-1] if merge_start > 0 else new_solution[-1]\n            next_node = new_solution[merge_end] if merge_end < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] +\n                         distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n\n            new_cost = (distance_matrix_1[prev_node, shuffled[0]] + distance_matrix_1[shuffled[-1], next_node] +\n                        distance_matrix_2[prev_node, shuffled[0]] + distance_matrix_2[shuffled[-1], next_node])\n\n            if new_cost < orig_cost:\n                new_solution[merge_start:merge_end] = shuffled\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6974078674593464,
            3.6494069695472717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Hierarchical segment decomposition\n    levels = 3\n    segment_sizes = [max(2, n // (2**i)) for i in range(levels)]\n\n    for size in segment_sizes:\n        for _ in range(2):\n            # Randomly select a segment\n            seg_start = random.randint(0, n - size)\n            seg_end = seg_start + size\n            segment = new_solution[seg_start:seg_end]\n\n            # Cluster nodes in the segment based on multi-objective impact\n            nodes = list(segment)\n            clusters = []\n            while nodes:\n                # Select a random node as cluster center\n                center = random.choice(nodes)\n                cluster = [center]\n                nodes.remove(center)\n\n                # Add nearby nodes to the cluster\n                for node in list(nodes):\n                    # Calculate distance to center in both objectives\n                    dist1 = distance_matrix_1[center, node]\n                    dist2 = distance_matrix_2[center, node]\n                    if (dist1 + dist2) < (distance_matrix_1[0,0] + distance_matrix_2[0,0]) * 0.5:\n                        cluster.append(node)\n                        nodes.remove(node)\n\n                clusters.append(cluster)\n\n            # Reconstruct the segment by ordering clusters\n            new_segment = []\n            for cluster in clusters:\n                # Order nodes within the cluster based on combined distance to neighbors\n                ordered_cluster = []\n                while cluster:\n                    if not ordered_cluster:\n                        # Start with the node closest to the segment's start\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        best_node = min(cluster, key=lambda x: distance_matrix_1[prev_node, x] + distance_matrix_2[prev_node, x])\n                    else:\n                        # Add the node that minimizes the combined distance to previous and next\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                        best_node = min(cluster, key=lambda x: (distance_matrix_1[ordered_cluster[-1], x] +\n                                                               distance_matrix_2[ordered_cluster[-1], x] +\n                                                               distance_matrix_1[x, next_node] +\n                                                               distance_matrix_2[x, next_node]))\n                    ordered_cluster.append(best_node)\n                    cluster.remove(best_node)\n\n                new_segment.extend(ordered_cluster)\n\n            # Replace the segment\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic segment merging for further refinement\n    for _ in range(2):\n        if n > 5:\n            merge_size = random.randint(2, min(5, n // 4))\n            merge_start = random.randint(0, n - merge_size)\n            merge_end = merge_start + merge_size\n\n            # Try to merge the segment by reordering nodes\n            segment = new_solution[merge_start:merge_end]\n            shuffled = list(segment)\n            random.shuffle(shuffled)\n\n            # Evaluate the shuffled segment\n            prev_node = new_solution[merge_start-1] if merge_start > 0 else new_solution[-1]\n            next_node = new_solution[merge_end] if merge_end < n else new_solution[0]\n\n            orig_cost = (distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node] +\n                         distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node])\n\n            new_cost = (distance_matrix_1[prev_node, shuffled[0]] + distance_matrix_1[shuffled[-1], next_node] +\n                        distance_matrix_2[prev_node, shuffled[0]] + distance_matrix_2[shuffled[-1], next_node])\n\n            if new_cost < orig_cost:\n                new_solution[merge_start:merge_end] = shuffled\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path reconstruction with dynamic node reinsertion, where it intelligently reconstructs critical path segments by reinserting nodes at positions that optimize both objectives while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive path reconstruction\n    for _ in range(2):\n        # Select a critical path segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = seg_start + 3\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment and reinsert nodes at optimized positions\n        remaining_nodes = [node for node in new_solution if node not in segment]\n\n        # Calculate insertion costs for each node\n        insertion_costs = []\n        for pos in range(n - 2):\n            if pos >= seg_start and pos < seg_end:\n                continue\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, next_node]\n\n            for node in segment:\n                new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                delta1 = new_cost1 - cost1\n                delta2 = new_cost2 - cost2\n                combined_delta = delta1 + delta2\n                insertion_costs.append((combined_delta, pos, node))\n\n        # Sort by combined delta and insert nodes\n        insertion_costs.sort(key=lambda x: x[0])\n        for _, pos, node in insertion_costs[:3]:\n            if node not in remaining_nodes:\n                continue\n            new_solution = np.insert(new_solution, pos, node)\n            remaining_nodes.remove(node)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    # Probabilistic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is a valid tour\n    new_solution = np.append(new_solution[:-1], new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8856854299277781,
            0.9695802330970764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive path reconstruction\n    for _ in range(2):\n        # Select a critical path segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = seg_start + 3\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment and reinsert nodes at optimized positions\n        remaining_nodes = [node for node in new_solution if node not in segment]\n\n        # Calculate insertion costs for each node\n        insertion_costs = []\n        for pos in range(n - 2):\n            if pos >= seg_start and pos < seg_end:\n                continue\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < n else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, next_node]\n\n            for node in segment:\n                new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                delta1 = new_cost1 - cost1\n                delta2 = new_cost2 - cost2\n                combined_delta = delta1 + delta2\n                insertion_costs.append((combined_delta, pos, node))\n\n        # Sort by combined delta and insert nodes\n        insertion_costs.sort(key=lambda x: x[0])\n        for _, pos, node in insertion_costs[:3]:\n            if node not in remaining_nodes:\n                continue\n            new_solution = np.insert(new_solution, pos, node)\n            remaining_nodes.remove(node)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][1])\n\n    # Probabilistic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution is a valid tour\n    new_solution = np.append(new_solution[:-1], new_solution[0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path optimization to explore high-quality solutions by strategically inserting nodes and optimizing paths while balancing improvements in both objective spaces through adaptive decision-making.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node in a new position\n        new_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Dynamic path optimization\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Further refine by swapping nodes based on objective improvements\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8197932177242772,
            0.5311197638511658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to insert elsewhere\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node in a new position\n        new_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Dynamic path optimization\n    for _ in range(2):\n        # Select a random segment to reverse\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Further refine by swapping nodes based on objective improvements\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        # Calculate potential improvement in both objectives\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept swap if it improves at least one objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This novel algorithm employs adaptive multi-objective segment refinement with dynamic node prioritization, where it selectively optimizes segments based on their combined objective impact while strategically reallocating nodes with weighted objective scores, ensuring feasibility through an enhanced segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive multi-objective segment refinement\n    for _ in range(3):\n        # Select a segment to refine\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = 0.6 * seg_cost1 + 0.4 * seg_cost2\n\n        # Refine the segment by reallocating nodes with weighted scoring\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on weighted objective impact\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = 0.6 * cost1 + 0.4 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate weighted score for swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (0.6 * (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                                   distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]) +\n                             0.4 * (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                                   distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]))\n\n            swapped_cost = (0.6 * (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                                  distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) +\n                           0.4 * (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                                 distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]))\n\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Enhanced segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes with minimal impact\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                # Find insertion position with minimal weighted cost\n                best_pos = -1\n                best_cost = float('inf')\n                for pos in range(n):\n                    prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    next_node = new_solution[pos] if pos < n else new_solution[0]\n                    cost1 = distance_matrix_1[prev_node, missing[0]] + distance_matrix_1[missing[0], next_node]\n                    cost2 = distance_matrix_2[prev_node, missing[0]] + distance_matrix_2[missing[0], next_node]\n                    total_cost = 0.6 * cost1 + 0.4 * cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n                # Insert missing node at best position\n                new_solution = np.insert(new_solution, best_pos, missing.pop(0))[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.9220511074948111,
            1.0145555138587952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive multi-objective segment refinement\n    for _ in range(3):\n        # Select a segment to refine\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = 0.6 * seg_cost1 + 0.4 * seg_cost2\n\n        # Refine the segment by reallocating nodes with weighted scoring\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on weighted objective impact\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = 0.6 * cost1 + 0.4 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate weighted score for swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (0.6 * (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                                   distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]) +\n                             0.4 * (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                                   distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]))\n\n            swapped_cost = (0.6 * (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                                  distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]) +\n                           0.4 * (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                                 distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]))\n\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Enhanced segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes with minimal impact\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                # Find insertion position with minimal weighted cost\n                best_pos = -1\n                best_cost = float('inf')\n                for pos in range(n):\n                    prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n                    next_node = new_solution[pos] if pos < n else new_solution[0]\n                    cost1 = distance_matrix_1[prev_node, missing[0]] + distance_matrix_1[missing[0], next_node]\n                    cost2 = distance_matrix_2[prev_node, missing[0]] + distance_matrix_2[missing[0], next_node]\n                    total_cost = 0.6 * cost1 + 0.4 * cost2\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = pos\n                # Insert missing node at best position\n                new_solution = np.insert(new_solution, best_pos, missing.pop(0))[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{An adaptive hybrid local search strategy that combines dynamic path inversion with multi-objective segment relocation to explore diverse neighborhoods by strategically inverting segments and relocating them based on their potential to improve both objectives while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Dynamic path inversion\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective segment relocation\n    for _ in range(2):\n        # Select a segment to relocate\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate potential insertion points based on both objectives\n        best_pos = -1\n        best_cost = (float('inf'), float('inf'))\n\n        for pos in range(n - segment_size + 1):\n            if pos >= seg_start and pos <= seg_end:\n                continue  # Skip original position\n\n            # Insert segment at position pos\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:seg_start],\n                new_solution[seg_end:]\n            ])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            # Pareto dominance check\n            if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n                best_pos = pos\n                best_cost = (cost1, cost2)\n\n        if best_pos != -1:\n            # Apply the best relocation\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:seg_start],\n                new_solution[seg_end:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7850241768881765,
            4.349552512168884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Dynamic path inversion\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Multi-objective segment relocation\n    for _ in range(2):\n        # Select a segment to relocate\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate potential insertion points based on both objectives\n        best_pos = -1\n        best_cost = (float('inf'), float('inf'))\n\n        for pos in range(n - segment_size + 1):\n            if pos >= seg_start and pos <= seg_end:\n                continue  # Skip original position\n\n            # Insert segment at position pos\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:seg_start],\n                new_solution[seg_end:]\n            ])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            # Pareto dominance check\n            if (cost1 < best_cost[0] and cost2 <= best_cost[1]) or (cost1 <= best_cost[0] and cost2 < best_cost[1]):\n                best_pos = pos\n                best_cost = (cost1, cost2)\n\n        if best_pos != -1:\n            # Apply the best relocation\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:seg_start],\n                new_solution[seg_end:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic path reversal to explore the solution space by intelligently inserting nodes and reversing segments while maintaining feasibility and balancing improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine insertion points and segment size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive node insertion\n    for _ in range(2):\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != 0 and node_to_insert != new_solution[insert_pos]:\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Dynamic path reversal\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.8633345058886479,
            0.528613269329071
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine insertion points and segment size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive node insertion\n    for _ in range(2):\n        node_to_insert = random.choice(new_solution)\n        insert_pos = random.randint(0, n - 1)\n        if insert_pos != 0 and node_to_insert != new_solution[insert_pos]:\n            new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Dynamic path reversal\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility by removing duplicates\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{This novel algorithm employs adaptive multi-objective path optimization with dynamic segment inversion and weighted node reallocation, where it intelligently inverts high-impact segments while strategically reallocating nodes based on a weighted objective score, ensuring feasibility through a probabilistic segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weighted = 0.7 * seg_cost1 + 0.3 * seg_cost2\n\n        if seg_weighted > 0.6 * (distance_matrix_1.mean() + distance_matrix_2.mean()):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n            if (0.6 * cost1_after + 0.4 * cost2_after) < (0.6 * cost1_before + 0.4 * cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7530980011493449,
            0.5524264574050903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weighted = 0.7 * seg_cost1 + 0.3 * seg_cost2\n\n        if seg_weighted > 0.6 * (distance_matrix_1.mean() + distance_matrix_2.mean()):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n            if (0.6 * cost1_after + 0.4 * cost2_after) < (0.6 * cost1_before + 0.4 * cost2_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with dynamic edge reversal to explore high-quality solutions by intelligently rearranging segments and reversing edges while maintaining feasibility and balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):  # Perform multiple insertions\n        # Select a segment and a position to insert it\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        insert_pos = random.randint(0, n - segment_size)\n\n        # Ensure the insertion maintains feasibility\n        if insert_pos >= seg_start and insert_pos < seg_end:\n            continue\n\n        # Extract and reinsert the segment\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Dynamic edge reversal for further refinement\n    for _ in range(4):  # Perform multiple edge reversals\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the reversal maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.831181508844814,
            0.1081380844116211
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3))\n\n    # Adaptive segment insertion\n    for _ in range(3):  # Perform multiple insertions\n        # Select a segment and a position to insert it\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        insert_pos = random.randint(0, n - segment_size)\n\n        # Ensure the insertion maintains feasibility\n        if insert_pos >= seg_start and insert_pos < seg_end:\n            continue\n\n        # Extract and reinsert the segment\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Dynamic edge reversal for further refinement\n    for _ in range(4):  # Perform multiple edge reversals\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the reversal maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore high-quality solutions by intelligently inverting segments of the tour and inserting nodes at positions that balance improvement in both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(2):\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7807552271303696,
            0.49128109216690063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion\n    for _ in range(2):\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_pos = random.randint(0, n - 1)\n        if new_pos != node_pos:\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This novel algorithm combines hierarchical objective-aware path decomposition with adaptive multi-segment inversion, where it first decomposes the tour into hierarchical segments based on objective dominance, then adaptively inverts and reorders these segments while preserving feasibility through a dynamic segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Hierarchical objective-aware path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate edge costs in both objectives\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Check if this edge is dominated by another in the segment\n        dominated = False\n        for seg_node in current_segment:\n            seg_cost1 = distance_matrix_1[seg_node, node]\n            seg_cost2 = distance_matrix_2[seg_node, node]\n            if (seg_cost1 <= cost1 and seg_cost2 <= cost2) and (seg_cost1 < cost1 or seg_cost2 < cost2):\n                dominated = True\n                break\n\n        if dominated:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Adaptive multi-segment inversion\n    if len(segments) > 1:\n        for _ in range(min(3, len(segments))):\n            # Select segments to invert\n            seg_indices = random.sample(range(len(segments)), min(2, len(segments)))\n            seg_indices.sort()\n\n            # Invert the selected segments\n            for idx in seg_indices:\n                segments[idx] = segments[idx][::-1]\n\n            # Reconstruct the solution\n            new_solution = []\n            for seg in segments:\n                new_solution.extend(seg)\n\n            # Ensure the tour is circular\n            if new_solution[0] != new_solution[-1]:\n                new_solution = np.roll(new_solution, -np.where(new_solution == new_solution[0])[0][0])\n\n    # Dynamic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.462908216008122,
            0.8462163209915161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Hierarchical objective-aware path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n\n        # Calculate edge costs in both objectives\n        cost1 = distance_matrix_1[prev_node, node]\n        cost2 = distance_matrix_2[prev_node, node]\n\n        # Check if this edge is dominated by another in the segment\n        dominated = False\n        for seg_node in current_segment:\n            seg_cost1 = distance_matrix_1[seg_node, node]\n            seg_cost2 = distance_matrix_2[seg_node, node]\n            if (seg_cost1 <= cost1 and seg_cost2 <= cost2) and (seg_cost1 < cost1 or seg_cost2 < cost2):\n                dominated = True\n                break\n\n        if dominated:\n            segments.append(current_segment)\n            current_segment = [node]\n        else:\n            current_segment.append(node)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Adaptive multi-segment inversion\n    if len(segments) > 1:\n        for _ in range(min(3, len(segments))):\n            # Select segments to invert\n            seg_indices = random.sample(range(len(segments)), min(2, len(segments)))\n            seg_indices.sort()\n\n            # Invert the selected segments\n            for idx in seg_indices:\n                segments[idx] = segments[idx][::-1]\n\n            # Reconstruct the solution\n            new_solution = []\n            for seg in segments:\n                new_solution.extend(seg)\n\n            # Ensure the tour is circular\n            if new_solution[0] != new_solution[-1]:\n                new_solution = np.roll(new_solution, -np.where(new_solution == new_solution[0])[0][0])\n\n    # Dynamic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with multi-objective edge evaluation to explore the solution space by strategically relocating nodes and evaluating their impact on both objectives, while dynamically balancing the exploration of both objective spaces through probabilistic selection of improvement criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with multi-objective evaluation\n    for _ in range(3):  # Perform multiple insertions\n        # Select a random node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Evaluate potential insertion positions\n        best_pos = 0\n        best_score = float('inf')\n\n        # Consider both objectives with probabilistic weighting\n        obj_weight = random.random()\n\n        for pos in range(n-1):\n            # Calculate the change in both objectives\n            if pos == 0:\n                delta1 = (distance_matrix_1[new_solution[-1], node] +\n                          distance_matrix_1[node, new_solution[pos+1]] -\n                          distance_matrix_1[new_solution[-1], new_solution[pos+1]])\n                delta2 = (distance_matrix_2[new_solution[-1], node] +\n                          distance_matrix_2[node, new_solution[pos+1]] -\n                          distance_matrix_2[new_solution[-1], new_solution[pos+1]])\n            elif pos == n-2:\n                delta1 = (distance_matrix_1[new_solution[pos-1], node] +\n                          distance_matrix_1[node, new_solution[0]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[0]])\n                delta2 = (distance_matrix_2[new_solution[pos-1], node] +\n                          distance_matrix_2[node, new_solution[0]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[0]])\n            else:\n                delta1 = (distance_matrix_1[new_solution[pos-1], node] +\n                          distance_matrix_1[node, new_solution[pos+1]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos+1]])\n                delta2 = (distance_matrix_2[new_solution[pos-1], node] +\n                          distance_matrix_2[node, new_solution[pos+1]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos+1]])\n\n            # Combine the objectives with probabilistic weighting\n            combined_score = obj_weight * delta1 + (1 - obj_weight) * delta2\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9077652621503783,
            0.9317310452461243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with multi-objective evaluation\n    for _ in range(3):  # Perform multiple insertions\n        # Select a random node to relocate\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Evaluate potential insertion positions\n        best_pos = 0\n        best_score = float('inf')\n\n        # Consider both objectives with probabilistic weighting\n        obj_weight = random.random()\n\n        for pos in range(n-1):\n            # Calculate the change in both objectives\n            if pos == 0:\n                delta1 = (distance_matrix_1[new_solution[-1], node] +\n                          distance_matrix_1[node, new_solution[pos+1]] -\n                          distance_matrix_1[new_solution[-1], new_solution[pos+1]])\n                delta2 = (distance_matrix_2[new_solution[-1], node] +\n                          distance_matrix_2[node, new_solution[pos+1]] -\n                          distance_matrix_2[new_solution[-1], new_solution[pos+1]])\n            elif pos == n-2:\n                delta1 = (distance_matrix_1[new_solution[pos-1], node] +\n                          distance_matrix_1[node, new_solution[0]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[0]])\n                delta2 = (distance_matrix_2[new_solution[pos-1], node] +\n                          distance_matrix_2[node, new_solution[0]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[0]])\n            else:\n                delta1 = (distance_matrix_1[new_solution[pos-1], node] +\n                          distance_matrix_1[node, new_solution[pos+1]] -\n                          distance_matrix_1[new_solution[pos-1], new_solution[pos+1]])\n                delta2 = (distance_matrix_2[new_solution[pos-1], node] +\n                          distance_matrix_2[node, new_solution[pos+1]] -\n                          distance_matrix_2[new_solution[pos-1], new_solution[pos+1]])\n\n            # Combine the objectives with probabilistic weighting\n            combined_score = obj_weight * delta1 + (1 - obj_weight) * delta2\n\n            if combined_score < best_score:\n                best_score = combined_score\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This adaptive multi-objective tour reconstruction algorithm combines segment-wise optimization with dynamic node redistribution, where it selectively reconstructs high-impact segments while strategically reallocating nodes based on their normalized objective contributions, ensuring feasibility through an intelligent segment reassembly mechanism with adaptive validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Normalize the objectives\n    costs1 = [obj[0] for _, obj in archive]\n    costs2 = [obj[1] for _, obj in archive]\n    min1, max1 = min(costs1), max(costs1)\n    min2, max2 = min(costs2), max(costs2)\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(2):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        norm_cost1 = (seg_cost1 - min1) / (max1 - min1 + 1e-8)\n        norm_cost2 = (seg_cost2 - min2) / (max2 - min2 + 1e-8)\n        seg_score = norm_cost1 + norm_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on normalized objective impact\n            candidates = random.sample(remaining_nodes, min(2, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                norm_cost1 = (cost1 - min1) / (max1 - min1 + 1e-8)\n                norm_cost2 = (cost2 - min2) / (max2 - min2 + 1e-8)\n                score = norm_cost1 + norm_cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node redistribution for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reassembly and validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reassemble by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8938801207173372,
            0.7886197566986084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Normalize the objectives\n    costs1 = [obj[0] for _, obj in archive]\n    costs2 = [obj[1] for _, obj in archive]\n    min1, max1 = min(costs1), max(costs1)\n    min2, max2 = min(costs2), max(costs2)\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(2):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        norm_cost1 = (seg_cost1 - min1) / (max1 - min1 + 1e-8)\n        norm_cost2 = (seg_cost2 - min2) / (max2 - min2 + 1e-8)\n        seg_score = norm_cost1 + norm_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on normalized objective impact\n            candidates = random.sample(remaining_nodes, min(2, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                norm_cost1 = (cost1 - min1) / (max1 - min1 + 1e-8)\n                norm_cost2 = (cost2 - min2) / (max2 - min2 + 1e-8)\n                score = norm_cost1 + norm_cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node redistribution for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reassembly and validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Reassemble by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm employs a multi-stage evolutionary refinement process that combines adaptive node clustering with dynamic path optimization, where it first partitions the tour into objective-specific clusters, then optimizes each cluster's path using a hybrid of greedy and probabilistic selection, followed by cross-cluster edge refinement to balance the bi-objective trade-off while maintaining feasibility through a novel cluster validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    cluster_size = max(3, min(7, n // 5))\n\n    # Adaptive node clustering based on objective preferences\n    clusters = []\n    remaining_nodes = list(new_solution)\n    while remaining_nodes:\n        cluster = random.sample(remaining_nodes, min(cluster_size, len(remaining_nodes)))\n        clusters.append(cluster)\n        for node in cluster:\n            remaining_nodes.remove(node)\n\n    # Optimize each cluster's path\n    for cluster in clusters:\n        cluster_indices = [i for i, node in enumerate(new_solution) if node in cluster]\n        if len(cluster_indices) < 2:\n            continue\n\n        # Determine which objective to prioritize for this cluster\n        obj1_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in cluster_indices)\n        obj2_cost = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in cluster_indices)\n        prioritize_obj1 = obj1_cost > obj2_cost\n\n        # Optimize cluster path\n        for _ in range(2):\n            i, j = random.sample(cluster_indices, 2)\n            if i > j:\n                i, j = j, i\n\n            # Evaluate potential swap\n            prev_i = cluster_indices[cluster_indices.index(i)-1] if i > 0 else cluster_indices[-1]\n            next_i = cluster_indices[cluster_indices.index(i)+1] if i < len(cluster_indices)-1 else cluster_indices[0]\n            prev_j = cluster_indices[cluster_indices.index(j)-1] if j > 0 else cluster_indices[-1]\n            next_j = cluster_indices[cluster_indices.index(j)+1] if j < len(cluster_indices)-1 else cluster_indices[0]\n\n            cost1 = (distance_matrix_1[new_solution[prev_i], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[next_i]] +\n                    distance_matrix_1[new_solution[prev_j], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[next_j]])\n\n            cost2 = (distance_matrix_2[new_solution[prev_i], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[next_i]] +\n                    distance_matrix_2[new_solution[prev_j], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[next_j]])\n\n            if prioritize_obj1 and cost1 < obj1_cost or not prioritize_obj1 and cost2 < obj2_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cross-cluster edge refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Skip circular edges\n\n        # Evaluate potential edge swap\n        prev_i = i-1 if i > 0 else n-1\n        next_i = i+1 if i < n-1 else 0\n        prev_j = j-1 if j > 0 else n-1\n        next_j = j+1 if j < n-1 else 0\n\n        cost1 = (distance_matrix_1[new_solution[prev_i], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[next_i]] +\n                distance_matrix_1[new_solution[prev_j], new_solution[i]] +\n                distance_matrix_1[new_solution[i], new_solution[next_j]])\n\n        cost2 = (distance_matrix_2[new_solution[prev_i], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[next_i]] +\n                distance_matrix_2[new_solution[prev_j], new_solution[i]] +\n                distance_matrix_2[new_solution[i], new_solution[next_j]])\n\n        if cost1 + cost2 < (distance_matrix_1[new_solution[prev_i], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[next_i]] +\n                           distance_matrix_2[new_solution[prev_i], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[next_i]] +\n                           distance_matrix_1[new_solution[prev_j], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[next_j]] +\n                           distance_matrix_2[new_solution[prev_j], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[next_j]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cluster validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8734232929240571,
            0.7826964259147644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    cluster_size = max(3, min(7, n // 5))\n\n    # Adaptive node clustering based on objective preferences\n    clusters = []\n    remaining_nodes = list(new_solution)\n    while remaining_nodes:\n        cluster = random.sample(remaining_nodes, min(cluster_size, len(remaining_nodes)))\n        clusters.append(cluster)\n        for node in cluster:\n            remaining_nodes.remove(node)\n\n    # Optimize each cluster's path\n    for cluster in clusters:\n        cluster_indices = [i for i, node in enumerate(new_solution) if node in cluster]\n        if len(cluster_indices) < 2:\n            continue\n\n        # Determine which objective to prioritize for this cluster\n        obj1_cost = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in cluster_indices)\n        obj2_cost = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in cluster_indices)\n        prioritize_obj1 = obj1_cost > obj2_cost\n\n        # Optimize cluster path\n        for _ in range(2):\n            i, j = random.sample(cluster_indices, 2)\n            if i > j:\n                i, j = j, i\n\n            # Evaluate potential swap\n            prev_i = cluster_indices[cluster_indices.index(i)-1] if i > 0 else cluster_indices[-1]\n            next_i = cluster_indices[cluster_indices.index(i)+1] if i < len(cluster_indices)-1 else cluster_indices[0]\n            prev_j = cluster_indices[cluster_indices.index(j)-1] if j > 0 else cluster_indices[-1]\n            next_j = cluster_indices[cluster_indices.index(j)+1] if j < len(cluster_indices)-1 else cluster_indices[0]\n\n            cost1 = (distance_matrix_1[new_solution[prev_i], new_solution[j]] +\n                    distance_matrix_1[new_solution[j], new_solution[next_i]] +\n                    distance_matrix_1[new_solution[prev_j], new_solution[i]] +\n                    distance_matrix_1[new_solution[i], new_solution[next_j]])\n\n            cost2 = (distance_matrix_2[new_solution[prev_i], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[next_i]] +\n                    distance_matrix_2[new_solution[prev_j], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[next_j]])\n\n            if prioritize_obj1 and cost1 < obj1_cost or not prioritize_obj1 and cost2 < obj2_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cross-cluster edge refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            continue  # Skip circular edges\n\n        # Evaluate potential edge swap\n        prev_i = i-1 if i > 0 else n-1\n        next_i = i+1 if i < n-1 else 0\n        prev_j = j-1 if j > 0 else n-1\n        next_j = j+1 if j < n-1 else 0\n\n        cost1 = (distance_matrix_1[new_solution[prev_i], new_solution[j]] +\n                distance_matrix_1[new_solution[j], new_solution[next_i]] +\n                distance_matrix_1[new_solution[prev_j], new_solution[i]] +\n                distance_matrix_1[new_solution[i], new_solution[next_j]])\n\n        cost2 = (distance_matrix_2[new_solution[prev_i], new_solution[j]] +\n                distance_matrix_2[new_solution[j], new_solution[next_i]] +\n                distance_matrix_2[new_solution[prev_j], new_solution[i]] +\n                distance_matrix_2[new_solution[i], new_solution[next_j]])\n\n        if cost1 + cost2 < (distance_matrix_1[new_solution[prev_i], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[next_i]] +\n                           distance_matrix_2[new_solution[prev_i], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[next_i]] +\n                           distance_matrix_1[new_solution[prev_j], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[next_j]] +\n                           distance_matrix_2[new_solution[prev_j], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[next_j]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cluster validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8934309723087848,
            1.0240108966827393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment reversal with dynamic node insertion to explore high-quality solutions in both objective spaces by intelligently reversing segments of the tour and inserting nodes in a way that balances the trade-off between the two objectives while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment reversal\n    for _ in range(3):  # Perform multiple reversals\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(2):  # Perform multiple insertions\n        # Select a node to remove and reinsert\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Calculate insertion costs considering both objectives\n        insertion_costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i]\n\n            # Calculate cost in both spaces\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine costs with a simple weighted sum\n            total_cost = cost1 + cost2\n            insertion_costs.append((total_cost, i))\n\n        # Select the best insertion position\n        best_cost, best_pos = min(insertion_costs, key=lambda x: x[0])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7335819832229526,
            0.7273455262184143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment reversal\n    for _ in range(3):  # Perform multiple reversals\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(2):  # Perform multiple insertions\n        # Select a node to remove and reinsert\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Calculate insertion costs considering both objectives\n        insertion_costs = []\n        for i in range(len(new_solution)):\n            prev_node = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i]\n\n            # Calculate cost in both spaces\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            # Combine costs with a simple weighted sum\n            total_cost = cost1 + cost2\n            insertion_costs.append((total_cost, i))\n\n        # Select the best insertion position\n        best_cost, best_pos = min(insertion_costs, key=lambda x: x[0])\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This novel algorithm employs adaptive multi-objective path decomposition with dynamic node reinsertion, where it strategically partitions the tour into segments, evaluates their combined objective impact, and reinserts nodes at optimal positions while maintaining feasibility through a segment-wise validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective path decomposition\n    for _ in range(3):\n        # Select a segment to decompose\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment and store its nodes\n        remaining_nodes = np.delete(new_solution, range(seg_start, seg_end))\n        removed_nodes = segment.copy()\n\n        # Find optimal insertion point for the segment\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(remaining_nodes) - len(removed_nodes) + 1):\n            # Calculate insertion cost\n            prev_node = remaining_nodes[pos - 1] if pos > 0 else remaining_nodes[-1]\n            next_node = remaining_nodes[pos] if pos < len(remaining_nodes) else remaining_nodes[0]\n\n            # Cost for first node in segment\n            cost1 = distance_matrix_1[prev_node, removed_nodes[0]] + distance_matrix_1[removed_nodes[0], next_node]\n            cost2 = distance_matrix_2[prev_node, removed_nodes[0]] + distance_matrix_2[removed_nodes[0], next_node]\n\n            # Cost for middle nodes\n            for i in range(1, len(removed_nodes)):\n                cost1 += distance_matrix_1[removed_nodes[i-1], removed_nodes[i]]\n                cost2 += distance_matrix_2[removed_nodes[i-1], removed_nodes[i]]\n\n            # Cost for last node in segment\n            if len(removed_nodes) > 1:\n                cost1 += distance_matrix_1[removed_nodes[-1], next_node]\n                cost2 += distance_matrix_2[removed_nodes[-1], next_node]\n\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = pos\n\n        # Reinsert the segment at the best position\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                remaining_nodes[:best_pos],\n                removed_nodes,\n                remaining_nodes[best_pos:]\n            ])\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        remaining_nodes = np.delete(new_solution, node_idx)\n\n        # Find optimal insertion point\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(remaining_nodes) + 1):\n            prev_node = remaining_nodes[pos - 1] if pos > 0 else remaining_nodes[-1]\n            next_node = remaining_nodes[pos] if pos < len(remaining_nodes) else remaining_nodes[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = pos\n\n        # Reinsert the node at the best position\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                remaining_nodes[:best_pos],\n                [node],\n                remaining_nodes[best_pos:]\n            ])\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8635673451439286,
            1.4445549249649048
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective path decomposition\n    for _ in range(3):\n        # Select a segment to decompose\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Remove the segment and store its nodes\n        remaining_nodes = np.delete(new_solution, range(seg_start, seg_end))\n        removed_nodes = segment.copy()\n\n        # Find optimal insertion point for the segment\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(remaining_nodes) - len(removed_nodes) + 1):\n            # Calculate insertion cost\n            prev_node = remaining_nodes[pos - 1] if pos > 0 else remaining_nodes[-1]\n            next_node = remaining_nodes[pos] if pos < len(remaining_nodes) else remaining_nodes[0]\n\n            # Cost for first node in segment\n            cost1 = distance_matrix_1[prev_node, removed_nodes[0]] + distance_matrix_1[removed_nodes[0], next_node]\n            cost2 = distance_matrix_2[prev_node, removed_nodes[0]] + distance_matrix_2[removed_nodes[0], next_node]\n\n            # Cost for middle nodes\n            for i in range(1, len(removed_nodes)):\n                cost1 += distance_matrix_1[removed_nodes[i-1], removed_nodes[i]]\n                cost2 += distance_matrix_2[removed_nodes[i-1], removed_nodes[i]]\n\n            # Cost for last node in segment\n            if len(removed_nodes) > 1:\n                cost1 += distance_matrix_1[removed_nodes[-1], next_node]\n                cost2 += distance_matrix_2[removed_nodes[-1], next_node]\n\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = pos\n\n        # Reinsert the segment at the best position\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                remaining_nodes[:best_pos],\n                removed_nodes,\n                remaining_nodes[best_pos:]\n            ])\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node\n        remaining_nodes = np.delete(new_solution, node_idx)\n\n        # Find optimal insertion point\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(remaining_nodes) + 1):\n            prev_node = remaining_nodes[pos - 1] if pos > 0 else remaining_nodes[-1]\n            next_node = remaining_nodes[pos] if pos < len(remaining_nodes) else remaining_nodes[0]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_pos = pos\n\n        # Reinsert the node at the best position\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                remaining_nodes[:best_pos],\n                [node],\n                remaining_nodes[best_pos:]\n            ])\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm employs a hybrid approach of multi-objective path decomposition and adaptive node insertion, where it intelligently partitions the tour into critical segments, evaluates their impact across both objectives, and strategically inserts nodes from other segments to improve the overall solution while maintaining feasibility through a combination of segment validation and path repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Multi-objective path decomposition\n    for _ in range(2):\n        # Select a segment to decompose\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Decompose and reinsert nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for node in segment:\n            # Evaluate insertion points\n            best_pos = -1\n            best_score = float('inf')\n\n            for pos in range(len(new_segment) + 1):\n                if pos == 0:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_segment[0] if new_segment else new_solution[seg_end] if seg_end < n else new_solution[0]\n                elif pos == len(new_segment):\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[pos-1]\n                    next_node = new_segment[pos]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_segment.insert(best_pos, node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[1] if node_pos != 1 else new_solution[2]\n            elif pos == n-1:\n                prev_node = new_solution[-2] if node_pos != n-2 else new_solution[-3]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos+1]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Remove node and reinsert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7522958169522593,
            1.1139020919799805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Multi-objective path decomposition\n    for _ in range(2):\n        # Select a segment to decompose\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Decompose and reinsert nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for node in segment:\n            # Evaluate insertion points\n            best_pos = -1\n            best_score = float('inf')\n\n            for pos in range(len(new_segment) + 1):\n                if pos == 0:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_segment[0] if new_segment else new_solution[seg_end] if seg_end < n else new_solution[0]\n                elif pos == len(new_segment):\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[pos-1]\n                    next_node = new_segment[pos]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            new_segment.insert(best_pos, node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Adaptive node insertion\n    for _ in range(3):\n        # Select a random node to reinsert\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Find best insertion position\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n\n            if pos == 0:\n                prev_node = new_solution[-1]\n                next_node = new_solution[1] if node_pos != 1 else new_solution[2]\n            elif pos == n-1:\n                prev_node = new_solution[-2] if node_pos != n-2 else new_solution[-3]\n                next_node = new_solution[0]\n            else:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos+1]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Remove node and reinsert at best position\n        new_solution = np.delete(new_solution, node_pos)\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This novel algorithm employs adaptive segment inversion with multi-objective node prioritization, where it intelligently inverts segments from high-performing solutions while strategically selecting nodes based on their combined objective impact and positional influence, ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select high-performing segments based on combined objective impact\n    segment_size = max(2, min(4, n // 4))\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with positional weighting\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] * (1 + 0.1 * i) for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] * (1 + 0.05 * i) for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert segment if beneficial\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Node prioritization based on combined objective and positional influence\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate impact of swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + \\\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n            cost2_before = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + \\\n                          distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n            # Accept swap if beneficial\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before) or random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7779737408298791,
            0.47873228788375854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select high-performing segments based on combined objective impact\n    segment_size = max(2, min(4, n // 4))\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with positional weighting\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] * (1 + 0.1 * i) for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] * (1 + 0.05 * i) for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert segment if beneficial\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Node prioritization based on combined objective and positional influence\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate impact of swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            cost1_before = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + \\\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n            cost2_before = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + \\\n                          distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n            cost1_after = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n            cost2_after = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n            # Accept swap if beneficial\n            if (cost1_after + cost2_after) < (cost1_before + cost2_before) or random.random() < 0.3:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This novel algorithm employs adaptive multi-objective path reshaping with dynamic node prioritization, where it intelligently selects and reshapes critical path segments from high-performing solutions while strategically reallocating nodes based on their normalized objective impact, ensuring feasibility through a probabilistic segment repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive multi-objective path reshaping\n    for _ in range(4):\n        # Select a segment to reshape\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reshape the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on normalized objective impact\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                # Normalized score calculation\n                score = (cost1 / (seg_cost1 + 1e-6)) + (cost2 / (seg_cost2 + 1e-6))\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes with probability\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes and random.random() < 0.7:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9188849767610506,
            1.3512727618217468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive multi-objective path reshaping\n    for _ in range(4):\n        # Select a segment to reshape\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reshape the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on normalized objective impact\n            candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                # Normalized score calculation\n                score = (cost1 / (seg_cost1 + 1e-6)) + (cost2 / (seg_cost2 + 1e-6))\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes with probability\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes and random.random() < 0.7:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This novel algorithm combines hierarchical segment decomposition with adaptive node reinsertion, where it systematically decomposes the tour into hierarchical segments, evaluates their multi-objective impact, and reinserts nodes at optimal positions while maintaining feasibility through a dynamic boundary-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    max_levels = min(3, int(np.log2(n)))  # Hierarchical decomposition levels\n\n    for level in range(max_levels):\n        segment_size = max(2, n // (2 ** (max_levels - level)))\n        num_segments = max(1, n // segment_size)\n\n        for _ in range(2):\n            seg_start = random.randint(0, n - segment_size)\n            seg_end = seg_start + segment_size\n            segment = new_solution[seg_start:seg_end]\n\n            # Calculate segment impact\n            seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n            # Remove segment and reinsert nodes\n            remaining_nodes = [node for node in new_solution if node not in segment]\n            new_segment = []\n\n            for node in segment:\n                best_pos = -1\n                best_score = float('inf')\n\n                for pos in range(len(remaining_nodes) + 1):\n                    if pos == 0:\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        next_node = remaining_nodes[0] if remaining_nodes else new_solution[seg_end] if seg_end < n else new_solution[0]\n                    elif pos == len(remaining_nodes):\n                        prev_node = remaining_nodes[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                    else:\n                        prev_node = remaining_nodes[pos-1]\n                        next_node = remaining_nodes[pos]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = pos\n\n                remaining_nodes.insert(best_pos, node)\n\n            # Rebuild the solution\n            new_solution = remaining_nodes.copy()\n\n    # Dynamic boundary preservation\n    boundary_nodes = set()\n    for i in range(1, len(new_solution)):\n        if distance_matrix_1[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_1) or \\\n           distance_matrix_2[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_2):\n            boundary_nodes.update({new_solution[i-1], new_solution[i]})\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] in boundary_nodes or new_solution[j] in boundary_nodes:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9497739703397394,
            5.304358422756195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    max_levels = min(3, int(np.log2(n)))  # Hierarchical decomposition levels\n\n    for level in range(max_levels):\n        segment_size = max(2, n // (2 ** (max_levels - level)))\n        num_segments = max(1, n // segment_size)\n\n        for _ in range(2):\n            seg_start = random.randint(0, n - segment_size)\n            seg_end = seg_start + segment_size\n            segment = new_solution[seg_start:seg_end]\n\n            # Calculate segment impact\n            seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n            # Remove segment and reinsert nodes\n            remaining_nodes = [node for node in new_solution if node not in segment]\n            new_segment = []\n\n            for node in segment:\n                best_pos = -1\n                best_score = float('inf')\n\n                for pos in range(len(remaining_nodes) + 1):\n                    if pos == 0:\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        next_node = remaining_nodes[0] if remaining_nodes else new_solution[seg_end] if seg_end < n else new_solution[0]\n                    elif pos == len(remaining_nodes):\n                        prev_node = remaining_nodes[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                    else:\n                        prev_node = remaining_nodes[pos-1]\n                        next_node = remaining_nodes[pos]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_pos = pos\n\n                remaining_nodes.insert(best_pos, node)\n\n            # Rebuild the solution\n            new_solution = remaining_nodes.copy()\n\n    # Dynamic boundary preservation\n    boundary_nodes = set()\n    for i in range(1, len(new_solution)):\n        if distance_matrix_1[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_1) or \\\n           distance_matrix_2[new_solution[i-1], new_solution[i]] > np.mean(distance_matrix_2):\n            boundary_nodes.update({new_solution[i-1], new_solution[i]})\n\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] in boundary_nodes or new_solution[j] in boundary_nodes:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Feasibility check\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This novel algorithm employs a multi-phase evolutionary approach that first performs adaptive node clustering based on combined objective distances, followed by a dynamic segment inversion and reinsertion process that preserves tour feasibility through a novel boundary validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node clustering\n    cluster_size = max(3, n // 5)\n    clusters = []\n\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Phase 2: Dynamic segment inversion and reinsertion\n    for _ in range(2):\n        # Select a random cluster\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        # Invert the cluster\n        inverted_cluster = cluster[::-1]\n\n        # Remove the original cluster\n        new_solution = [node for node in new_solution if node not in cluster]\n\n        # Find the best position to reinsert the inverted cluster\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting at position i\n            candidate = np.insert(new_solution, i, inverted_cluster)\n\n            # Calculate the cost of the new solution\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Reinsert the inverted cluster at the best position\n        new_solution = np.insert(new_solution, best_pos, inverted_cluster)\n\n    # Phase 3: Boundary validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes at random positions\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8158931632169912,
            5.924922585487366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive node clustering\n    cluster_size = max(3, n // 5)\n    clusters = []\n\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Phase 2: Dynamic segment inversion and reinsertion\n    for _ in range(2):\n        # Select a random cluster\n        cluster_idx = random.randint(0, len(clusters)-1)\n        cluster = clusters[cluster_idx]\n\n        # Invert the cluster\n        inverted_cluster = cluster[::-1]\n\n        # Remove the original cluster\n        new_solution = [node for node in new_solution if node not in cluster]\n\n        # Find the best position to reinsert the inverted cluster\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting at position i\n            candidate = np.insert(new_solution, i, inverted_cluster)\n\n            # Calculate the cost of the new solution\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, len(candidate)))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = i\n\n        # Reinsert the inverted cluster at the best position\n        new_solution = np.insert(new_solution, best_pos, inverted_cluster)\n\n    # Phase 3: Boundary validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes at random positions\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{This novel algorithm employs a dynamic multi-objective path evolution strategy that iteratively refines segments of high-performing solutions by intelligently merging and reordering nodes based on their combined objective impact, while maintaining feasibility through a probabilistic segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective performance\n    archive_solutions = [sol for sol, (obj1, obj2) in archive if obj1 + obj2 < np.mean([o1 + o2 for _, (o1, o2) in archive])]\n    if not archive_solutions:\n        archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    # Dynamic path evolution\n    for _ in range(2):\n        # Select a segment to evolve\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Evolve the segment by merging with another segment\n        other_seg_start = random.randint(0, n - segment_size)\n        other_seg_end = other_seg_start + segment_size\n        other_segment = new_solution[other_seg_start:other_seg_end]\n\n        # Combine segments probabilistically based on objective impact\n        if random.random() < 0.7 * (seg_cost1 + seg_cost2) / (seg_cost1 + seg_cost2 + 1e-6):\n            # Merge segments by alternating nodes\n            merged = []\n            i = j = 0\n            while i < len(segment) and j < len(other_segment):\n                if random.random() < 0.5:\n                    merged.append(segment[i])\n                    i += 1\n                else:\n                    merged.append(other_segment[j])\n                    j += 1\n            merged.extend(segment[i:])\n            merged.extend(other_segment[j:])\n\n            # Replace the original segment\n            new_solution[seg_start:seg_end] = merged[:segment_size]\n\n    # Probabilistic segment validation and repair\n    if random.random() < 0.3:\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # Repair by inserting missing nodes at random positions\n            missing = [node for node in range(n) if node not in unique_nodes]\n            for node in missing:\n                pos = random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.7740733174637848,
            2.20466411113739
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective performance\n    archive_solutions = [sol for sol, (obj1, obj2) in archive if obj1 + obj2 < np.mean([o1 + o2 for _, (o1, o2) in archive])]\n    if not archive_solutions:\n        archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    # Dynamic path evolution\n    for _ in range(2):\n        # Select a segment to evolve\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Evolve the segment by merging with another segment\n        other_seg_start = random.randint(0, n - segment_size)\n        other_seg_end = other_seg_start + segment_size\n        other_segment = new_solution[other_seg_start:other_seg_end]\n\n        # Combine segments probabilistically based on objective impact\n        if random.random() < 0.7 * (seg_cost1 + seg_cost2) / (seg_cost1 + seg_cost2 + 1e-6):\n            # Merge segments by alternating nodes\n            merged = []\n            i = j = 0\n            while i < len(segment) and j < len(other_segment):\n                if random.random() < 0.5:\n                    merged.append(segment[i])\n                    i += 1\n                else:\n                    merged.append(other_segment[j])\n                    j += 1\n            merged.extend(segment[i:])\n            merged.extend(other_segment[j:])\n\n            # Replace the original segment\n            new_solution[seg_start:seg_end] = merged[:segment_size]\n\n    # Probabilistic segment validation and repair\n    if random.random() < 0.3:\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            # Repair by inserting missing nodes at random positions\n            missing = [node for node in range(n) if node not in unique_nodes]\n            for node in missing:\n                pos = random.randint(0, n)\n                new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9686001836985894,
            0.9512246251106262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This novel algorithm combines hierarchical cluster-based segment reconstruction with adaptive node reallocation, where it intelligently partitions the tour into clusters based on spatial proximity in both objectives, reconstructs segments by optimizing within clusters, and strategically reallocates nodes between clusters to improve both objectives while maintaining feasibility through a cluster validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    cluster_size = max(3, min(7, n // 4))\n\n    # Hierarchical cluster-based segment reconstruction\n    for _ in range(2):\n        # Create clusters based on spatial proximity in both objectives\n        clusters = []\n        remaining_nodes = list(range(n))\n\n        while remaining_nodes:\n            # Select a random node as cluster center\n            center = random.choice(remaining_nodes)\n            cluster = [center]\n            remaining_nodes.remove(center)\n\n            # Find nodes close to the center in both objectives\n            for node in list(remaining_nodes):\n                pos1 = instance[node, :2]\n                pos2 = instance[node, 2:]\n                center_pos1 = instance[center, :2]\n                center_pos2 = instance[center, 2:]\n                dist1 = np.linalg.norm(pos1 - center_pos1)\n                dist2 = np.linalg.norm(pos2 - center_pos2)\n\n                if dist1 < 1.5 * np.mean(distance_matrix_1) or dist2 < 1.5 * np.mean(distance_matrix_2):\n                    cluster.append(node)\n                    remaining_nodes.remove(node)\n\n                if len(cluster) >= cluster_size:\n                    break\n\n            clusters.append(cluster)\n\n        # Reconstruct segments within each cluster\n        for cluster in clusters:\n            if len(cluster) < 2:\n                continue\n\n            # Find the segment in the solution that overlaps with the cluster\n            seg_start = None\n            seg_end = None\n            for i in range(len(new_solution) - len(cluster) + 1):\n                if all(new_solution[i+j] in cluster for j in range(len(cluster))):\n                    seg_start = i\n                    seg_end = i + len(cluster)\n                    break\n\n            if seg_start is None:\n                continue\n\n            segment = new_solution[seg_start:seg_end]\n            remaining_nodes = [node for node in cluster if node not in segment]\n\n            # Reconstruct the segment by optimizing within the cluster\n            new_segment = []\n            for _ in range(len(segment)):\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                else:\n                    prev_node = new_segment[-1]\n\n                candidates = remaining_nodes if remaining_nodes else segment\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    if seg_end < n:\n                        next_node = new_solution[seg_end]\n                    else:\n                        next_node = new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                if best_node in remaining_nodes:\n                    remaining_nodes.remove(best_node)\n                new_segment.append(best_node)\n\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Adaptive node reallocation between clusters\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Check if swapping improves both objectives\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j])\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n            if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cluster validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6919824716712925,
            2.6317869424819946
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    cluster_size = max(3, min(7, n // 4))\n\n    # Hierarchical cluster-based segment reconstruction\n    for _ in range(2):\n        # Create clusters based on spatial proximity in both objectives\n        clusters = []\n        remaining_nodes = list(range(n))\n\n        while remaining_nodes:\n            # Select a random node as cluster center\n            center = random.choice(remaining_nodes)\n            cluster = [center]\n            remaining_nodes.remove(center)\n\n            # Find nodes close to the center in both objectives\n            for node in list(remaining_nodes):\n                pos1 = instance[node, :2]\n                pos2 = instance[node, 2:]\n                center_pos1 = instance[center, :2]\n                center_pos2 = instance[center, 2:]\n                dist1 = np.linalg.norm(pos1 - center_pos1)\n                dist2 = np.linalg.norm(pos2 - center_pos2)\n\n                if dist1 < 1.5 * np.mean(distance_matrix_1) or dist2 < 1.5 * np.mean(distance_matrix_2):\n                    cluster.append(node)\n                    remaining_nodes.remove(node)\n\n                if len(cluster) >= cluster_size:\n                    break\n\n            clusters.append(cluster)\n\n        # Reconstruct segments within each cluster\n        for cluster in clusters:\n            if len(cluster) < 2:\n                continue\n\n            # Find the segment in the solution that overlaps with the cluster\n            seg_start = None\n            seg_end = None\n            for i in range(len(new_solution) - len(cluster) + 1):\n                if all(new_solution[i+j] in cluster for j in range(len(cluster))):\n                    seg_start = i\n                    seg_end = i + len(cluster)\n                    break\n\n            if seg_start is None:\n                continue\n\n            segment = new_solution[seg_start:seg_end]\n            remaining_nodes = [node for node in cluster if node not in segment]\n\n            # Reconstruct the segment by optimizing within the cluster\n            new_segment = []\n            for _ in range(len(segment)):\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                else:\n                    prev_node = new_segment[-1]\n\n                candidates = remaining_nodes if remaining_nodes else segment\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    if seg_end < n:\n                        next_node = new_solution[seg_end]\n                    else:\n                        next_node = new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                if best_node in remaining_nodes:\n                    remaining_nodes.remove(best_node)\n                new_segment.append(best_node)\n\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Adaptive node reallocation between clusters\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Check if swapping improves both objectives\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                          distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j])\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j])\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n            if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Cluster validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node clustering with dynamic path inversion to explore high-quality solutions by intelligently grouping nodes based on their objective-space proximity and then inverting selected paths while maintaining tour feasibility and diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering based on objective-space proximity\n    cluster_size = max(2, min(5, n // 3))\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Dynamic path inversion for refinement\n    for _ in range(3):\n        if len(clusters) < 2:\n            break\n        i, j = random.sample(range(len(clusters)), 2)\n        if i > j:\n            i, j = j, i\n        # Invert the path between two clusters\n        start = i * cluster_size\n        end = j * cluster_size + cluster_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Local edge swaps for fine-tuning\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7371880153480034,
            0.4482809901237488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering based on objective-space proximity\n    cluster_size = max(2, min(5, n // 3))\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Dynamic path inversion for refinement\n    for _ in range(3):\n        if len(clusters) < 2:\n            break\n        i, j = random.sample(range(len(clusters)), 2)\n        if i > j:\n            i, j = j, i\n        # Invert the path between two clusters\n        start = i * cluster_size\n        end = j * cluster_size + cluster_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Local edge swaps for fine-tuning\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This novel algorithm employs a multi-phase approach combining adaptive path decomposition with objective-aware node insertion, where it first decomposes the tour into critical segments based on their combined objective impact, then intelligently reinserts nodes using a hybrid of greedy and probabilistic selection to balance exploration and exploitation while maintaining feasibility through a dynamic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_objectives = [sum(obj) for obj in objectives]\n    selected_idx = combined_objectives.index(min(combined_objectives))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive path decomposition\n    decomposition_points = []\n    current_cost1 = 0\n    current_cost2 = 0\n\n    for i in range(1, n):\n        node_prev = new_solution[i-1]\n        node_current = new_solution[i]\n        current_cost1 += distance_matrix_1[node_prev, node_current]\n        current_cost2 += distance_matrix_2[node_prev, node_current]\n\n        # Calculate average cost per edge\n        avg_cost1 = current_cost1 / i\n        avg_cost2 = current_cost2 / i\n\n        # Identify critical points where costs deviate significantly from average\n        if (distance_matrix_1[node_prev, node_current] > 1.5 * avg_cost1 or\n            distance_matrix_2[node_prev, node_current] > 1.5 * avg_cost2):\n            decomposition_points.append(i)\n\n    # Add start and end points\n    decomposition_points = [0] + decomposition_points + [n]\n\n    # Phase 2: Objective-aware node reinsertion\n    for _ in range(2):\n        # Select a random segment to modify\n        if len(decomposition_points) < 3:\n            break\n\n        seg_start = random.choice(range(len(decomposition_points)-2))\n        start_idx = decomposition_points[seg_start]\n        end_idx = decomposition_points[seg_start+2]\n\n        segment = new_solution[start_idx:end_idx]\n        removed_nodes = segment.copy()\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start_idx], new_solution[end_idx:]])\n\n        # Reinsert nodes with objective-aware selection\n        for node in removed_nodes:\n            # Calculate insertion costs for all possible positions\n            insertion_costs = []\n            for pos in range(len(new_solution)+1):\n                if pos == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                elif pos == len(new_solution):\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[pos-1]\n                    next_node = new_solution[pos]\n\n                cost1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                         distance_matrix_2[prev_node, next_node])\n\n                # Combine costs with adaptive weights\n                total_cost = (0.6 * cost1 + 0.4 * cost2) if random.random() < 0.7 else (0.4 * cost1 + 0.6 * cost2)\n                insertion_costs.append((total_cost, pos))\n\n            # Select top 3 candidates and choose probabilistically\n            insertion_costs.sort(key=lambda x: x[0])\n            top_candidates = insertion_costs[:min(3, len(insertion_costs))]\n\n            if top_candidates:\n                # Probabilistic selection based on rank\n                weights = [1/(i+1) for i in range(len(top_candidates))]\n                selected_pos = random.choices([pos for (_, pos) in top_candidates], weights=weights)[0]\n\n                # Insert the node\n                if selected_pos == len(new_solution):\n                    new_solution = np.append(new_solution, node)\n                else:\n                    new_solution = np.insert(new_solution, selected_pos, node)\n\n    # Phase 3: Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes at random positions\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7820332689783895,
            2.1832407116889954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    combined_objectives = [sum(obj) for obj in objectives]\n    selected_idx = combined_objectives.index(min(combined_objectives))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Phase 1: Adaptive path decomposition\n    decomposition_points = []\n    current_cost1 = 0\n    current_cost2 = 0\n\n    for i in range(1, n):\n        node_prev = new_solution[i-1]\n        node_current = new_solution[i]\n        current_cost1 += distance_matrix_1[node_prev, node_current]\n        current_cost2 += distance_matrix_2[node_prev, node_current]\n\n        # Calculate average cost per edge\n        avg_cost1 = current_cost1 / i\n        avg_cost2 = current_cost2 / i\n\n        # Identify critical points where costs deviate significantly from average\n        if (distance_matrix_1[node_prev, node_current] > 1.5 * avg_cost1 or\n            distance_matrix_2[node_prev, node_current] > 1.5 * avg_cost2):\n            decomposition_points.append(i)\n\n    # Add start and end points\n    decomposition_points = [0] + decomposition_points + [n]\n\n    # Phase 2: Objective-aware node reinsertion\n    for _ in range(2):\n        # Select a random segment to modify\n        if len(decomposition_points) < 3:\n            break\n\n        seg_start = random.choice(range(len(decomposition_points)-2))\n        start_idx = decomposition_points[seg_start]\n        end_idx = decomposition_points[seg_start+2]\n\n        segment = new_solution[start_idx:end_idx]\n        removed_nodes = segment.copy()\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start_idx], new_solution[end_idx:]])\n\n        # Reinsert nodes with objective-aware selection\n        for node in removed_nodes:\n            # Calculate insertion costs for all possible positions\n            insertion_costs = []\n            for pos in range(len(new_solution)+1):\n                if pos == 0:\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                elif pos == len(new_solution):\n                    prev_node = new_solution[-1]\n                    next_node = new_solution[0]\n                else:\n                    prev_node = new_solution[pos-1]\n                    next_node = new_solution[pos]\n\n                cost1 = (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] -\n                         distance_matrix_1[prev_node, next_node])\n                cost2 = (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] -\n                         distance_matrix_2[prev_node, next_node])\n\n                # Combine costs with adaptive weights\n                total_cost = (0.6 * cost1 + 0.4 * cost2) if random.random() < 0.7 else (0.4 * cost1 + 0.6 * cost2)\n                insertion_costs.append((total_cost, pos))\n\n            # Select top 3 candidates and choose probabilistically\n            insertion_costs.sort(key=lambda x: x[0])\n            top_candidates = insertion_costs[:min(3, len(insertion_costs))]\n\n            if top_candidates:\n                # Probabilistic selection based on rank\n                weights = [1/(i+1) for i in range(len(top_candidates))]\n                selected_pos = random.choices([pos for (_, pos) in top_candidates], weights=weights)[0]\n\n                # Insert the node\n                if selected_pos == len(new_solution):\n                    new_solution = np.append(new_solution, node)\n                else:\n                    new_solution = np.insert(new_solution, selected_pos, node)\n\n    # Phase 3: Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes at random positions\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment inversion with dynamic objective-aware node swapping, where it selectively inverts segments of high-impact nodes while strategically swapping nodes based on their combined objective contributions, ensuring feasibility through a comprehensive validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert segment if it shows potential for improvement\n        if random.random() < 0.7 or (seg_cost1 + seg_cost2) > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_segment = segment[::-1]\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic objective-aware node swapping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate potential improvement\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            old_cost = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                        distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                        distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                        distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n\n            new_cost = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                        distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j] +\n                        distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                        distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        for i in range(n):\n            if new_solution[i] in duplicates:\n                new_solution[i] = missing.pop(0)\n            elif new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7296339996329904,
            0.5554799437522888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Invert segment if it shows potential for improvement\n        if random.random() < 0.7 or (seg_cost1 + seg_cost2) > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_segment = segment[::-1]\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic objective-aware node swapping\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate potential improvement\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            old_cost = (distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] +\n                        distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j] +\n                        distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] +\n                        distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j])\n\n            new_cost = (distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] +\n                        distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j] +\n                        distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] +\n                        distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j])\n\n            if new_cost < old_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Comprehensive validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        duplicates = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        for i in range(n):\n            if new_solution[i] in duplicates:\n                new_solution[i] = missing.pop(0)\n            elif new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment inversion with dynamic node prioritization, where it selectively inverts solution segments based on their combined objective impact while strategically reallocating nodes according to a novel multi-objective scoring function, ensuring feasibility through an enhanced validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value\n    archive_solutions = [sol for sol, (obj1, obj2) in archive if obj1 + obj2 > sum(obj1 + obj2 for _, (obj1, obj2) in archive) / len(archive)]\n    if not archive_solutions:\n        archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive segment inversion with multi-objective scoring\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weighted = 0.6 * seg_cost1 + 0.4 * seg_cost2\n\n        # Invert segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_weighted > (distance_matrix_1.sum() + distance_matrix_2.sum()) / (2 * n):\n            new_segment = segment[::-1]\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization and reallocation\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes based on combined objective impact\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            cost_original = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j] +\n                            distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            cost_swapped = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                           distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j] +\n                           distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                           distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if cost_swapped < cost_original:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Enhanced validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7396933621988808,
            1.4228714108467102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high combined objective value\n    archive_solutions = [sol for sol, (obj1, obj2) in archive if obj1 + obj2 > sum(obj1 + obj2 for _, (obj1, obj2) in archive) / len(archive)]\n    if not archive_solutions:\n        archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive segment inversion with multi-objective scoring\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact with weighted objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weighted = 0.6 * seg_cost1 + 0.4 * seg_cost2\n\n        # Invert segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_weighted > (distance_matrix_1.sum() + distance_matrix_2.sum()) / (2 * n):\n            new_segment = segment[::-1]\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node prioritization and reallocation\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes based on combined objective impact\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            cost_original = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j] +\n                            distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            cost_swapped = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                           distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j] +\n                           distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                           distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            if cost_swapped < cost_original:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Enhanced validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel adaptive segment inversion and dynamic edge insertion strategy that combines intelligent segment selection with probabilistic edge insertion to explore diverse high-quality solutions by adaptively inverting segments and strategically inserting edges while maintaining feasibility and balancing exploration in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size and randomness\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3 + random.randint(-2, 2)))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge insertion with probabilistic selection\n    for _ in range(4):  # Perform multiple edge insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1 and random.random() < 0.7:  # Higher probability for larger segments\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8606866648297552,
            0.457941472530365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size and randomness\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 3 + random.randint(-2, 2)))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic edge insertion with probabilistic selection\n    for _ in range(4):  # Perform multiple edge insertions\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1 and random.random() < 0.7:  # Higher probability for larger segments\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore high-quality solutions by intelligently rearranging segments and inserting nodes while preserving feasibility and balancing exploration in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7860504364026287,
            0.5329119563102722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):  # Perform multiple inversions\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Dynamic node insertion for further refinement\n    for _ in range(4):  # Perform multiple insertions\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This novel algorithm combines multi-objective path decomposition with adaptive segment inversion, where it intelligently partitions the tour into segments based on their combined objective impact, inverts high-impact segments to explore new solution spaces, and dynamically adjusts segment boundaries to maintain feasibility while preserving the tour structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path decomposition and segment inversion\n    for _ in range(3):\n        # Randomly select a segment to invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end + 1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end + 1))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows high impact\n        if random.random() < 0.7 or seg_total > (distance_matrix_1.sum() + distance_matrix_2.sum()) / (2 * n):\n            new_solution[seg_start:seg_end + 1] = new_solution[seg_start:seg_end + 1][::-1]\n\n    # Adaptive segment boundary adjustment\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n\n        if i != j:\n            # Swap nodes and check feasibility\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # Repair if duplicates are created\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                # Find missing nodes and place them at random positions\n                missing = [node for node in range(n) if node not in unique_nodes]\n                for node in missing:\n                    pos = random.randint(0, n - 1)\n                    new_solution[pos] = node\n\n    return new_solution\n\n",
        "score": [
            -0.8830570187463529,
            0.5258045196533203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Multi-objective path decomposition and segment inversion\n    for _ in range(3):\n        # Randomly select a segment to invert\n        seg_start = random.randint(0, n - 2)\n        seg_end = random.randint(seg_start + 1, n - 1)\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end + 1))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end + 1))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows high impact\n        if random.random() < 0.7 or seg_total > (distance_matrix_1.sum() + distance_matrix_2.sum()) / (2 * n):\n            new_solution[seg_start:seg_end + 1] = new_solution[seg_start:seg_end + 1][::-1]\n\n    # Adaptive segment boundary adjustment\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n\n        if i != j:\n            # Swap nodes and check feasibility\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # Repair if duplicates are created\n            unique_nodes = np.unique(new_solution)\n            if len(unique_nodes) != n:\n                # Find missing nodes and place them at random positions\n                missing = [node for node in range(n) if node not in unique_nodes]\n                for node in missing:\n                    pos = random.randint(0, n - 1)\n                    new_solution[pos] = node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This novel algorithm employs a multi-phase evolutionary refinement process that combines adaptive node clustering with Pareto-optimal segment insertion, dynamically optimizing both objectives through iterative segment reconstruction and node reallocation while maintaining feasibility through a constraint-aware repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [sum(obj) for _, obj in archive]\n    selected_sol = archive_solutions[objectives.index(min(objectives))]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    cluster_size = max(2, min(4, n // 5))\n\n    # Adaptive node clustering phase\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Pareto-optimal segment insertion\n    for _ in range(3):\n        # Select two clusters to merge\n        if len(clusters) < 2:\n            break\n\n        i, j = random.sample(range(len(clusters)), 2)\n        if i > j:\n            i, j = j, i\n\n        cluster1 = clusters[i]\n        cluster2 = clusters[j]\n\n        # Merge clusters and evaluate\n        merged = np.concatenate([cluster1, cluster2])\n        original_cost1 = sum(distance_matrix_1[cluster1[k-1], cluster1[k]] for k in range(1, len(cluster1))) + \\\n                         sum(distance_matrix_1[cluster2[k-1], cluster2[k]] for k in range(1, len(cluster2)))\n        original_cost2 = sum(distance_matrix_2[cluster1[k-1], cluster1[k]] for k in range(1, len(cluster1))) + \\\n                         sum(distance_matrix_2[cluster2[k-1], cluster2[k]] for k in range(1, len(cluster2)))\n\n        # Try all possible insertions\n        best_insertion = None\n        best_score = float('inf')\n\n        for pos in range(len(merged) + 1):\n            for k in range(1, len(merged)):\n                # Split into two segments\n                seg1 = merged[:k]\n                seg2 = merged[k:]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) + \\\n                            sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2)))\n                new_cost2 = sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) + \\\n                            sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2)))\n\n                # Calculate improvement\n                score = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n                if score < best_score:\n                    best_score = score\n                    best_insertion = (seg1, seg2)\n\n        if best_insertion:\n            seg1, seg2 = best_insertion\n            clusters[i] = seg1\n            clusters[j] = seg2\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Constraint-aware repair\n    if len(np.unique(new_solution)) != n:\n        # Find missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        # Insert missing nodes at random positions\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Dynamic node reallocation\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            # Check if swap maintains feasibility\n            if len(np.unique(new_solution)) == n:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7407408793169383,
            2.2497951984405518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [sum(obj) for _, obj in archive]\n    selected_sol = archive_solutions[objectives.index(min(objectives))]\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    cluster_size = max(2, min(4, n // 5))\n\n    # Adaptive node clustering phase\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Pareto-optimal segment insertion\n    for _ in range(3):\n        # Select two clusters to merge\n        if len(clusters) < 2:\n            break\n\n        i, j = random.sample(range(len(clusters)), 2)\n        if i > j:\n            i, j = j, i\n\n        cluster1 = clusters[i]\n        cluster2 = clusters[j]\n\n        # Merge clusters and evaluate\n        merged = np.concatenate([cluster1, cluster2])\n        original_cost1 = sum(distance_matrix_1[cluster1[k-1], cluster1[k]] for k in range(1, len(cluster1))) + \\\n                         sum(distance_matrix_1[cluster2[k-1], cluster2[k]] for k in range(1, len(cluster2)))\n        original_cost2 = sum(distance_matrix_2[cluster1[k-1], cluster1[k]] for k in range(1, len(cluster1))) + \\\n                         sum(distance_matrix_2[cluster2[k-1], cluster2[k]] for k in range(1, len(cluster2)))\n\n        # Try all possible insertions\n        best_insertion = None\n        best_score = float('inf')\n\n        for pos in range(len(merged) + 1):\n            for k in range(1, len(merged)):\n                # Split into two segments\n                seg1 = merged[:k]\n                seg2 = merged[k:]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) + \\\n                            sum(distance_matrix_1[seg2[l-1], seg2[l]] for l in range(1, len(seg2)))\n                new_cost2 = sum(distance_matrix_2[seg1[l-1], seg1[l]] for l in range(1, len(seg1))) + \\\n                            sum(distance_matrix_2[seg2[l-1], seg2[l]] for l in range(1, len(seg2)))\n\n                # Calculate improvement\n                score = (original_cost1 - new_cost1) + (original_cost2 - new_cost2)\n\n                if score < best_score:\n                    best_score = score\n                    best_insertion = (seg1, seg2)\n\n        if best_insertion:\n            seg1, seg2 = best_insertion\n            clusters[i] = seg1\n            clusters[j] = seg2\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Constraint-aware repair\n    if len(np.unique(new_solution)) != n:\n        # Find missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        # Insert missing nodes at random positions\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    # Dynamic node reallocation\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            # Check if swap maintains feasibility\n            if len(np.unique(new_solution)) == n:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path segmentation with dynamic node reinsertion, where it intelligently partitions the tour into segments based on their combined objective impact, then strategically reinserts nodes from these segments into the tour while maintaining feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path segmentation\n    segments = []\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n        segments.append((seg_start, seg_end, segment))\n\n    # Sort segments by their combined objective impact\n    segments.sort(key=lambda x: sum(distance_matrix_1[x[2][i-1], x[2][i]] + distance_matrix_2[x[2][i-1], x[2][i]] for i in range(1, len(x[2]))))\n\n    # Dynamic node reinsertion\n    for seg_start, seg_end, segment in segments:\n        # Remove the segment from the solution\n        temp_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        remaining_nodes = list(temp_solution)\n\n        # Reinsert nodes from the segment into the best possible positions\n        for node in segment:\n            best_pos = 0\n            best_score = float('inf')\n\n            for pos in range(len(remaining_nodes) + 1):\n                if pos == 0:\n                    prev_node = remaining_nodes[-1] if len(remaining_nodes) > 0 else new_solution[seg_end-1]\n                    next_node = remaining_nodes[0] if len(remaining_nodes) > 0 else new_solution[seg_start]\n                elif pos == len(remaining_nodes):\n                    prev_node = remaining_nodes[-1]\n                    next_node = remaining_nodes[0] if len(remaining_nodes) > 0 else new_solution[seg_start]\n                else:\n                    prev_node = remaining_nodes[pos-1]\n                    next_node = remaining_nodes[pos]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            remaining_nodes.insert(best_pos, node)\n\n        new_solution = np.array(remaining_nodes)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8377274474537506,
            1.2015819549560547
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path segmentation\n    segments = []\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n        segments.append((seg_start, seg_end, segment))\n\n    # Sort segments by their combined objective impact\n    segments.sort(key=lambda x: sum(distance_matrix_1[x[2][i-1], x[2][i]] + distance_matrix_2[x[2][i-1], x[2][i]] for i in range(1, len(x[2]))))\n\n    # Dynamic node reinsertion\n    for seg_start, seg_end, segment in segments:\n        # Remove the segment from the solution\n        temp_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n        remaining_nodes = list(temp_solution)\n\n        # Reinsert nodes from the segment into the best possible positions\n        for node in segment:\n            best_pos = 0\n            best_score = float('inf')\n\n            for pos in range(len(remaining_nodes) + 1):\n                if pos == 0:\n                    prev_node = remaining_nodes[-1] if len(remaining_nodes) > 0 else new_solution[seg_end-1]\n                    next_node = remaining_nodes[0] if len(remaining_nodes) > 0 else new_solution[seg_start]\n                elif pos == len(remaining_nodes):\n                    prev_node = remaining_nodes[-1]\n                    next_node = remaining_nodes[0] if len(remaining_nodes) > 0 else new_solution[seg_start]\n                else:\n                    prev_node = remaining_nodes[pos-1]\n                    next_node = remaining_nodes[pos]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = pos\n\n            remaining_nodes.insert(best_pos, node)\n\n        new_solution = np.array(remaining_nodes)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Novel multi-objective segment reconstruction with dynamic node reallocation\n    for _ in range(2):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation with adaptive swaps\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9006299383869395,
            0.8176907300949097
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Novel multi-objective segment reconstruction with dynamic node reallocation\n    for _ in range(2):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation with adaptive swaps\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path inversion with dynamic node insertion, where it selectively inverts segments of high-impact paths while strategically inserting nodes based on their combined objective contributions, ensuring feasibility through a novel path validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        if random.random() < 0.7 or seg_total > (sum(distance_matrix_1[selected_sol[i-1], selected_sol[i]] for i in range(1, n)) + sum(distance_matrix_2[selected_sol[i-1], selected_sol[i]] for i in range(1, n))) / n:\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8315576414295,
            0.536313533782959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        if random.random() < 0.7 or seg_total > (sum(distance_matrix_1[selected_sol[i-1], selected_sol[i]] for i in range(1, n)) + sum(distance_matrix_2[selected_sol[i-1], selected_sol[i]] for i in range(1, n))) / n:\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This novel algorithm combines adaptive objective-aware path decomposition with multi-scale node reassignment, where it intelligently partitions the tour into critical and non-critical segments based on their combined objective impact, then performs targeted reassignment of nodes at different scales while maintaining feasibility through a hierarchical repair mechanism that preserves both local and global connectivity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    scales = [1, 2, 3]  # Different reassignment scales\n\n    # Adaptive path decomposition\n    for scale in scales:\n        segment_size = max(2, min(4, n // scale))\n\n        # Identify critical segments based on combined objective impact\n        critical_segments = []\n        for i in range(0, n, segment_size):\n            segment = new_solution[i:i+segment_size]\n            seg_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            seg_total = seg_cost1 + seg_cost2\n            critical_segments.append((i, i+segment_size, seg_total))\n\n        # Sort segments by impact (descending)\n        critical_segments.sort(key=lambda x: -x[2])\n\n        # Reassign nodes in critical segments\n        for seg_start, seg_end, _ in critical_segments[:max(1, len(critical_segments)//2)]:\n            segment = new_solution[seg_start:seg_end]\n            remaining_nodes = [node for node in new_solution if node not in segment]\n            new_segment = []\n\n            for _ in range(len(segment)):\n                candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    if not new_segment:\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                    else:\n                        prev_node = new_segment[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Hierarchical repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Local repair for missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    # Global connectivity validation\n    if len(np.unique(new_solution)) != n:\n        # Full repair if local repair fails\n        new_solution = np.arange(n)\n        random.shuffle(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7950840348915926,
            4.444945454597473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    scales = [1, 2, 3]  # Different reassignment scales\n\n    # Adaptive path decomposition\n    for scale in scales:\n        segment_size = max(2, min(4, n // scale))\n\n        # Identify critical segments based on combined objective impact\n        critical_segments = []\n        for i in range(0, n, segment_size):\n            segment = new_solution[i:i+segment_size]\n            seg_cost1 = sum(distance_matrix_1[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            seg_cost2 = sum(distance_matrix_2[segment[j-1], segment[j]] for j in range(1, len(segment)))\n            seg_total = seg_cost1 + seg_cost2\n            critical_segments.append((i, i+segment_size, seg_total))\n\n        # Sort segments by impact (descending)\n        critical_segments.sort(key=lambda x: -x[2])\n\n        # Reassign nodes in critical segments\n        for seg_start, seg_end, _ in critical_segments[:max(1, len(critical_segments)//2)]:\n            segment = new_solution[seg_start:seg_end]\n            remaining_nodes = [node for node in new_solution if node not in segment]\n            new_segment = []\n\n            for _ in range(len(segment)):\n                candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    if not new_segment:\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                    else:\n                        prev_node = new_segment[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = cost1 + cost2\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Hierarchical repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Local repair for missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    # Global connectivity validation\n    if len(np.unique(new_solution)) != n:\n        # Full repair if local repair fails\n        new_solution = np.arange(n)\n        random.shuffle(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This novel algorithm employs a hybrid approach combining adaptive segment inversion with dynamic objective-aware node insertion, where it intelligently inverts high-impact segments and strategically inserts nodes based on their combined objective impact while ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to move\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Find best insertion position based on combined objective impact\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == node_pos or (i == node_pos + 1 and node_pos != n-1):\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n else new_solution[0]\n\n            # Calculate insertion cost\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8867138482365517,
            0.7198400497436523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive segment inversion\n    for _ in range(2):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to move\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Find best insertion position based on combined objective impact\n        best_pos = -1\n        best_score = float('inf')\n\n        for i in range(n):\n            if i == node_pos or (i == node_pos + 1 and node_pos != n-1):\n                continue\n\n            prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i] if i < n else new_solution[0]\n\n            # Calculate insertion cost\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        if best_pos != -1:\n            # Remove node and insert at best position\n            new_solution = np.delete(new_solution, node_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path reversal with dynamic node insertion to explore high-quality solutions by intelligently reversing segments of the tour and strategically inserting nodes while maintaining feasibility and balancing improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        if node != new_solution[pos]:\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n    return new_solution\n\n",
        "score": [
            -0.8487556958713878,
            0.4980533719062805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path reversal\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Dynamic node insertion\n    for _ in range(3):\n        node = random.choice(new_solution)\n        pos = random.randint(0, n-1)\n        if node != new_solution[pos]:\n            new_solution = np.insert(new_solution, pos, node)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm employs a hybrid approach of adaptive segment inversion with dynamic node rebalancing, where it selectively inverts segments of high-impact nodes while strategically rebalancing nodes based on their combined objective contributions, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows improvement potential\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic node rebalancing\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Rebalance nodes based on objective impact\n            node_i_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            node_i_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            node_j_cost1 = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            node_j_cost2 = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            if (node_i_cost1 + node_i_cost2) > (node_j_cost1 + node_j_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7279408491062381,
            0.5076109170913696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows improvement potential\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic node rebalancing\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Rebalance nodes based on objective impact\n            node_i_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            node_i_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            node_j_cost1 = distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            node_j_cost2 = distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            if (node_i_cost1 + node_i_cost2) > (node_j_cost1 + node_j_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with dynamic edge reversal to explore high-quality solutions by intelligently rearranging segments and edges while preserving feasibility and balancing exploration of both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment insertion and reversal\n    for _ in range(3):  # Perform multiple insertions\n        # Select a segment and a new position\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_pos = random.randint(0, n - segment_size)\n\n        # Ensure the segment and new position don't overlap\n        if not (seg_start <= new_pos < seg_end or seg_start <= new_pos + segment_size < seg_end):\n            segment = new_solution[seg_start:seg_end]\n            new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Dynamic edge reversal for further refinement\n    for _ in range(4):  # Perform multiple edge reversals\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8936835768546142,
            0.45729881525039673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(3, min(7, n // 3))\n\n    # Adaptive segment insertion and reversal\n    for _ in range(3):  # Perform multiple insertions\n        # Select a segment and a new position\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_pos = random.randint(0, n - segment_size)\n\n        # Ensure the segment and new position don't overlap\n        if not (seg_start <= new_pos < seg_end or seg_start <= new_pos + segment_size < seg_end):\n            segment = new_solution[seg_start:seg_end]\n            new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n            new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n    # Dynamic edge reversal for further refinement\n    for _ in range(4):  # Perform multiple edge reversals\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 2:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm implements a hybrid local search strategy that combines adaptive segment inversion with dynamic edge selection, using a novel scoring mechanism to prioritize solutions with high potential for improvement, while maintaining feasibility and exploring diverse regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on potential improvement\n    def score_solution(sol, obj):\n        n = len(sol)\n        total_cost = obj[0] + obj[1]\n        return total_cost * (1 + 0.1 * (n - sum(sol == base_solution)))\n\n    base_solution = archive[0][0]\n    scored_solutions = [(score_solution(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n\n    # Select top 20% solutions with highest potential\n    top_count = max(1, len(scored_solutions) // 5)\n    selected_sol = random.choice([sol for _, sol in scored_solutions[:top_count]])\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_size = max(2, min(7, n // 3))\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic edge selection with objective-aware swaps\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Check if swap improves both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7780524655171579,
            0.5997581481933594
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Score solutions based on potential improvement\n    def score_solution(sol, obj):\n        n = len(sol)\n        total_cost = obj[0] + obj[1]\n        return total_cost * (1 + 0.1 * (n - sum(sol == base_solution)))\n\n    base_solution = archive[0][0]\n    scored_solutions = [(score_solution(sol, obj), sol) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[0])\n\n    # Select top 20% solutions with highest potential\n    top_count = max(1, len(scored_solutions) // 5)\n    selected_sol = random.choice([sol for _, sol in scored_solutions[:top_count]])\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_size = max(2, min(7, n // 3))\n    for _ in range(3):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Dynamic edge selection with objective-aware swaps\n    for _ in range(4):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            # Check if swap improves both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j-1]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This novel algorithm employs a multi-phase approach that combines adaptive node clustering with dynamic path inversion, where it first partitions the tour into clusters based on spatial proximity in both objective spaces, then inverts segments within clusters to explore new solution configurations while maintaining feasibility through a cluster validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive\n    selected_sol = random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive Node Clustering\n    cluster_size = max(2, min(4, n // 5))\n    clusters = []\n\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Phase 2: Dynamic Path Inversion within Clusters\n    for cluster in clusters:\n        if len(cluster) > 1:\n            # Invert the cluster with a probability\n            if random.random() < 0.5:\n                start_idx = np.where(new_solution == cluster[0])[0][0]\n                end_idx = start_idx + len(cluster)\n                new_solution[start_idx:end_idx] = cluster[::-1]\n\n    # Phase 3: Cluster Validation and Repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7726558735937338,
            0.49788975715637207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the archive\n    selected_sol = random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive Node Clustering\n    cluster_size = max(2, min(4, n // 5))\n    clusters = []\n\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Phase 2: Dynamic Path Inversion within Clusters\n    for cluster in clusters:\n        if len(cluster) > 1:\n            # Invert the cluster with a probability\n            if random.random() < 0.5:\n                start_idx = np.where(new_solution == cluster[0])[0][0]\n                end_idx = start_idx + len(cluster)\n                new_solution[start_idx:end_idx] = cluster[::-1]\n\n    # Phase 3: Cluster Validation and Repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{This novel algorithm employs a hybrid approach combining Pareto-frontier guided segment insertion with adaptive node rebalancing, where it selectively inserts high-quality segments from Pareto-optimal solutions while dynamically rebalancing nodes based on their multi-objective trade-off, ensuring feasibility through a novel segment compatibility check and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the Pareto frontier\n    pareto_front = []\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (pcost1, pcost2) in archive:\n            if (pcost1 <= cost1 and pcost2 <= cost2) and (pcost1 < cost1 or pcost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    selected_sol = random.choice(pareto_front) if pareto_front else random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Pareto-frontier guided segment insertion\n    for _ in range(2):\n        # Select a segment from the selected solution\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Find insertion point in the new solution\n        insert_pos = random.randint(0, n - len(segment))\n        if insert_pos < seg_start or insert_pos >= seg_end:\n            # Insert the segment\n            new_segment = segment.copy()\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                new_segment,\n                new_solution[insert_pos:]\n            ])[:n]\n\n    # Adaptive node rebalancing\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j and new_solution[i] != new_solution[j]:\n            # Calculate impact of swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_j])\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                        distance_matrix_1[new_solution[j], next_i] +\n                        distance_matrix_1[prev_j, new_solution[i]] +\n                        distance_matrix_1[new_solution[i], next_j])\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                        distance_matrix_2[new_solution[j], next_i] +\n                        distance_matrix_2[prev_j, new_solution[i]] +\n                        distance_matrix_2[new_solution[i], next_j])\n\n            # Accept swap if it improves at least one objective\n            if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment compatibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6126904699923054,
            0.3655463457107544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution from the Pareto frontier\n    pareto_front = []\n    for sol, (cost1, cost2) in archive:\n        dominated = False\n        for _, (pcost1, pcost2) in archive:\n            if (pcost1 <= cost1 and pcost2 <= cost2) and (pcost1 < cost1 or pcost2 < cost2):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol)\n\n    selected_sol = random.choice(pareto_front) if pareto_front else random.choice([sol for sol, _ in archive])\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Pareto-frontier guided segment insertion\n    for _ in range(2):\n        # Select a segment from the selected solution\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Find insertion point in the new solution\n        insert_pos = random.randint(0, n - len(segment))\n        if insert_pos < seg_start or insert_pos >= seg_end:\n            # Insert the segment\n            new_segment = segment.copy()\n            new_solution = np.concatenate([\n                new_solution[:insert_pos],\n                new_segment,\n                new_solution[insert_pos:]\n            ])[:n]\n\n    # Adaptive node rebalancing\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j and new_solution[i] != new_solution[j]:\n            # Calculate impact of swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[(j+1)%n]\n\n            old_cost1 = (distance_matrix_1[prev_i, new_solution[i]] +\n                         distance_matrix_1[new_solution[i], next_i] +\n                         distance_matrix_1[prev_j, new_solution[j]] +\n                         distance_matrix_1[new_solution[j], next_j])\n            old_cost2 = (distance_matrix_2[prev_i, new_solution[i]] +\n                         distance_matrix_2[new_solution[i], next_i] +\n                         distance_matrix_2[prev_j, new_solution[j]] +\n                         distance_matrix_2[new_solution[j], next_j])\n\n            new_cost1 = (distance_matrix_1[prev_i, new_solution[j]] +\n                        distance_matrix_1[new_solution[j], next_i] +\n                        distance_matrix_1[prev_j, new_solution[i]] +\n                        distance_matrix_1[new_solution[i], next_j])\n            new_cost2 = (distance_matrix_2[prev_i, new_solution[j]] +\n                        distance_matrix_2[new_solution[j], next_i] +\n                        distance_matrix_2[prev_j, new_solution[i]] +\n                        distance_matrix_2[new_solution[i], next_j])\n\n            # Accept swap if it improves at least one objective\n            if (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment compatibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This novel algorithm employs adaptive segment fragmentation with dynamic objective-aware node insertion, where it intelligently fragments and reinserts segments from high-performing solutions based on their combined objective impact, while strategically inserting nodes to optimize both objectives simultaneously, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment fragmentation and reinsertion\n    for _ in range(3):\n        # Fragment a segment\n        frag_start = random.randint(0, n - segment_size)\n        frag_end = frag_start + segment_size\n        fragment = new_solution[frag_start:frag_end]\n\n        # Remove the fragment\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n\n        # Calculate fragment impact\n        frag_cost1 = sum(distance_matrix_1[fragment[i-1], fragment[i]] for i in range(1, len(fragment)))\n        frag_cost2 = sum(distance_matrix_2[fragment[i-1], fragment[i]] for i in range(1, len(fragment)))\n        frag_weight = frag_cost1 + frag_cost2\n\n        # Find best insertion point\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Calculate insertion cost\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, fragment[0]] + distance_matrix_1[fragment[-1], next_node]\n            cost2 = distance_matrix_2[prev_node, fragment[0]] + distance_matrix_2[fragment[-1], next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the fragment\n        new_solution = np.concatenate([new_solution[:best_pos], fragment, new_solution[best_pos:]])\n\n    # Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            if pos == node_idx or pos == node_idx - 1:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n\n            # Calculate cost before removal\n            old_prev = new_solution[node_idx-1] if node_idx > 0 else new_solution[-1]\n            old_next = new_solution[node_idx+1] if node_idx < n-1 else new_solution[0]\n            old_cost1 = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next]\n            old_cost2 = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate score difference\n            score_diff = (new_cost1 + new_cost2) - (old_cost1 + old_cost2)\n\n            if score_diff < best_score:\n                best_score = score_diff\n                best_pos = pos\n\n        # Perform the insertion if it improves the solution\n        if best_score < 0:\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.9267483347320701,
            0.9179962873458862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment fragmentation and reinsertion\n    for _ in range(3):\n        # Fragment a segment\n        frag_start = random.randint(0, n - segment_size)\n        frag_end = frag_start + segment_size\n        fragment = new_solution[frag_start:frag_end]\n\n        # Remove the fragment\n        new_solution = np.concatenate([new_solution[:frag_start], new_solution[frag_end:]])\n\n        # Calculate fragment impact\n        frag_cost1 = sum(distance_matrix_1[fragment[i-1], fragment[i]] for i in range(1, len(fragment)))\n        frag_cost2 = sum(distance_matrix_2[fragment[i-1], fragment[i]] for i in range(1, len(fragment)))\n        frag_weight = frag_cost1 + frag_cost2\n\n        # Find best insertion point\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Calculate insertion cost\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n\n            cost1 = distance_matrix_1[prev_node, fragment[0]] + distance_matrix_1[fragment[-1], next_node]\n            cost2 = distance_matrix_2[prev_node, fragment[0]] + distance_matrix_2[fragment[-1], next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        # Insert the fragment\n        new_solution = np.concatenate([new_solution[:best_pos], fragment, new_solution[best_pos:]])\n\n    # Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find best insertion point considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            if pos == node_idx or pos == node_idx - 1:\n                continue\n\n            prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos] if pos < len(new_solution) else new_solution[0]\n\n            # Calculate cost before removal\n            old_prev = new_solution[node_idx-1] if node_idx > 0 else new_solution[-1]\n            old_next = new_solution[node_idx+1] if node_idx < n-1 else new_solution[0]\n            old_cost1 = distance_matrix_1[old_prev, node] + distance_matrix_1[node, old_next]\n            old_cost2 = distance_matrix_2[old_prev, node] + distance_matrix_2[node, old_next]\n\n            # Calculate cost after insertion\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate score difference\n            score_diff = (new_cost1 + new_cost2) - (old_cost1 + old_cost2)\n\n            if score_diff < best_score:\n                best_score = score_diff\n                best_pos = pos\n\n        # Perform the insertion if it improves the solution\n        if best_score < 0:\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with multi-objective edge optimization to explore high-quality solutions by intelligently relocating nodes and optimizing edges based on their potential improvement in both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with multi-objective consideration\n    for _ in range(3):\n        # Select a node to relocate\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Calculate potential improvement for both objectives\n        current_prev = new_solution[node_pos - 1] if node_pos > 0 else new_solution[-1]\n        current_next = new_solution[(node_pos + 1) % n]\n\n        # Remove the node from its current position\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos + 1:]])\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            prev = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i]\n\n            # Calculate improvement in both objectives\n            obj1_improvement = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n                               distance_matrix_1[prev, next_node])\n            obj2_improvement = (distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n                               distance_matrix_2[prev, next_node])\n\n            # Combined score (can be adjusted based on preference)\n            score = obj1_improvement + obj2_improvement\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-objective edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n\n            # Evaluate segment in both objectives\n            current_obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n            current_obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n            # Reverse the segment\n            reversed_segment = segment[::-1]\n            reversed_obj1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1)) + distance_matrix_1[reversed_segment[-1], reversed_segment[0]]\n            reversed_obj2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1)) + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n\n            # Accept if at least one objective improves\n            if (reversed_obj1 < current_obj1) or (reversed_obj2 < current_obj2):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7594924382542001,
            0.9257027506828308
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion with multi-objective consideration\n    for _ in range(3):\n        # Select a node to relocate\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n\n        # Calculate potential improvement for both objectives\n        current_prev = new_solution[node_pos - 1] if node_pos > 0 else new_solution[-1]\n        current_next = new_solution[(node_pos + 1) % n]\n\n        # Remove the node from its current position\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos + 1:]])\n\n        # Find the best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_solution)):\n            prev = new_solution[i - 1] if i > 0 else new_solution[-1]\n            next_node = new_solution[i]\n\n            # Calculate improvement in both objectives\n            obj1_improvement = (distance_matrix_1[prev, node] + distance_matrix_1[node, next_node] -\n                               distance_matrix_1[prev, next_node])\n            obj2_improvement = (distance_matrix_2[prev, node] + distance_matrix_2[node, next_node] -\n                               distance_matrix_2[prev, next_node])\n\n            # Combined score (can be adjusted based on preference)\n            score = obj1_improvement + obj2_improvement\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Multi-objective edge optimization\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            segment = new_solution[i:j]\n\n            # Evaluate segment in both objectives\n            current_obj1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n            current_obj2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n            # Reverse the segment\n            reversed_segment = segment[::-1]\n            reversed_obj1 = sum(distance_matrix_1[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1)) + distance_matrix_1[reversed_segment[-1], reversed_segment[0]]\n            reversed_obj2 = sum(distance_matrix_2[reversed_segment[k], reversed_segment[k+1]] for k in range(len(reversed_segment)-1)) + distance_matrix_2[reversed_segment[-1], reversed_segment[0]]\n\n            # Accept if at least one objective improves\n            if (reversed_obj1 < current_obj1) or (reversed_obj2 < current_obj2):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This novel algorithm employs a multi-phase adaptive tour reconstruction strategy that combines probabilistic node reassignment with dynamic objective-aware segment inversion, leveraging both spatial and objective-based metrics to intelligently restructure the tour while maintaining feasibility through a constrained repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(6, n // 5))\n\n    # Phase 1: Probabilistic Node Reassignment\n    for _ in range(2):\n        # Select a segment to reassign\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment's objective impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weight = seg_cost1 + seg_cost2\n\n        # Probabilistically decide to reassign based on segment weight\n        if random.random() < (seg_weight / (seg_weight + 1000)):\n            # Reassign nodes based on combined objective impact\n            remaining_nodes = [node for node in new_solution if node not in segment]\n            new_segment = []\n\n            for _ in range(len(segment)):\n                # Select next node based on both objectives\n                candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    if not new_segment:\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                    else:\n                        prev_node = new_segment[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = (cost1 + cost2) / 2  # Balanced score\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Phase 2: Dynamic Objective-Aware Segment Inversion\n    for _ in range(3):\n        # Select inversion points with objective awareness\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, min(i + segment_size, n - 1))\n\n        # Calculate inversion impact\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[j], next_j]\n        current_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[j], next_j]\n\n        inverted_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n        inverted_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n        # Invert if it improves both objectives\n        if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2) or \\\n           random.random() < 0.3:  # Sometimes invert even if not better\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Rebuild missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8109877068293114,
            0.6015465259552002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(3, min(6, n // 5))\n\n    # Phase 1: Probabilistic Node Reassignment\n    for _ in range(2):\n        # Select a segment to reassign\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment's objective impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_weight = seg_cost1 + seg_cost2\n\n        # Probabilistically decide to reassign based on segment weight\n        if random.random() < (seg_weight / (seg_weight + 1000)):\n            # Reassign nodes based on combined objective impact\n            remaining_nodes = [node for node in new_solution if node not in segment]\n            new_segment = []\n\n            for _ in range(len(segment)):\n                # Select next node based on both objectives\n                candidates = random.sample(remaining_nodes, min(4, len(remaining_nodes)))\n                best_node = None\n                best_score = float('inf')\n\n                for node in candidates:\n                    if not new_segment:\n                        prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                    else:\n                        prev_node = new_segment[-1]\n                        next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                    cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                    cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                    score = (cost1 + cost2) / 2  # Balanced score\n\n                    if score < best_score:\n                        best_score = score\n                        best_node = node\n\n                new_segment.append(best_node)\n                remaining_nodes.remove(best_node)\n\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Phase 2: Dynamic Objective-Aware Segment Inversion\n    for _ in range(3):\n        # Select inversion points with objective awareness\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, min(i + segment_size, n - 1))\n\n        # Calculate inversion impact\n        prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_j = new_solution[j] if j < n - 1 else new_solution[0]\n\n        current_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[j], next_j]\n        current_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[j], next_j]\n\n        inverted_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[i], next_j]\n        inverted_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[i], next_j]\n\n        # Invert if it improves both objectives\n        if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2) or \\\n           random.random() < 0.3:  # Sometimes invert even if not better\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Feasibility repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Rebuild missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive node insertion with dynamic segment reversal to explore high-quality solutions by strategically reinserting nodes and reversing segments while ensuring feasibility and balancing the trade-off between both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic segment reversal\n    for _ in range(2):\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7409608883745549,
            0.5408432483673096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Dynamic segment reversal\n    for _ in range(2):\n        start = random.randint(0, n-3)\n        end = random.randint(start+2, n-1)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path rerouting with dynamic hub selection, where it intelligently reroutes segments of the tour around critical nodes (hubs) identified by their combined objective impact, while strategically repositioning these hubs to optimize both objectives simultaneously through a novel hub-aware segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    hub_size = max(2, min(3, n // 5))\n\n    # Identify hubs (nodes with high combined objective impact)\n    hub_candidates = []\n    for i in range(n):\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n        cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n        cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n        hub_candidates.append((cost1 + cost2, new_solution[i]))\n\n    hub_candidates.sort(reverse=True, key=lambda x: x[0])\n    hubs = [node for _, node in hub_candidates[:hub_size]]\n\n    # Adaptive path rerouting around hubs\n    for hub in hubs:\n        hub_pos = np.where(new_solution == hub)[0][0]\n        segment_size = max(2, min(4, n // 6))\n\n        # Select a segment to reroute around the hub\n        seg_start = max(0, hub_pos - segment_size)\n        seg_end = min(n, hub_pos + segment_size + 1)\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Reroute the segment around the hub\n        if len(segment) > 2:\n            # Reverse the segment excluding the hub\n            hub_index = np.where(segment == hub)[0][0]\n            segment = np.concatenate([segment[:hub_index], segment[hub_index:][::-1]])\n            new_solution[seg_start:seg_end] = segment\n\n    # Dynamic hub repositioning for further refinement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        if new_solution[i] in hubs:\n            # Find a position to insert the hub that improves both objectives\n            best_pos = -1\n            best_score = float('inf')\n\n            for j in range(n):\n                if i == j:\n                    continue\n\n                # Calculate score for inserting hub at position j\n                prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n                next_node = new_solution[j] if j < n-1 else new_solution[0]\n                cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n                cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = j\n\n            if best_pos != -1:\n                # Insert hub at best position\n                hub = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, best_pos, hub)\n\n    # Hub-aware segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6805700549854248,
            0.6228379607200623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    hub_size = max(2, min(3, n // 5))\n\n    # Identify hubs (nodes with high combined objective impact)\n    hub_candidates = []\n    for i in range(n):\n        prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n        next_node = new_solution[i+1] if i < n-1 else new_solution[0]\n        cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n        cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n        hub_candidates.append((cost1 + cost2, new_solution[i]))\n\n    hub_candidates.sort(reverse=True, key=lambda x: x[0])\n    hubs = [node for _, node in hub_candidates[:hub_size]]\n\n    # Adaptive path rerouting around hubs\n    for hub in hubs:\n        hub_pos = np.where(new_solution == hub)[0][0]\n        segment_size = max(2, min(4, n // 6))\n\n        # Select a segment to reroute around the hub\n        seg_start = max(0, hub_pos - segment_size)\n        seg_end = min(n, hub_pos + segment_size + 1)\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Reroute the segment around the hub\n        if len(segment) > 2:\n            # Reverse the segment excluding the hub\n            hub_index = np.where(segment == hub)[0][0]\n            segment = np.concatenate([segment[:hub_index], segment[hub_index:][::-1]])\n            new_solution[seg_start:seg_end] = segment\n\n    # Dynamic hub repositioning for further refinement\n    for _ in range(2):\n        i = random.randint(0, n-1)\n        if new_solution[i] in hubs:\n            # Find a position to insert the hub that improves both objectives\n            best_pos = -1\n            best_score = float('inf')\n\n            for j in range(n):\n                if i == j:\n                    continue\n\n                # Calculate score for inserting hub at position j\n                prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n                next_node = new_solution[j] if j < n-1 else new_solution[0]\n                cost1 = distance_matrix_1[prev_node, new_solution[i]] + distance_matrix_1[new_solution[i], next_node]\n                cost2 = distance_matrix_2[prev_node, new_solution[i]] + distance_matrix_2[new_solution[i], next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = j\n\n            if best_pos != -1:\n                # Insert hub at best position\n                hub = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, best_pos, hub)\n\n    # Hub-aware segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment insertion with dynamic edge reversal to explore high-quality solutions in both objective spaces by intelligently repositioning segments of the tour while maintaining feasibility and balancing the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment insertion\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        insert_pos = random.randint(0, n - segment_size)\n        while abs(insert_pos - seg_start) < segment_size:\n            insert_pos = random.randint(0, n - segment_size)\n\n        new_solution = np.delete(new_solution, np.s_[seg_start:seg_end])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic edge reversal with objective-aware selection\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            segment = new_solution[i:j]\n            cost1_before = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j]]\n            cost2_before = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j]]\n\n            reversed_segment = segment[::-1]\n            cost1_after = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n            # Accept if either objective improves\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8641948170863893,
            0.6000546813011169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment insertion\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        insert_pos = random.randint(0, n - segment_size)\n        while abs(insert_pos - seg_start) < segment_size:\n            insert_pos = random.randint(0, n - segment_size)\n\n        new_solution = np.delete(new_solution, np.s_[seg_start:seg_end])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Dynamic edge reversal with objective-aware selection\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if (j - i) > 1:\n            segment = new_solution[i:j]\n            cost1_before = distance_matrix_1[new_solution[i-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[j]]\n            cost2_before = distance_matrix_2[new_solution[i-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[j]]\n\n            reversed_segment = segment[::-1]\n            cost1_after = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[j]]\n            cost2_after = distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[j]]\n\n            # Accept if either objective improves\n            if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n                new_solution[i:j] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive tour fragmentation with dynamic node reinsertion to explore high-quality solutions by intelligently breaking and reassembling the tour while optimizing both objectives through selective node repositioning and feasibility-preserving operations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine fragmentation points based on problem size\n    n = len(new_solution)\n    frag_points = sorted(random.sample(range(1, n), min(3, n-1)))\n\n    # Fragment the tour and reinsert nodes in a new order\n    fragments = []\n    prev = 0\n    for point in frag_points:\n        fragments.append(new_solution[prev:point])\n        prev = point\n    fragments.append(new_solution[prev:])\n\n    # Shuffle fragments and reinsert nodes\n    random.shuffle(fragments)\n    new_solution = np.concatenate(fragments)\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(2):\n        # Select a random node and its new position\n        node_idx = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n\n        # Remove and reinsert the node\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8548278458981213,
            0.4719640016555786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine fragmentation points based on problem size\n    n = len(new_solution)\n    frag_points = sorted(random.sample(range(1, n), min(3, n-1)))\n\n    # Fragment the tour and reinsert nodes in a new order\n    fragments = []\n    prev = 0\n    for point in frag_points:\n        fragments.append(new_solution[prev:point])\n        prev = point\n    fragments.append(new_solution[prev:])\n\n    # Shuffle fragments and reinsert nodes\n    random.shuffle(fragments)\n    new_solution = np.concatenate(fragments)\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(2):\n        # Select a random node and its new position\n        node_idx = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n\n        # Remove and reinsert the node\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment inversion with dynamic objective-aware node swapping, where it intelligently inverts segments while strategically swapping nodes based on their combined objective impact, ensuring feasibility through a novel segment boundary preservation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective performance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive segment inversion with objective awareness\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_total > np.mean([obj[0] + obj[1] for _, obj in archive]):\n            new_segment = segment[::-1]\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic objective-aware node swapping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate impact of swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n            old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n            new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n            new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n            # Accept swap if it improves combined objective\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment boundary preservation\n    if random.random() < 0.5:\n        boundary_size = max(1, n // 10)\n        for i in range(boundary_size):\n            j = random.randint(0, n-1)\n            if j != i and new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8838984759400064,
            0.5401131510734558
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on combined objective performance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive segment inversion with objective awareness\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_total > np.mean([obj[0] + obj[1] for _, obj in archive]):\n            new_segment = segment[::-1]\n            new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic objective-aware node swapping\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Calculate impact of swap\n            prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n            next_i = new_solution[i+1] if i < n-1 else new_solution[0]\n            prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_j = new_solution[j+1] if j < n-1 else new_solution[0]\n\n            old_cost1 = distance_matrix_1[prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], next_j]\n            old_cost2 = distance_matrix_2[prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], next_j]\n\n            new_cost1 = distance_matrix_1[prev_i, new_solution[j]] + distance_matrix_1[new_solution[j], next_i] + \\\n                         distance_matrix_1[prev_j, new_solution[i]] + distance_matrix_1[new_solution[i], next_j]\n            new_cost2 = distance_matrix_2[prev_i, new_solution[j]] + distance_matrix_2[new_solution[j], next_i] + \\\n                         distance_matrix_2[prev_j, new_solution[i]] + distance_matrix_2[new_solution[i], next_j]\n\n            # Accept swap if it improves combined objective\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment boundary preservation\n    if random.random() < 0.5:\n        boundary_size = max(1, n // 10)\n        for i in range(boundary_size):\n            j = random.randint(0, n-1)\n            if j != i and new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This novel algorithm employs adaptive objective-balanced segment reconstruction with dynamic node reinsertion, where it selectively reconstructs segments from promising solutions while strategically reinserting nodes based on their normalized objective impact, ensuring feasibility through a probabilistic segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive objective-balanced segment reconstruction\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        max_cost1 = np.max(distance_matrix_1)\n        max_cost2 = np.max(distance_matrix_2)\n        norm_cost1 = seg_cost1 / max_cost1 if max_cost1 > 0 else 0\n        norm_cost2 = seg_cost2 / max_cost2 if max_cost2 > 0 else 0\n        combined_score = norm_cost1 + norm_cost2\n\n        # Reconstruct the segment with probabilistic node selection\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                norm_cost1 = cost1 / max_cost1 if max_cost1 > 0 else 0\n                norm_cost2 = cost2 / max_cost2 if max_cost2 > 0 else 0\n                score = (norm_cost1 + norm_cost2) / combined_score if combined_score > 0 else 0\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Probabilistic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        repair_prob = 0.7\n        for i in range(n):\n            if new_solution[i] not in unique_nodes and random.random() < repair_prob:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8701174742413207,
            0.7356231808662415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 2))\n\n    # Adaptive objective-balanced segment reconstruction\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        max_cost1 = np.max(distance_matrix_1)\n        max_cost2 = np.max(distance_matrix_2)\n        norm_cost1 = seg_cost1 / max_cost1 if max_cost1 > 0 else 0\n        norm_cost2 = seg_cost2 / max_cost2 if max_cost2 > 0 else 0\n        combined_score = norm_cost1 + norm_cost2\n\n        # Reconstruct the segment with probabilistic node selection\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                norm_cost1 = cost1 / max_cost1 if max_cost1 > 0 else 0\n                norm_cost2 = cost2 / max_cost2 if max_cost2 > 0 else 0\n                score = (norm_cost1 + norm_cost2) / combined_score if combined_score > 0 else 0\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reinsertion for further refinement\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n    # Probabilistic segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        repair_prob = 0.7\n        for i in range(n):\n            if new_solution[i] not in unique_nodes and random.random() < repair_prob:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment inversion with dynamic node insertion to explore diverse solution spaces by intelligently inverting segments and inserting nodes while balancing exploration and exploitation to maintain feasibility and improve solution quality across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 5))\n\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    for _ in range(2):\n        node = random.randint(0, n - 1)\n        pos = random.randint(0, n - 1)\n        if node != pos:\n            new_solution = np.insert(new_solution, pos, new_solution[node])\n            new_solution = np.delete(new_solution, node + (1 if node > pos else 0))\n\n    return new_solution\n\n",
        "score": [
            -0.8453560387591753,
            0.48103296756744385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 5))\n\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    for _ in range(2):\n        node = random.randint(0, n - 1)\n        pos = random.randint(0, n - 1)\n        if node != pos:\n            new_solution = np.insert(new_solution, pos, new_solution[node])\n            new_solution = np.delete(new_solution, node + (1 if node > pos else 0))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This novel algorithm employs a hierarchical two-phase optimization approach, where it first performs adaptive segment reordering based on Pareto dominance and then applies a dynamic node insertion heuristic that considers both objective impacts and spatial proximity to refine the solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    archive_solutions = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(3, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    # Hierarchical segment reordering\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment dominance\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Reorder segment based on combined impact\n        reordered = sorted(segment, key=lambda node: (distance_matrix_1[segment[0], node] + distance_matrix_2[segment[0], node]))\n        new_solution[seg_start:seg_end] = reordered\n\n    # Dynamic node insertion\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n\n        # Find insertion point based on spatial proximity and objective impact\n        candidates = [j for j in range(n) if j != i]\n        best_pos = None\n        best_score = float('inf')\n\n        for j in candidates:\n            prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node = new_solution[j]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = j\n\n        if best_pos is not None and best_pos != i:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6606227180135891,
            0.7689042687416077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good potential for improvement\n    archive_solutions = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = min(3, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(4, n // 4))\n\n    # Hierarchical segment reordering\n    for _ in range(2):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment dominance\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Reorder segment based on combined impact\n        reordered = sorted(segment, key=lambda node: (distance_matrix_1[segment[0], node] + distance_matrix_2[segment[0], node]))\n        new_solution[seg_start:seg_end] = reordered\n\n    # Dynamic node insertion\n    for _ in range(3):\n        i = random.randint(0, n - 1)\n        node = new_solution[i]\n\n        # Find insertion point based on spatial proximity and objective impact\n        candidates = [j for j in range(n) if j != i]\n        best_pos = None\n        best_score = float('inf')\n\n        for j in candidates:\n            prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node = new_solution[j]\n\n            cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = j\n\n        if best_pos is not None and best_pos != i:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This algorithm employs hierarchical segment partitioning with adaptive objective-weighted node substitution, where it dynamically divides the tour into hierarchical segments, evaluates them based on their combined objective impact, and substitutes nodes using a weighted scoring function that balances both objectives with adjustable parameters.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good combined objective performance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 2))\n\n    # Hierarchical segment partitioning\n    for _ in range(4):\n        # Select a segment to process\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate segment impact with weighted objective function\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        weight = 0.6  # Higher weight for first objective\n        seg_score = weight * seg_cost1 + (1 - weight) * seg_cost2\n\n        # Adaptive node substitution\n        for i in range(len(segment)):\n            node = segment[i]\n            candidates = [n for n in range(n) if n not in segment]\n            if not candidates:\n                continue\n\n            best_node = None\n            best_score = float('inf')\n\n            for candidate in candidates:\n                # Calculate potential score with weighted function\n                if i == 0:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                else:\n                    prev_node = segment[i-1]\n\n                if i == len(segment) - 1:\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    next_node = segment[i+1]\n\n                cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                score = weight * cost1 + (1 - weight) * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = candidate\n\n            if best_node is not None:\n                segment[i] = best_node\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = segment\n\n    # Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8286894562024327,
            6.2385066747665405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with good combined objective performance\n    archive_solutions = [sol for sol, obj in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(7, n // 2))\n\n    # Hierarchical segment partitioning\n    for _ in range(4):\n        # Select a segment to process\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate segment impact with weighted objective function\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        weight = 0.6  # Higher weight for first objective\n        seg_score = weight * seg_cost1 + (1 - weight) * seg_cost2\n\n        # Adaptive node substitution\n        for i in range(len(segment)):\n            node = segment[i]\n            candidates = [n for n in range(n) if n not in segment]\n            if not candidates:\n                continue\n\n            best_node = None\n            best_score = float('inf')\n\n            for candidate in candidates:\n                # Calculate potential score with weighted function\n                if i == 0:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                else:\n                    prev_node = segment[i-1]\n\n                if i == len(segment) - 1:\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    next_node = segment[i+1]\n\n                cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n                cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n                score = weight * cost1 + (1 - weight) * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = candidate\n\n            if best_node is not None:\n                segment[i] = best_node\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = segment\n\n    # Final validation\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive path inversion with dynamic objective-aware node insertion, where it selectively inverts segments of the tour based on their combined objective impact and strategically inserts nodes from other high-performing solutions to create diversified neighbors while maintaining feasibility through a multi-phase validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive path inversion based on objective impact\n    for _ in range(3):\n        # Select a segment to invert\n        seg_size = max(2, min(5, n // 4))\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert segment if it has high impact\n        if seg_total > (distance_matrix_1.mean() + distance_matrix_2.mean()) * seg_size / 2:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Phase 2: Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to insert from another solution\n        donor_sol = random.choice(archive_solutions)\n        donor_node = random.choice(donor_sol)\n\n        if donor_node not in new_solution:\n            # Find best insertion position based on combined objective impact\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, donor_node] + distance_matrix_1[donor_node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, donor_node] + distance_matrix_2[donor_node, next_node] - distance_matrix_2[prev_node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the node\n            new_solution = np.insert(new_solution, best_pos, donor_node)\n            new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Phase 3: Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    # Final check to ensure all nodes are present\n    if len(np.unique(new_solution)) != n:\n        # If still invalid, return a random permutation\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
        "score": [
            -0.8214037691280144,
            0.5414956212043762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive path inversion based on objective impact\n    for _ in range(3):\n        # Select a segment to invert\n        seg_size = max(2, min(5, n // 4))\n        seg_start = random.randint(0, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert segment if it has high impact\n        if seg_total > (distance_matrix_1.mean() + distance_matrix_2.mean()) * seg_size / 2:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Phase 2: Dynamic objective-aware node insertion\n    for _ in range(2):\n        # Select a node to insert from another solution\n        donor_sol = random.choice(archive_solutions)\n        donor_node = random.choice(donor_sol)\n\n        if donor_node not in new_solution:\n            # Find best insertion position based on combined objective impact\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                prev_node = new_solution[i-1] if i > 0 else new_solution[-1]\n                next_node = new_solution[i] if i < n-1 else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, donor_node] + distance_matrix_1[donor_node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, donor_node] + distance_matrix_2[donor_node, next_node] - distance_matrix_2[prev_node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the node\n            new_solution = np.insert(new_solution, best_pos, donor_node)\n            new_solution = new_solution[:n]  # Ensure length remains the same\n\n    # Phase 3: Multi-phase validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by replacing duplicates with missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    # Final check to ensure all nodes are present\n    if len(np.unique(new_solution)) != n:\n        # If still invalid, return a random permutation\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm employs adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their normalized objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        max_cost1 = max(distance_matrix_1.max(), 1)\n        max_cost2 = max(distance_matrix_2.max(), 1)\n        normalized_cost = (seg_cost1 / max_cost1) + (seg_cost2 / max_cost2)\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on normalized objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                normalized_score = (cost1 / max_cost1) + (cost2 / max_cost2)\n\n                if normalized_score < best_score:\n                    best_score = normalized_score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.8980799122826716,
            0.9350772500038147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate normalized segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        max_cost1 = max(distance_matrix_1.max(), 1)\n        max_cost2 = max(distance_matrix_2.max(), 1)\n        normalized_cost = (seg_cost1 / max_cost1) + (seg_cost2 / max_cost2)\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on normalized objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                normalized_score = (cost1 / max_cost1) + (cost2 / max_cost2)\n\n                if normalized_score < best_score:\n                    best_score = normalized_score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This novel algorithm combines adaptive multi-objective path inversion with dynamic segment reordering, where it selectively inverts segments of the tour based on their combined objective impact while strategically reordering segments to explore diverse neighborhood structures, ensuring feasibility through a novel path validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 5))\n\n    # Adaptive multi-objective path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic segment reordering\n    for _ in range(2):\n        # Select two segments to reorder\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments are distinct and don't overlap\n        while (seg1_start == seg2_start or abs(seg1_start - seg2_start) < segment_size):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Reorder the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        if random.random() < 0.5:\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n        else:\n            new_solution[seg1_start:seg1_end] = seg2[::-1]\n            new_solution[seg2_start:seg2_end] = seg1[::-1]\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.837462573029025,
            0.36097389459609985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 5))\n\n    # Adaptive multi-objective path inversion\n    for _ in range(3):\n        # Select a segment to invert\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Invert the segment if it shows potential for improvement\n        if random.random() < 0.7 or seg_total > (distance_matrix_1[segment[0], segment[-1]] + distance_matrix_2[segment[0], segment[-1]]):\n            new_solution[seg_start:seg_end] = segment[::-1]\n\n    # Dynamic segment reordering\n    for _ in range(2):\n        # Select two segments to reorder\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments are distinct and don't overlap\n        while (seg1_start == seg2_start or abs(seg1_start - seg2_start) < segment_size):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Reorder the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        if random.random() < 0.5:\n            new_solution[seg1_start:seg1_end] = seg2\n            new_solution[seg2_start:seg2_end] = seg1\n        else:\n            new_solution[seg1_start:seg1_end] = seg2[::-1]\n            new_solution[seg2_start:seg2_end] = seg1[::-1]\n\n    # Path validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This novel algorithm employs a hybrid approach combining adaptive path decomposition with multi-objective node swapping, where it intelligently partitions the tour into segments, evaluates their impact across objectives, and performs targeted node swaps while ensuring feasibility through a dynamic validation and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path decomposition\n    for _ in range(3):\n        # Select a random segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Multi-objective node swapping\n        if len(segment) > 2:\n            # Select two nodes in the segment\n            i, j = sorted(random.sample(range(len(segment)), 2))\n            node_i, node_j = segment[i], segment[j]\n\n            # Calculate potential improvement\n            prev_i = segment[i-1] if i > 0 else new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n            next_i = segment[i+1] if i < len(segment)-1 else new_solution[seg_end] if seg_end < n else new_solution[0]\n            prev_j = segment[j-1] if j > 0 else new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n            next_j = segment[j+1] if j < len(segment)-1 else new_solution[seg_end] if seg_end < n else new_solution[0]\n\n            # Current costs\n            current_cost = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # Swapped costs\n            swapped_cost = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                            distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                            distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j] +\n                            distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            # Apply swap if beneficial\n            if swapped_cost < current_cost:\n                segment[i], segment[j] = segment[j], segment[i]\n\n        # Update the segment in the solution\n        new_solution[seg_start:seg_end] = segment\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.739355878463082,
            0.6053904294967651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive path decomposition\n    for _ in range(3):\n        # Select a random segment\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Evaluate segment impact\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n\n        # Multi-objective node swapping\n        if len(segment) > 2:\n            # Select two nodes in the segment\n            i, j = sorted(random.sample(range(len(segment)), 2))\n            node_i, node_j = segment[i], segment[j]\n\n            # Calculate potential improvement\n            prev_i = segment[i-1] if i > 0 else new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n            next_i = segment[i+1] if i < len(segment)-1 else new_solution[seg_end] if seg_end < n else new_solution[0]\n            prev_j = segment[j-1] if j > 0 else new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n            next_j = segment[j+1] if j < len(segment)-1 else new_solution[seg_end] if seg_end < n else new_solution[0]\n\n            # Current costs\n            current_cost = (distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i] +\n                            distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i] +\n                            distance_matrix_1[prev_j, node_j] + distance_matrix_1[node_j, next_j] +\n                            distance_matrix_2[prev_j, node_j] + distance_matrix_2[node_j, next_j])\n\n            # Swapped costs\n            swapped_cost = (distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i] +\n                            distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i] +\n                            distance_matrix_1[prev_j, node_i] + distance_matrix_1[node_i, next_j] +\n                            distance_matrix_2[prev_j, node_i] + distance_matrix_2[node_i, next_j])\n\n            # Apply swap if beneficial\n            if swapped_cost < current_cost:\n                segment[i], segment[j] = segment[j], segment[i]\n\n        # Update the segment in the solution\n        new_solution[seg_start:seg_end] = segment\n\n    # Dynamic validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm combines adaptive multi-objective segment reconstruction with dynamic node reallocation, where it intelligently selects and reconstructs segments from high-performing solutions while strategically reallocating nodes based on their combined objective impact, ensuring feasibility through a novel segment validation and repair mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive multi-objective segment reconstruction\n    for _ in range(3):\n        # Select a segment to reconstruct\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n        segment = new_solution[seg_start:seg_end]\n\n        # Calculate segment impact in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, len(segment)))\n        seg_total = seg_cost1 + seg_cost2\n\n        # Reconstruct the segment by reallocating nodes\n        remaining_nodes = [node for node in new_solution if node not in segment]\n        new_segment = []\n\n        for _ in range(len(segment)):\n            # Select next node based on combined objective impact\n            candidates = random.sample(remaining_nodes, min(3, len(remaining_nodes)))\n            best_node = None\n            best_score = float('inf')\n\n            for node in candidates:\n                if not new_segment:\n                    # For first node in new segment\n                    prev_node = new_solution[seg_start-1] if seg_start > 0 else new_solution[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n                else:\n                    prev_node = new_segment[-1]\n                    next_node = new_solution[seg_end] if seg_end < n else new_solution[0]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                score = cost1 + cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_node = node\n\n            new_segment.append(best_node)\n            remaining_nodes.remove(best_node)\n\n        # Replace the segment\n        new_solution[seg_start:seg_end] = new_segment\n\n    # Dynamic node reallocation for further refinement\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if new_solution[i] != new_solution[j]:\n            # Swap nodes if they don't create duplicates\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Repair by inserting missing nodes\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This novel algorithm combines adaptive segment inversion with multi-objective edge insertion, where it dynamically selects and inverts segments of the tour while strategically inserting edges based on their combined objective improvement potential, ensuring feasibility through a novel segment validation and repair mechanism with a probabilistic acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        current_total = current_cost1 + current_cost2\n\n        # Invert the segment\n        inverted_segment = new_solution[seg_start:seg_end][::-1]\n        new_solution[seg_start:seg_end] = inverted_segment\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_total = new_cost1 + new_cost2\n\n        # Probabilistic acceptance based on improvement\n        if new_total >= current_total and random.random() > 0.3:\n            # Revert if not improved enough\n            new_solution[seg_start:seg_end] = inverted_segment[::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Calculate potential edge insertion\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Find insertion point\n            insertion_point = random.randint(0, n-1)\n            if insertion_point != i and insertion_point != j:\n                # Calculate cost of current edges\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Calculate cost of new edges\n                new_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[j]]\n\n                # Probabilistic acceptance based on improvement\n                if (new_cost1 + new_cost2) < (current_cost1 + current_cost2) or random.random() > 0.5:\n                    # Insert the edge\n                    new_solution = np.insert(new_solution, insertion_point, node_j)\n                    new_solution = np.delete(new_solution, j if j > i else i)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.7315384204383883,
            0.5394730567932129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 3))\n\n    # Adaptive segment inversion\n    for _ in range(3):\n        seg_start = random.randint(0, n - segment_size)\n        seg_end = seg_start + segment_size\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        current_total = current_cost1 + current_cost2\n\n        # Invert the segment\n        inverted_segment = new_solution[seg_start:seg_end][::-1]\n        new_solution[seg_start:seg_end] = inverted_segment\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(seg_start, seg_end))\n        new_total = new_cost1 + new_cost2\n\n        # Probabilistic acceptance based on improvement\n        if new_total >= current_total and random.random() > 0.3:\n            # Revert if not improved enough\n            new_solution[seg_start:seg_end] = inverted_segment[::-1]\n\n    # Multi-objective edge insertion\n    for _ in range(2):\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            # Calculate potential edge insertion\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Find insertion point\n            insertion_point = random.randint(0, n-1)\n            if insertion_point != i and insertion_point != j:\n                # Calculate cost of current edges\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                # Calculate cost of new edges\n                new_cost1 = distance_matrix_1[new_solution[i-1], node_j] + distance_matrix_1[node_j, new_solution[j]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], node_j] + distance_matrix_2[node_j, new_solution[j]]\n\n                # Probabilistic acceptance based on improvement\n                if (new_cost1 + new_cost2) < (current_cost1 + current_cost2) or random.random() > 0.5:\n                    # Insert the edge\n                    new_solution = np.insert(new_solution, insertion_point, node_j)\n                    new_solution = np.delete(new_solution, j if j > i else i)\n\n    # Segment validation and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing.pop(0)\n\n    return new_solution\n\n"
    }
]