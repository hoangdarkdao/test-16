[
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9773673423984225,
               0.18285882472991943
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify the most promising candidate for local improvement, prioritizing those with lower objective values or exhibiting characteristics of suboptimality (e.g., high edge crossings or non-dominated solutions). It then applies a novel hybrid local search strategy that combines a segment inversion operator with a biased 3-opt move, where the inversion is guided by the relative costs of edges in the two objective spaces, and the 3-opt is constrained to preserve feasibility by ensuring no nodes are skipped or revisited. The inversion operator selects two random segments of the tour and reverses their order, while the 3-opt operator identifies three non-adjacent edges and reconnects them to form a new cycle, with the selection of edges biased towards those with higher relative costs in either objective space. The function ensures feasibility by validating the generated neighbor solution before returning it, thus maintaining the integrity of the TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives as the base\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with biased 3-opt\n    if n >= 4:\n        # Segment inversion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Biased 3-opt: select edges with higher relative costs\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            edges.append((i, (i + 1) % n, max(cost1, cost2)))\n\n        # Sort edges by descending cost and select top 3\n        edges.sort(key=lambda x: -x[2])\n        selected_edges = [edge for edge in edges[:3]]\n\n        if len(selected_edges) == 3:\n            # Perform 3-opt swap\n            i1, j1, _ = selected_edges[0]\n            i2, j2, _ = selected_edges[1]\n            i3, j3, _ = selected_edges[2]\n\n            # Ensure edges are non-adjacent and can form a valid cycle\n            if not (abs(i1 - i2) == 1 or abs(i1 - i3) == 1 or abs(i2 - i3) == 1):\n                # Create a new segment by reconnecting the edges\n                segment = new_solution[i1:j1] + new_solution[i2:j2] + new_solution[i3:j3]\n                new_solution = np.concatenate([new_solution[:i1], segment[::-1], new_solution[j3:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8976962591238635,
               0.14388447999954224
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9022264279058461,
               0.18054747581481934
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by clustering solutions in the archive based on their objective values using a k-means algorithm, then selects a representative solution from each cluster to maintain diversity. It then applies a novel adaptive local search strategy that dynamically switches between three operators (edge swap, node insertion, and segment reversal) based on the current solution's improvement potential, where each operator is selected probabilistically according to its historical success rate. The search process is guided by a multi-objective evaluation that considers both the immediate improvement in objectives and the structural diversity of the generated neighbors, with feasibility maintained through a comprehensive validation step that checks for duplicate nodes, missing nodes, and invalid cycles, using a fallback mechanism to revert to the original solution if any infeasibility is detected. The function also incorporates a memory mechanism that tracks previously successful operators and adjusts their selection probabilities, creating an adaptive learning process that evolves the search strategy over time.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Cluster solutions and select representatives\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        from sklearn.cluster import KMeans\n        k = min(3, len(archive))\n        kmeans = KMeans(n_clusters=k, random_state=42).fit(objectives)\n        cluster_labels = kmeans.labels_\n        representatives = []\n        for i in range(k):\n            cluster_indices = np.where(cluster_labels == i)[0]\n            if len(cluster_indices) > 0:\n                # Select a random solution from the cluster\n                selected_idx = np.random.choice(cluster_indices)\n                representatives.append(archive[selected_idx][0])\n        if representatives:\n            base_solution = representatives[np.random.choice(len(representatives))]\n        else:\n            base_solution = archive[0][0]\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        # Adaptive operator selection\n        operator_probs = {'swap': 0.3, 'insert': 0.3, 'reverse': 0.4}  # Initial probabilities\n        operator = np.random.choice(list(operator_probs.keys()), p=list(operator_probs.values()))\n\n        if operator == 'swap':\n            # Edge swap\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'insert':\n            # Node insertion\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        elif operator == 'reverse':\n            # Segment reversal\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Validate solution\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) != n or np.any(counts != 1):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9862663648604585,
               4.586995720863342
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a novel multi-phase approach that combines archive analysis with a dynamic segment-based local search strategy. It first identifies candidate solutions by evaluating their objective trade-offs and structural diversity, then selects the most promising one through a weighted tournament selection that balances objective values and solution structure. For local search, it uses a hybrid strategy that dynamically alternates between segment inversion, segment relocation, and a novel \"segment fusion\" operator, where adjacent segments are merged and reordered to create more diverse neighbors. The operator ensures feasibility by maintaining a valid TSP tour through a cycle validation step, and employs a dynamic fallback mechanism that reverts to the original solution if the neighbor is infeasible. Additionally, the function incorporates a guided edge insertion step that strategically places nodes based on their relative costs in both objective spaces, while prioritizing diversity by favoring solutions with high crowding distances in the archive. The algorithm dynamically adjusts its search strategy based on the current archive state, favoring exploration when diversity is high and exploitation when convergence is detected, resulting in high-quality solutions across multiple objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective trade-off\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment-based local search\n    operator = np.random.choice(['inversion', 'relocation', 'fusion'])\n\n    if operator == 'inversion':\n        # Segment inversion with guided selection\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n    elif operator == 'relocation':\n        # Segment relocation with cost-based insertion\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position\n        min_cost = float('inf')\n        best_pos = -1\n        for i in range(n - segment_length):\n            if i >= start and i < start + segment_length:\n                continue\n            cost = (distance_matrix_1[new_solution[i], segment[0]] + distance_matrix_1[segment[-1], new_solution[(i+segment_length)%n]] +\n                    distance_matrix_2[new_solution[i], segment[0]] + distance_matrix_2[segment[-1], new_solution[(i+segment_length)%n]])\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = i\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:-segment_length] if best_pos + segment_length < n else new_solution[best_pos:]\n            ])\n    else:  # fusion\n        # Segment fusion and reordering\n        num_segments = np.random.randint(2, min(4, n//3))\n        split_points = sorted(np.random.choice(range(1, n), num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + split_points, split_points + [n])]\n\n        # Merge and reorder segments\n        while len(segments) > 1:\n            i, j = np.random.choice(len(segments), 2, replace=False)\n            if i > j:\n                i, j = j, i\n            merged = np.concatenate([segments[i], segments[j]])\n            segments = segments[:i] + [merged] + segments[j+1:]\n\n        new_solution = segments[0]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        return selected_solution\n\n    return new_solution\n\n",
          "score": [
               -0.9575355474345375,
               0.2782154679298401
          ]
     },
     {
          "algorithm": "{The new algorithm for select_neighbor first identifies the solution in the archive with the highest combined objective value, then applies a novel two-phase local search: first, it performs a probabilistic segment rotation that randomly selects and rotates segments of the tour in a way that maintains feasibility, followed by a guided edge replacement that strategically replaces edges with those that show the most potential for reducing both objectives simultaneously, while ensuring the solution remains a valid tour through a comprehensive cycle validation and repair mechanism that includes a fallback to the original solution if any invalidity is detected.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Phase 1: Probabilistic segment rotation\n        num_rotations = np.random.randint(1, min(4, n//2))\n        for _ in range(num_rotations):\n            segment_length = np.random.randint(2, min(6, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            rotation = np.random.randint(1, segment_length)\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Phase 2: Guided edge replacement\n        for _ in range(min(3, n//2)):\n            # Select edges to replace\n            edge1 = np.random.randint(0, n)\n            edge2 = np.random.randint(0, n)\n            while edge2 == edge1 or abs(edge1 - edge2) <= 1:\n                edge2 = np.random.randint(0, n)\n\n            # Calculate potential replacement cost\n            def replacement_cost(a, b, c, d):\n                return (distance_matrix_1[a, c] + distance_matrix_1[c, d] + distance_matrix_1[b, d] + distance_matrix_1[a, b] -\n                        distance_matrix_1[a, b] - distance_matrix_1[c, d])\n\n            node_a, node_b = new_solution[edge1], new_solution[(edge1+1)%n]\n            node_c, node_d = new_solution[edge2], new_solution[(edge2+1)%n]\n\n            if replacement_cost(node_a, node_b, node_c, node_d) < 0:\n                # Perform replacement\n                new_solution[edge1], new_solution[edge2] = new_solution[edge2], new_solution[edge1]\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9553915040636932,
               0.2602725625038147
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8243285838347048,
               0.17931151390075684
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify the most promising candidate for local improvement, prioritizing those with lower objective values or exhibiting characteristics of suboptimality (e.g., high edge crossings or non-dominated solutions). It then applies a hybrid local search strategy that combines a novel segment inversion operator with a biased 3-opt move, where the inversion is guided by the relative costs of edges in the two objective spaces, and the 3-opt is constrained to preserve feasibility by ensuring no nodes are skipped or revisited. The inversion operator selects two random segments of the tour and reverses their order, while the 3-opt operator identifies three non-adjacent edges and reconnects them to form a new cycle, with the selection of edges biased towards those with higher relative costs in either objective space. The function ensures feasibility by validating the generated neighbor solution before returning it, thus maintaining the integrity of the TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives as the base\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with biased 3-opt\n    if n >= 4:\n        # Segment inversion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Biased 3-opt: select edges with higher relative costs\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            edges.append((i, (i + 1) % n, max(cost1, cost2)))\n\n        # Sort edges by descending cost and select top 3\n        edges.sort(key=lambda x: -x[2])\n        selected_edges = [edge for edge in edges[:3]]\n\n        if len(selected_edges) == 3:\n            # Perform 3-opt swap\n            i1, j1, _ = selected_edges[0]\n            i2, j2, _ = selected_edges[1]\n            i3, j3, _ = selected_edges[2]\n\n            # Ensure edges are non-adjacent and can form a valid cycle\n            if not (abs(i1 - i2) == 1 or abs(i1 - i3) == 1 or abs(i2 - i3) == 1):\n                # Create a new segment by reconnecting the edges\n                segment = new_solution[i1:j1] + new_solution[i2:j2] + new_solution[i3:j3]\n                new_solution = np.concatenate([new_solution[:i1], segment[::-1], new_solution[j3:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8609101435913555,
               0.23056882619857788
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by evaluating the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel adaptive local search strategy that combines a multi-segment inversion with a guided edge swapping, where the inversion reverses randomly selected segments of the tour while the swapping exchanges edges based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment inversion\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        for i in range(len(segments)):\n            segments[i] = segments[i][::-1]  # Reverse each segment\n        new_solution = np.concatenate(segments)\n\n        # Guided edge swapping\n        for _ in range(min(3, n//2)):\n            # Select two edges to swap\n            edge1 = np.random.randint(n)\n            edge2 = np.random.randint(n)\n            while edge2 == edge1 or edge2 == (edge1 + 1) % n:\n                edge2 = np.random.randint(n)\n\n            # Calculate cost before swap\n            prev1 = new_solution[edge1]\n            next1 = new_solution[(edge1 + 1) % n]\n            prev2 = new_solution[edge2]\n            next2 = new_solution[(edge2 + 1) % n]\n\n            cost_before = (distance_matrix_1[prev1, next1] + distance_matrix_1[prev2, next2] +\n                          distance_matrix_2[prev1, next1] + distance_matrix_2[prev2, next2])\n\n            # Perform swap\n            new_solution[edge1], new_solution[(edge1 + 1) % n] = new_solution[(edge1 + 1) % n], new_solution[edge1]\n            new_solution[edge2], new_solution[(edge2 + 1) % n] = new_solution[(edge2 + 1) % n], new_solution[edge2]\n\n            # Calculate cost after swap\n            prev1_new = new_solution[edge1]\n            next1_new = new_solution[(edge1 + 1) % n]\n            prev2_new = new_solution[edge2]\n            next2_new = new_solution[(edge2 + 1) % n]\n\n            cost_after = (distance_matrix_1[prev1_new, next1_new] + distance_matrix_1[prev2_new, next2_new] +\n                         distance_matrix_2[prev1_new, next1_new] + distance_matrix_2[prev2_new, next2_new])\n\n            # Revert if cost increases\n            if cost_after > cost_before:\n                new_solution[edge1], new_solution[(edge1 + 1) % n] = new_solution[(edge1 + 1) % n], new_solution[edge1]\n                new_solution[edge2], new_solution[(edge2 + 1) % n] = new_solution[(edge2 + 1) % n], new_solution[edge2]\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8883848512127939,
               0.2525418996810913
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-phase approach to intelligently select a promising solution from the archive and generate a high-quality neighbor solution. First, it identifies candidate solutions by evaluating their objective values and structural diversity, using a weighted sum of normalized objectives to prioritize solutions with good trade-offs. Next, it selects the most promising candidate through tournament selection, favoring solutions with higher diversity and better objective values. For local search, it employs a hybrid strategy combining edge inversion and segment relocation, where segments of the tour are either inverted or relocated to different positions while maintaining feasibility. The algorithm ensures feasibility by strictly enforcing the TSP constraints (no node repetition or omission) and uses the provided distance matrices to evaluate the quality of generated neighbors. The process iteratively refines the solution by accepting improvements in either objective while maintaining Pareto dominance, and terminates when no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (simplified for this example)\n    # In practice, implement a more sophisticated selection mechanism\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between inversion and relocation\n    if np.random.rand() < 0.5:\n        # Segment inversion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment relocation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If infeasible, revert to original\n        return selected_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7012671140032183,
               0.2083536982536316
          ]
     }
]