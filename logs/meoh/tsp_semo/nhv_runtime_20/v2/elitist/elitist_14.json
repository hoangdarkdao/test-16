[
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9957873510296426,
            0.3842282295227051
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Prioritize non-dominated solutions with high diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(5, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(6, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(6, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9790134761382666,
            0.07310903072357178
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601362894719456,
            0.18925809860229492
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" and an additional \"node inversion\" step to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n            if np.random.random() < 0.3:\n                invert_start = np.random.randint(0, n - 2)\n                invert_end = np.random.randint(invert_start + 2, n)\n                new_solution[invert_start:invert_end] = new_solution[invert_start:invert_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9659346655023324,
            0.07538694143295288
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel \"multi-segment rotation\" combined with \"objective-aware segment insertion\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment rotation with objective-aware selection\n    if n > 4:\n        num_segments = np.random.randint(2, min(4, n//3))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n        segment_starts = np.random.choice(range(n - sum(segment_lengths)), size=num_segments, replace=False)\n\n        segments = []\n        for start, length in zip(segment_starts, segment_lengths):\n            segments.append(new_solution[start:start+length])\n\n        # Calculate segment costs in both objectives\n        segment_costs = []\n        for segment in segments:\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            segment_costs.append((cost1, cost2))\n\n        # Rotate segments if it improves at least one objective\n        if num_segments > 1:\n            rotated_segments = segments[1:] + [segments[0]]\n            rotated_costs = segment_costs[1:] + [segment_costs[0]]\n\n            original_total = sum(cost[0] + cost[1] for cost in segment_costs)\n            rotated_total = sum(cost[0] + cost[1] for cost in rotated_costs)\n\n            if rotated_total < original_total:\n                segments = rotated_segments\n\n        # Reinsert segments at new positions\n        for i, (start, length) in enumerate(zip(segment_starts, segment_lengths)):\n            new_position = np.random.randint(0, n - length)\n            segment = segments[i]\n            new_solution = np.concatenate([\n                new_solution[:new_position],\n                segment,\n                new_solution[new_position:new_position+length],\n                new_solution[new_position+length:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.9232470030410538,
            0.1193494200706482
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9957873510296426,
            0.3842282295227051
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and distance-based diversity, then applies a novel \"multi-segment rotation\" and \"distance-aware segment insertion\" strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and distance-based diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Multi-segment rotation: Select two segments and rotate their positions\n        segment_length = np.random.randint(2, min(5, n))\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        segment1 = new_solution[start1:start1+segment_length]\n        segment2 = new_solution[start2:start2+segment_length]\n\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n        # Distance-aware segment insertion: Insert a segment at a position that minimizes distance in both objectives\n        if n > 8:\n            segment_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - segment_length)\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n            # Find best insertion point based on distance in both objectives\n            min_cost = float('inf')\n            best_pos = 0\n            for pos in range(len(new_solution) - segment_length + 1):\n                temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n                cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n                total_cost = cost1 + cost2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9957873510296426,
            0.3842282295227051
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment reversal with objective-aware segment selection\n    if n > 4:\n        # Objective-aware segment selection\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment costs in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        segment_cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Reverse if it improves at least one objective\n        if segment_cost1 > distance_matrix_1[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n        elif segment_cost2 > distance_matrix_2[segment[-1], segment[0]]:\n            new_solution[start:start+segment_length] = segment[::-1]\n\n        # Cross-segment merge with diversity consideration\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+first_length]\n\n            # Merge segments if it improves diversity\n            if len(set(first_segment)) > len(set(second_segment)):\n                new_solution[first_start:first_start+first_length] = second_segment\n            else:\n                new_solution[second_start:second_start+first_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9843618229617754,
            0.07264900207519531
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a heuristic that considers both objective values and diversity, then applies a novel segment rotation and adaptive perturbation strategy that combines local and global reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    n = len(instance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n    new_solution[a:b+1] = rotated_segment\n\n    if random.random() < 0.3:\n        c = random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:c], new_solution[c+1:], [new_solution[c]]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9955756972706151,
            0.19696515798568726
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    }
]