[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm implements a novel multi-objective segment relocation and inversion strategy that identifies segments based on their contribution to both objectives, relocates them to positions that optimize both objectives simultaneously while ensuring feasibility, and inverts segments to explore additional solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(5, n // 2))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[relocated[k-1], relocated[k]] for k in range(len(relocated))) + sum(distance_matrix_2[relocated[k-1], relocated[k]] for k in range(len(relocated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm implements a multi-objective segment inversion and adaptive relocation strategy that inverts segments based on their combined objective contribution, adaptively relocates them to positions that balance both objectives using a dynamic weighting scheme, and ensures feasibility by repairing missing nodes with a probabilistic insertion approach.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(4, n // 3))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.6:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.6 + 0.4 * (current_cost1 / (current_cost1 + current_cost2))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.8472060232418075,
            7.698803190896254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(4, n // 3))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.6:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.6 + 0.4 * (current_cost1 / (current_cost1 + current_cost2))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm implements a novel multi-objective segment relocation and inversion strategy that identifies segments based on their contribution to both objectives, relocates them to positions that optimize both objectives simultaneously while ensuring feasibility, and inverts segments to explore additional solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(5, n // 2))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[relocated[k-1], relocated[k]] for k in range(len(relocated))) + sum(distance_matrix_2[relocated[k-1], relocated[k]] for k in range(len(relocated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm implements a multi-objective adaptive segment fusion and dynamic node rearrangement strategy that combines probabilistic segment merging with intelligent node repositioning, dynamically optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(2, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segments.append(segment)\n\n    fused_segments = []\n    for i in range(0, len(segments), 2):\n        if i + 1 < len(segments):\n            merged = np.concatenate((segments[i], segments[i+1]))\n            if random.random() < 0.5:\n                merged = merged[::-1]\n            fused_segments.append(merged)\n        else:\n            fused_segments.append(segments[i])\n\n    reassembled = []\n    for segment in fused_segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 if pos == 0 or pos == len(reassembled) else 0.3\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.7 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm implements a novel multi-objective adaptive segment rotation and dynamic node reordering strategy that rotates segments of varying lengths in both clockwise and counter-clockwise directions, evaluates their contribution to both objectives using adaptive weighting, and dynamically reorders nodes to optimize both objectives while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(7, n // 2))\n    rotation_direction = random.choice([1, -1])\n\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        if len(segment) > 1 and random.random() < 0.7:\n            segment = np.roll(segment, rotation_direction)\n        segments.append(segment)\n\n    rotated = []\n    for segment in segments:\n        if not rotated:\n            rotated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(rotated) + 1):\n            candidate = rotated[:pos] + segment.tolist() + rotated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(rotated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[rotated[k-1], rotated[k]] for k in range(len(rotated))) + sum(distance_matrix_2[rotated[k-1], rotated[k]] for k in range(len(rotated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            rotated = rotated[:best_pos] + segment.tolist() + rotated[best_pos:]\n\n    _, unique_indices = np.unique(rotated, return_index=True)\n    new_solution = np.array(rotated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if random.random() < 0.3:\n        for _ in range(min(3, n // 2)):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.07214755849866,
            8.575671738275384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(7, n // 2))\n    rotation_direction = random.choice([1, -1])\n\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        if len(segment) > 1 and random.random() < 0.7:\n            segment = np.roll(segment, rotation_direction)\n        segments.append(segment)\n\n    rotated = []\n    for segment in segments:\n        if not rotated:\n            rotated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(rotated) + 1):\n            candidate = rotated[:pos] + segment.tolist() + rotated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(rotated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[rotated[k-1], rotated[k]] for k in range(len(rotated))) + sum(distance_matrix_2[rotated[k-1], rotated[k]] for k in range(len(rotated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            rotated = rotated[:best_pos] + segment.tolist() + rotated[best_pos:]\n\n    _, unique_indices = np.unique(rotated, return_index=True)\n    new_solution = np.array(rotated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    if random.random() < 0.3:\n        for _ in range(min(3, n // 2)):\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm implements a novel multi-objective segment relocation and inversion strategy that identifies segments based on their contribution to both objectives, relocates them to positions that optimize both objectives simultaneously while ensuring feasibility, and inverts segments to explore additional solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(5, n // 2))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[relocated[k-1], relocated[k]] for k in range(len(relocated))) + sum(distance_matrix_2[relocated[k-1], relocated[k]] for k in range(len(relocated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm implements a multi-objective adaptive segment fusion and dynamic node rearrangement strategy that combines probabilistic segment merging with intelligent node repositioning, dynamically optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(2, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segments.append(segment)\n\n    fused_segments = []\n    for i in range(0, len(segments), 2):\n        if i + 1 < len(segments):\n            merged = np.concatenate((segments[i], segments[i+1]))\n            if random.random() < 0.5:\n                merged = merged[::-1]\n            fused_segments.append(merged)\n        else:\n            fused_segments.append(segments[i])\n\n    reassembled = []\n    for segment in fused_segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 if pos == 0 or pos == len(reassembled) else 0.3\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.7 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm implements a novel multi-objective adaptive segment partitioning and dynamic segment rearrangement strategy that combines probabilistic segment splitting with intelligent segment repositioning, dynamically optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    split_points = sorted(random.sample(range(1, n), k=random.randint(1, min(3, n//2))))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    random.shuffle(segments)\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    rearranged = []\n    for segment in segments:\n        if not rearranged:\n            rearranged = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(rearranged) + 1):\n            candidate = rearranged[:pos] + segment.tolist() + rearranged[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(rearranged)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[rearranged[k-1], rearranged[k]] for k in range(len(rearranged))) + sum(distance_matrix_2[rearranged[k-1], rearranged[k]] for k in range(len(rearranged))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        rearranged = rearranged[:best_pos] + segment.tolist() + rearranged[best_pos:]\n\n    new_solution = np.array(rearranged)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.026054178293117,
            7.796957717036786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    split_points = sorted(random.sample(range(1, n), k=random.randint(1, min(3, n//2))))\n    segments = []\n    prev = 0\n    for point in split_points:\n        segments.append(new_solution[prev:point])\n        prev = point\n    segments.append(new_solution[prev:])\n\n    random.shuffle(segments)\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    rearranged = []\n    for segment in segments:\n        if not rearranged:\n            rearranged = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(rearranged) + 1):\n            candidate = rearranged[:pos] + segment.tolist() + rearranged[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(rearranged)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[rearranged[k-1], rearranged[k]] for k in range(len(rearranged))) + sum(distance_matrix_2[rearranged[k-1], rearranged[k]] for k in range(len(rearranged))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        rearranged = rearranged[:best_pos] + segment.tolist() + rearranged[best_pos:]\n\n    new_solution = np.array(rearranged)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm implements a multi-objective adaptive segment fusion and dynamic node rearrangement strategy that combines probabilistic segment merging with intelligent node repositioning, dynamically optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(2, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segments.append(segment)\n\n    fused_segments = []\n    for i in range(0, len(segments), 2):\n        if i + 1 < len(segments):\n            merged = np.concatenate((segments[i], segments[i+1]))\n            if random.random() < 0.5:\n                merged = merged[::-1]\n            fused_segments.append(merged)\n        else:\n            fused_segments.append(segments[i])\n\n    reassembled = []\n    for segment in fused_segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 if pos == 0 or pos == len(reassembled) else 0.3\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.7 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm implements an adaptive segment partitioning and multi-objective-aware node insertion strategy that combines dynamic segment splitting with intelligent node repositioning, optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_size = max(2, min(3, int(n * 0.15)))\n    num_partitions = random.randint(1, min(3, n // segment_size))\n\n    partitions = []\n    for _ in range(num_partitions):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        partition = new_solution[start:end]\n        partitions.append(partition)\n\n    for i in range(len(partitions)):\n        if random.random() < 0.7:\n            partitions[i] = partitions[i][::-1]\n\n    reassembled = []\n    for partition in partitions:\n        if not reassembled:\n            reassembled = partition.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + partition.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.6 if pos == 0 or pos == len(reassembled) else 0.2\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + partition.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.8 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            9.160028360414948,
            4.260669985927448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_size = max(2, min(3, int(n * 0.15)))\n    num_partitions = random.randint(1, min(3, n // segment_size))\n\n    partitions = []\n    for _ in range(num_partitions):\n        start = random.randint(0, n - segment_size)\n        end = start + segment_size\n        partition = new_solution[start:end]\n        partitions.append(partition)\n\n    for i in range(len(partitions)):\n        if random.random() < 0.7:\n            partitions[i] = partitions[i][::-1]\n\n    reassembled = []\n    for partition in partitions:\n        if not reassembled:\n            reassembled = partition.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + partition.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.6 if pos == 0 or pos == len(reassembled) else 0.2\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + partition.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.8 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm implements a novel multi-objective segment relocation and inversion strategy that identifies segments based on their contribution to both objectives, relocates them to positions that optimize both objectives simultaneously while ensuring feasibility, and inverts segments to explore additional solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(5, n // 2))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[relocated[k-1], relocated[k]] for k in range(len(relocated))) + sum(distance_matrix_2[relocated[k-1], relocated[k]] for k in range(len(relocated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm implements a multi-objective adaptive segment fusion and dynamic node rearrangement strategy that combines probabilistic segment merging with intelligent node repositioning, dynamically optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(2, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segments.append(segment)\n\n    fused_segments = []\n    for i in range(0, len(segments), 2):\n        if i + 1 < len(segments):\n            merged = np.concatenate((segments[i], segments[i+1]))\n            if random.random() < 0.5:\n                merged = merged[::-1]\n            fused_segments.append(merged)\n        else:\n            fused_segments.append(segments[i])\n\n    reassembled = []\n    for segment in fused_segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 if pos == 0 or pos == len(reassembled) else 0.3\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.7 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm implements a novel multi-objective adaptive node clustering and intelligent segment reordering strategy that first partitions the solution into clusters based on spatial proximity in both objective spaces, then intelligently reorders these clusters while applying dynamic segment inversion to explore diverse solution spaces, and finally optimizes cluster boundaries through adaptive node reassignment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    k = max(2, min(5, int(np.sqrt(n))))\n    clusters = []\n    for _ in range(k):\n        clusters.append([])\n\n    for i in range(n):\n        node = new_solution[i]\n        x1, y1, x2, y2 = instance[node]\n        best_cluster = 0\n        best_score = float('inf')\n\n        for c in range(k):\n            if not clusters[c]:\n                score = 0\n            else:\n                cluster_nodes = clusters[c]\n                avg_x1 = np.mean(instance[cluster_nodes, 0])\n                avg_y1 = np.mean(instance[cluster_nodes, 1])\n                avg_x2 = np.mean(instance[cluster_nodes, 2])\n                avg_y2 = np.mean(instance[cluster_nodes, 3])\n                dist1 = np.sqrt((x1 - avg_x1)**2 + (y1 - avg_y1)**2)\n                dist2 = np.sqrt((x2 - avg_x2)**2 + (y2 - avg_y2)**2)\n                score = dist1 + dist2\n\n            if score < best_score:\n                best_score = score\n                best_cluster = c\n\n        clusters[best_cluster].append(node)\n\n    for c in range(k):\n        if clusters[c] and random.random() < 0.6:\n            clusters[c] = clusters[c][::-1]\n\n    reassembled = []\n    for c in range(k):\n        if not clusters[c]:\n            continue\n\n        if not reassembled:\n            reassembled = clusters[c]\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + clusters[c] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 + 0.5 * (candidate_cost1 + candidate_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + clusters[c] + reassembled[best_pos:]\n\n    missing_nodes = set(range(n)) - set(reassembled)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(reassembled))\n            reassembled.insert(insert_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            5.866733042891395,
            7.570746693177809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    k = max(2, min(5, int(np.sqrt(n))))\n    clusters = []\n    for _ in range(k):\n        clusters.append([])\n\n    for i in range(n):\n        node = new_solution[i]\n        x1, y1, x2, y2 = instance[node]\n        best_cluster = 0\n        best_score = float('inf')\n\n        for c in range(k):\n            if not clusters[c]:\n                score = 0\n            else:\n                cluster_nodes = clusters[c]\n                avg_x1 = np.mean(instance[cluster_nodes, 0])\n                avg_y1 = np.mean(instance[cluster_nodes, 1])\n                avg_x2 = np.mean(instance[cluster_nodes, 2])\n                avg_y2 = np.mean(instance[cluster_nodes, 3])\n                dist1 = np.sqrt((x1 - avg_x1)**2 + (y1 - avg_y1)**2)\n                dist2 = np.sqrt((x2 - avg_x2)**2 + (y2 - avg_y2)**2)\n                score = dist1 + dist2\n\n            if score < best_score:\n                best_score = score\n                best_cluster = c\n\n        clusters[best_cluster].append(node)\n\n    for c in range(k):\n        if clusters[c] and random.random() < 0.6:\n            clusters[c] = clusters[c][::-1]\n\n    reassembled = []\n    for c in range(k):\n        if not clusters[c]:\n            continue\n\n        if not reassembled:\n            reassembled = clusters[c]\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + clusters[c] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 + 0.5 * (candidate_cost1 + candidate_cost2) / (sum(distance_matrix_1[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))) + sum(distance_matrix_2[reassembled[k-1], reassembled[k]] for k in range(len(reassembled))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + clusters[c] + reassembled[best_pos:]\n\n    missing_nodes = set(range(n)) - set(reassembled)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(reassembled))\n            reassembled.insert(insert_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    }
]